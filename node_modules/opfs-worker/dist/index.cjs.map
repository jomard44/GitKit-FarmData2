{"version":3,"file":"index.cjs","sources":["../src/facade.ts","../src/index.ts"],"sourcesContent":["import { wrap } from 'comlink';\n\nimport { decodeBuffer, encodeString, isBinaryFileExtension } from './utils/encoder';\nimport WorkerCtor from './worker?worker&inline';\n\nimport type {\n    BinaryEncoding,\n    DirentData,\n    Encoding,\n    FileOpenOptions,\n    FileStat,\n    OPFSOptions,\n    PathLike,\n    RemoteOPFSWorker,\n    RenameOptions,\n    StringEncoding,\n    WatchOptions\n} from './types';\n\n/**\n * Utility function to convert a PathLike to a string path\n * If it's a URI, extracts the pathname; otherwise returns the string as-is\n */\nfunction normalizePath(path: PathLike): string {\n    if (path instanceof URL) {\n        return path.pathname;\n    }\n\n    return path;\n}\n\n/**\n * Facade class that provides a clean interface for communicating with the OPFS worker\n * while hiding Comlink implementation details.\n */\nexport class OPFSFileSystem {\n    #worker: RemoteOPFSWorker;\n    promises: OPFSFileSystem = this;\n\n    constructor(options?: OPFSOptions) {\n        this.#worker = wrap<RemoteOPFSWorker>(new WorkerCtor());\n\n        // Set up options if provided\n        if (options) {\n            // We can't pass a BroadcastChannel instance to the worker, so we need to convert it to a string first\n            if (options.broadcastChannel && options.broadcastChannel instanceof BroadcastChannel) {\n                options.broadcastChannel = options.broadcastChannel.name;\n            }\n\n            // Initialize options asynchronously\n            void this.setOptions(options);\n        }\n    }\n\n    /**\n     * Start watching a file or directory for changes\n     */\n    watch(path: PathLike, options?: WatchOptions): () => void {\n        const normalizedPath = normalizePath(path);\n\n        void this.#worker.watch(normalizedPath, options);\n\n        return () => this.unwatch(normalizedPath);\n    }\n\n    /**\n     * Stop watching a previously watched path\n     */\n    unwatch(path: PathLike) {\n        const normalizedPath = normalizePath(path);\n\n        void this.#worker.unwatch(normalizedPath);\n    }\n\n    /**\n     * Update configuration options\n     */\n    async setOptions(options: OPFSOptions) {\n        return this.#worker.setOptions(options);\n    }\n\n    /**\n     * Get a complete index of all files and directories in the file system\n     */\n    async index(): Promise<Map<string, FileStat>> {\n        return this.#worker.index();\n    }\n\n    /**\n     * Read a file from the file system\n     */\n    // Overload for explicit string encoding - returns string\n    async readFile(path: PathLike, encoding: StringEncoding): Promise<string>;\n    // Overload for explicit binary encoding - returns Uint8Array\n    async readFile(path: PathLike, encoding: BinaryEncoding): Promise<Uint8Array>;\n    // Overload for options object with string encoding - returns string\n    async readFile(path: PathLike, options: { encoding: StringEncoding }): Promise<string>;\n    // Overload for options object with binary encoding - returns Uint8Array\n    async readFile(path: PathLike, options: { encoding: BinaryEncoding }): Promise<Uint8Array>;\n    // Overload for no encoding (auto-detected) - returns string | Uint8Array based on file extension\n    async readFile(path: PathLike): Promise<string | Uint8Array>;\n    // Implementation\n    async readFile(\n        path: PathLike,\n        optionsOrEncoding?: Encoding | { encoding?: Encoding }\n    ): Promise<string | Uint8Array> {\n        const normalizedPath = normalizePath(path);\n\n        // Handle both options object and direct encoding parameter for backward compatibility\n        let encoding: Encoding | undefined;\n\n        if (typeof optionsOrEncoding === 'string') {\n            encoding = optionsOrEncoding;\n        }\n        else if (optionsOrEncoding && typeof optionsOrEncoding === 'object') {\n            encoding = optionsOrEncoding.encoding;\n        }\n\n        // Get binary data from worker\n        const buffer = await this.#worker.readFile(normalizedPath);\n\n        // If no encoding specified, auto-detect based on file extension\n        if (!encoding) {\n            encoding = isBinaryFileExtension(normalizedPath) ? 'binary' : 'utf-8';\n        }\n\n        // Return binary data or decode to string\n        return (encoding === 'binary') ? buffer : decodeBuffer(buffer, encoding);\n    }\n\n    /**\n     * Write data to a file\n     */\n    async writeFile(\n        path: PathLike,\n        data: string | Uint8Array | ArrayBuffer,\n        options?: { encoding?: Encoding } | Encoding\n    ): Promise<void> {\n        const normalizedPath = normalizePath(path);\n\n        let encoding: Encoding | undefined;\n\n        if (typeof options === 'string') {\n            encoding = options;\n        }\n        else if (options && typeof options === 'object') {\n            encoding = options.encoding;\n        }\n\n        // If no encoding specified, auto-detect based on file extension\n        if (!encoding) {\n            encoding = (typeof data !== 'string' || isBinaryFileExtension(normalizedPath)) ? 'binary' : 'utf-8';\n        }\n\n        // Convert data to Uint8Array\n        const buffer = typeof data === 'string'\n            ? encodeString(data, encoding)\n            : (data instanceof Uint8Array ? data : new Uint8Array(data));\n\n        return this.#worker.writeFile(normalizedPath, buffer);\n    }\n\n    /**\n     * Append data to a file\n     */\n    async appendFile(\n        path: PathLike,\n        data: string | Uint8Array | ArrayBuffer,\n        encoding?: Encoding\n    ): Promise<void> {\n        const normalizedPath = normalizePath(path);\n\n        // If no encoding specified, auto-detect based on file extension\n        if (!encoding) {\n            encoding = (typeof data !== 'string' || isBinaryFileExtension(normalizedPath)) ? 'binary' : 'utf-8';\n        }\n\n        // Convert data to Uint8Array\n        const buffer = typeof data === 'string'\n            ? encodeString(data, encoding)\n            : (data instanceof Uint8Array ? data : new Uint8Array(data));\n\n        return this.#worker.appendFile(normalizedPath, buffer);\n    }\n\n    /**\n     * Create a directory\n     */\n    async mkdir(path: PathLike, mode?: number | { recursive?: boolean }): Promise<void> {\n        const normalizedPath = normalizePath(path);\n\n        let options: { recursive?: boolean } | undefined;\n\n        // OPFS doesn't support file modes, so we ignore the mode parameter\n        if (typeof mode === 'number') {\n            options = { recursive: false };\n        }\n        else {\n            options = mode;\n        }\n\n        return this.#worker.mkdir(normalizedPath, options);\n    }\n\n    /**\n     * Get file or directory statistics\n     */\n    async stat(path: PathLike): Promise<FileStat> {\n        const normalizedPath = normalizePath(path);\n\n        return this.#worker.stat(normalizedPath);\n    }\n\n    /**\n     * Read a directory's contents\n     */\n    async readDir(path: PathLike): Promise<DirentData[]> {\n        const normalizedPath = normalizePath(path);\n\n        return this.#worker.readDir(normalizedPath);\n    }\n\n    /**\n     * Check if a file or directory exists\n     */\n    async exists(path: PathLike): Promise<boolean> {\n        const normalizedPath = normalizePath(path);\n\n        return this.#worker.exists(normalizedPath);\n    }\n\n    /**\n     * Clear all contents of a directory without removing the directory itself\n     */\n    async clear(path?: PathLike): Promise<void> {\n        const normalizedPath = path ? normalizePath(path) : undefined;\n\n        return this.#worker.clear(normalizedPath);\n    }\n\n    /**\n     * Remove files and directories\n     */\n    async remove(path: PathLike, options?: { recursive?: boolean; force?: boolean }): Promise<void> {\n        const normalizedPath = normalizePath(path);\n\n        return this.#worker.remove(normalizedPath, options);\n    }\n\n    /**\n     * Alias for remove() for NodeJS like API compatibility\n     */\n    async unlink(path: PathLike): Promise<void> {\n        return this.remove(path);\n    }\n\n    /**\n     * Alias for remove() for NodeJS like API compatibility\n     */\n    async rm(path: PathLike, options?: { recursive?: boolean; force?: boolean }): Promise<void> {\n        return this.remove(path, options);\n    }\n\n    /**\n     * Alias for remove() for NodeJS like API compatibility\n     */\n    async rmdir(path: PathLike): Promise<void> {\n        return this.remove(path);\n    }\n\n    /**\n     * Alias for readDir() for NodeJS like API compatibility\n     */\n    async readdir(path: PathLike, _options?: unknown): Promise<DirentData[]> {\n        return this.readDir(path);\n    }\n\n    /**\n     * Alias for stat() for NodeJS like API compatibility\n     */\n    async lstat(path: PathLike): Promise<FileStat> {\n        return this.stat(path);\n    }\n\n    /**\n     * Note: OPFS doesn't support file modes, so this is a no-op and exists only for compatibility with tools like isomorphic-git\n     */\n    async chmod(_path: PathLike, _mode: number): Promise<void> {\n        return Promise.resolve();\n    }\n\n    /**\n     * Resolve a path to an absolute path\n     */\n    async realpath(path: PathLike): Promise<string> {\n        const normalizedPath = normalizePath(path);\n\n        return this.#worker.realpath(normalizedPath);\n    }\n\n    /**\n     * Rename a file or directory\n     */\n    async rename(oldPath: PathLike, newPath: PathLike, options?: RenameOptions): Promise<void> {\n        const normalizedOldPath = normalizePath(oldPath);\n        const normalizedNewPath = normalizePath(newPath);\n\n        return this.#worker.rename(normalizedOldPath, normalizedNewPath, options);\n    }\n\n    /**\n     * Copy files and directories\n     */\n    async copy(source: PathLike, destination: PathLike, options?: { recursive?: boolean; overwrite?: boolean }): Promise<void> {\n        const normalizedSource = normalizePath(source);\n        const normalizedDestination = normalizePath(destination);\n\n        return this.#worker.copy(normalizedSource, normalizedDestination, options);\n    }\n\n    /**\n     * Open a file and return a file descriptor\n     */\n    async open(path: PathLike, options?: FileOpenOptions): Promise<number> {\n        const normalizedPath = normalizePath(path);\n\n        return this.#worker.open(normalizedPath, options);\n    }\n\n    /**\n     * Close a file descriptor\n     */\n    async close(fd: number): Promise<void> {\n        return this.#worker.close(fd);\n    }\n\n    /**\n     * Read data from a file descriptor\n     * \n     * This method requires special handling due to Comlink transfer requirements.\n     * The buffer is transferred to the worker and back, so the original buffer\n     * becomes unusable after the call.\n     */\n    async read(\n        fd: number,\n        buffer: Uint8Array,\n        offset: number,\n        length: number,\n        position?: number | null | undefined\n    ): Promise<{ bytesRead: number; buffer: Uint8Array }> {\n        const { bytesRead, buffer: transferred } = await this.#worker.read(\n            fd,\n            // Temp buffer to preserve the original buffer\n            new Uint8Array(length),\n            0,\n            length,\n            position\n        );\n\n        // Copy the data from the transferred buffer to the original buffer\n        if (bytesRead > 0) {\n            buffer.set(transferred.subarray(0, bytesRead), offset);\n        }\n\n        return { bytesRead, buffer };\n    }\n\n    /**\n     * Write data to a file descriptor\n     */\n    async write(\n        fd: number,\n        buffer: Uint8Array,\n        offset?: number,\n        length?: number,\n        position?: number | null | undefined,\n        emitEvent?: boolean\n    ): Promise<number> {\n        return this.#worker.write(fd, buffer, offset, length, position, emitEvent);\n    }\n\n    /**\n     * Get file status information by file descriptor\n     */\n    async fstat(fd: number): Promise<FileStat> {\n        return this.#worker.fstat(fd);\n    }\n\n    /**\n     * Truncate file to specified size\n     */\n    async ftruncate(fd: number, size?: number): Promise<void> {\n        return this.#worker.ftruncate(fd, size);\n    }\n\n    /**\n     * Synchronize file data to storage (fsync equivalent)\n     */\n    async fsync(fd: number): Promise<void> {\n        return this.#worker.fsync(fd);\n    }\n\n    /**\n     * Dispose of resources and clean up the file system instance\n     */\n    dispose() {\n        void this.#worker.dispose();\n    }\n\n    /**\n     * Synchronize the file system with external data\n     */\n    async createIndex(entries: [PathLike, string | Uint8Array | Blob][]): Promise<void> {\n        const normalizedEntries = entries.map(([path, data]) => [normalizePath(path), data] as [string, string | Uint8Array | Blob]);\n\n        return this.#worker.createIndex(normalizedEntries);\n    }\n\n    /**\n     * Read a file as text with automatic encoding detection\n     */\n    async readText(path: PathLike, encoding: Encoding = 'utf-8'): Promise<string> {\n        const normalizedPath = normalizePath(path);\n        const buffer = await this.#worker.readFile(normalizedPath);\n\n        return decodeBuffer(buffer, encoding);\n    }\n\n    /**\n     * Write text to a file with specified encoding\n     */\n    async writeText(path: PathLike, text: string, encoding: Encoding = 'utf-8'): Promise<void> {\n        const normalizedPath = normalizePath(path);\n        const buffer = encodeString(text, encoding);\n\n        return this.#worker.writeFile(normalizedPath, buffer);\n    }\n\n    /**\n     * Append text to a file with specified encoding\n     */\n    async appendText(path: PathLike, text: string, encoding: Encoding = 'utf-8'): Promise<void> {\n        const normalizedPath = normalizePath(path);\n        const buffer = encodeString(text, encoding);\n\n        return this.#worker.appendFile(normalizedPath, buffer);\n    }\n}\n","import { OPFSFileSystem } from './facade';\n\nimport type { OPFSOptions } from './types';\n\nexport * from './types';\nexport * from './utils/errors';\nexport * from './utils/helpers';\nexport * from './utils/encoder';\nexport * from './facade';\n\n/**\n * Creates a new file system instance with inline worker\n * @param options - Optional configuration options\n * @returns Promise resolving to the file system interface\n */\nexport function createWorker(\n    options?: OPFSOptions\n): OPFSFileSystem {\n    return new OPFSFileSystem(options);\n}\n"],"names":["normalizePath","path","OPFSFileSystem","#worker","options","wrap","WorkerCtor","normalizedPath","optionsOrEncoding","encoding","buffer","isBinaryFileExtension","decodeBuffer","data","encodeString","mode","_options","_path","_mode","oldPath","newPath","normalizedOldPath","normalizedNewPath","source","destination","normalizedSource","normalizedDestination","fd","offset","length","position","bytesRead","transferred","emitEvent","size","entries","normalizedEntries","text","createWorker"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;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"}