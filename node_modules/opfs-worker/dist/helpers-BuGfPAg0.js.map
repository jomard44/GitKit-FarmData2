{"version":3,"file":"helpers-BuGfPAg0.js","sources":["../src/utils/errors.ts","../src/utils/encoder.ts","../src/types.ts","../node_modules/@isaacs/balanced-match/dist/esm/index.js","../node_modules/@isaacs/brace-expansion/dist/esm/index.js","../node_modules/minimatch/dist/esm/assert-valid-pattern.js","../node_modules/minimatch/dist/esm/brace-expressions.js","../node_modules/minimatch/dist/esm/unescape.js","../node_modules/minimatch/dist/esm/ast.js","../node_modules/minimatch/dist/esm/escape.js","../node_modules/minimatch/dist/esm/index.js","../src/utils/helpers.ts"],"sourcesContent":["/**\n * Error code to numeric errno mapping (Node.js compatible)\n */\nconst ERROR_CODE_TO_ERRNO: Record<string, number> = {\n    ENOENT: -2, // No such file or directory\n    EISDIR: -21, // Is a directory\n    ENOTDIR: -20, // Not a directory\n    EACCES: -13, // Permission denied\n    EEXIST: -17, // File exists\n    ENOTEMPTY: -39, // Directory not empty\n    EINVAL: -22, // Invalid argument\n    EIO: -5, // I/O error\n    ENOSPC: -28, // No space left on device\n    EBUSY: -16, // Device or resource busy\n    EINTR: -4, // Interrupted system call\n    ENOTSUP: -95, // Operation not supported\n    ERANGE: -34, // Result too large\n    EBADF: -9, // Bad file descriptor\n    EROOT: -1, // Custom: Cannot remove root directory\n};\n\n/**\n * Base error class for all OPFS-related errors (Node.js SystemError compatible)\n */\nexport class OPFSError extends Error {\n    public readonly errno: number;\n    public readonly syscall?: string;\n    public readonly path?: string;\n\n    constructor(\n        message: string,\n        code: string,\n        path?: string,\n        syscall?: string,\n        cause?: any\n    ) {\n        super(message, { cause });\n        this.name = code;\n        this.errno = ERROR_CODE_TO_ERRNO[code] || -1;\n        this.path = path;\n        this.syscall = syscall;\n    }\n}\n\n/**\n * Error thrown when OPFS is not supported in the current browser\n */\nexport class OPFSNotSupportedError extends OPFSError {\n    constructor(cause?: unknown) {\n        super('OPFS is not supported in this browser', 'OPFS_NOT_SUPPORTED', undefined, undefined, cause);\n    }\n}\n\n/**\n * Error thrown for invalid paths or path traversal attempts\n */\nexport class PathError extends OPFSError {\n    constructor(message: string, path: string, cause?: unknown) {\n        super(message, 'INVALID_PATH', path, 'access', cause);\n    }\n}\n\n/**\n * Error thrown when files or directories don't exist\n */\nexport class ExistenceError extends OPFSError {\n    constructor(type: 'file' | 'directory' | 'source', path: string, cause?: unknown) {\n        const messages = {\n            file: `File not found: ${ path }`,\n            directory: `Directory not found: ${ path }`,\n            source: `Source does not exist: ${ path }`,\n        };\n\n        super(messages[type], 'ENOENT', path, 'access', cause);\n    }\n}\n\n/**\n * Error thrown when permission is denied for an operation\n */\nexport class PermissionError extends OPFSError {\n    constructor(path: string, operation: string, cause?: unknown) {\n        super(`Permission denied for ${ operation } on: ${ path }`, 'PERMISSION_DENIED', path, operation, cause);\n    }\n}\n\n/**\n * Error thrown when an operation fails due to insufficient storage\n */\nexport class StorageError extends OPFSError {\n    constructor(message: string, path?: string, cause?: unknown) {\n        super(message, 'ENOSPC', path, 'write', cause);\n    }\n}\n\n/**\n * Error thrown when an operation times out\n */\nexport class TimeoutError extends OPFSError {\n    constructor(operation: string, path?: string, cause?: unknown) {\n        super(`Operation timed out: ${ operation }`, 'TIMEOUT_ERROR', path, operation, cause);\n    }\n}\n\n/**\n * Error thrown when a file is busy (locked by another operation)\n */\nexport class FileBusyError extends OPFSError {\n    constructor(path: string, cause?: unknown) {\n        super(`File is busy: ${ path }`, 'EBUSY', path, 'open', cause);\n    }\n}\n\n/**\n * Error thrown when file/directory type expectations don't match\n */\nexport class FileTypeError extends OPFSError {\n    constructor(expectedType: 'file' | 'directory', actualType: 'file' | 'directory', path: string, cause?: unknown) {\n        const message = actualType === 'directory'\n            ? `Is a directory: ${ path }`\n            : `Not a directory: ${ path }`;\n        const code = actualType === 'directory' ? 'EISDIR' : 'ENOTDIR';\n\n        super(message, code, path, 'access', cause);\n    }\n}\n\n/**\n * Error thrown for validation failures (invalid arguments, formats, etc.)\n */\nexport class ValidationError extends OPFSError {\n    constructor(type: 'argument' | 'format' | 'descriptor' | 'overflow', message: string, path?: string, cause?: unknown) {\n        const codes = {\n            argument: 'EINVAL',\n            format: 'INVALID_FORMAT',\n            descriptor: 'EBADF',\n            overflow: 'ERANGE',\n        };\n\n        super(message, codes[type], path, 'validate', cause);\n    }\n}\n\n/**\n * Error thrown when an operation is aborted\n */\nexport class OperationAbortedError extends OPFSError {\n    constructor(path: string, cause?: unknown) {\n        super(`Operation aborted: ${ path }`, 'EINTR', path, 'interrupt', cause);\n    }\n}\n\n/**\n * Error thrown for I/O operation failures\n */\nexport class IOError extends OPFSError {\n    constructor(message: string, path?: string, cause?: unknown) {\n        super(message, 'EIO', path, 'io', cause);\n    }\n}\n\n/**\n * Error thrown when an operation is not supported\n */\nexport class OperationNotSupportedError extends OPFSError {\n    constructor(path: string, cause?: unknown) {\n        super(`Operation not supported: ${ path }`, 'ENOTSUP', path, 'operation', cause);\n    }\n}\n\n/**\n * Error thrown when directory operations fail\n */\nexport class DirectoryOperationError extends OPFSError {\n    constructor(operation: 'remove' | 'clear' | 'root', path: string, cause?: unknown) {\n        const messages = {\n            remove: `Failed to remove entry: ${ path }`,\n            clear: `Directory not empty: ${ path }. Use recursive option to force removal.`,\n            root: 'Cannot remove root directory',\n        };\n        const codes = {\n            remove: 'RM_FAILED',\n            clear: 'ENOTEMPTY',\n            root: 'EROOT',\n        };\n\n        super(messages[operation], codes[operation], path, 'unlink', cause);\n    }\n}\n\n\n/**\n * Error thrown when OPFS initialization fails\n */\nexport class InitializationFailedError extends OPFSError {\n    constructor(path: string, cause?: unknown) {\n        super('Failed to initialize OPFS', 'INIT_FAILED', path, 'init', cause);\n    }\n}\n\n/**\n * Error thrown when file system operations fail\n */\nexport class FileSystemOperationError extends OPFSError {\n    constructor(operation: string, path: string, cause?: unknown) {\n        super(`Failed to ${ operation }: ${ path }`, `${ operation.toUpperCase() }_FAILED`, path, operation, cause);\n    }\n}\n\n/**\n * Error thrown when path resolution fails\n */\nexport class PathResolutionFailedError extends OPFSError {\n    constructor(path: string, cause?: unknown) {\n        super(`Failed to resolve path: ${ path }`, 'REALPATH_FAILED', path, 'realpath', cause);\n    }\n}\n\n/**\n * Error thrown when a file or directory already exists\n */\nexport class AlreadyExistsError extends OPFSError {\n    constructor(path: string, cause?: unknown) {\n        super(`Destination already exists: ${ path }`, 'EEXIST', path, 'open', cause);\n    }\n}\n\n/**\n * Create an OPFSError with file descriptor context\n * \n * @param operation - The operation that failed (e.g., 'read', 'write', 'close')\n * @param fd - The file descriptor number\n * @param path - The file path\n * @param error - The underlying error (optional)\n * @returns OPFSError with appropriate context\n */\nexport function createFDError(operation: string, fd: number, path: string, error?: any): OPFSError {\n    const errorCode = `${ operation.toUpperCase() }_FAILED` as 'READ_FAILED' | 'WRITE_FAILED' | 'CLOSE_FAILED';\n\n    return new OPFSError(`Failed to ${ operation } file descriptor: ${ fd }`, errorCode, path, operation, error);\n}\n\n/**\n * Map DOM exceptions to OPFS error codes\n * \n * @param error - The DOM exception to map\n * @param context - Context information for better error mapping\n * @param context.path - File path for context-specific errors\n * @param context.isDirectory - Whether the operation involves a directory\n * @returns OPFSError with appropriate error code\n */\nexport function mapDomError(error: any, context?: { path?: string; isDirectory?: boolean }): OPFSError {\n    const path = context?.path;\n    const isDirectory = context?.isDirectory;\n\n    switch (error.name) {\n        case 'InvalidStateError':\n            return new FileBusyError(path || 'unknown', error);\n\n        case 'QuotaExceededError':\n            return new StorageError(`No space left on device: ${ path || 'unknown' }`, path, error);\n\n        case 'NotFoundError':\n            return new ExistenceError('file', path!, error);\n\n        case 'TypeMismatchError':\n            if (isDirectory !== undefined) {\n                if (isDirectory) {\n                    return new FileTypeError('file', 'directory', path || 'unknown', error);\n                }\n                else {\n                    return new FileTypeError('directory', 'file', path || 'unknown', error);\n                }\n            }\n\n            // Fall through to default for ambiguous cases\n            return new ValidationError('argument', `Type mismatch: ${ path || 'unknown' }`, path, error);\n\n        case 'NotAllowedError':\n        case 'SecurityError':\n            return new PermissionError(path!, 'unknown', error);\n\n        case 'InvalidModificationError':\n            return new ValidationError('argument', `Invalid modification: ${ path || 'unknown' }`, path, error);\n\n        case 'AbortError':\n            return new OperationAbortedError(path || 'unknown', error);\n\n        case 'OperationError':\n            return new IOError(`Operation failed: ${ path || 'unknown' }`, path, error);\n\n        case 'TypeError':\n            return new OperationNotSupportedError(path || 'unknown', error);\n\n        default:\n            return new IOError(`I/O error: ${ path || 'unknown' }`, path, error);\n    }\n}\n","import { ValidationError } from './errors';\n\nimport type { Encoding } from '../types';\n\n\n/**\n * Common binary file extensions\n */\nexport const BINARY_FILE_EXTENSIONS = [\n    // Images\n    '.jpg',\n    '.jpeg',\n    '.png',\n    '.gif',\n    '.bmp',\n    '.webp',\n    '.ico',\n    '.tiff',\n    '.tga',\n    // Audio\n    '.mp3',\n    '.wav',\n    '.ogg',\n    '.flac',\n    '.aac',\n    '.wma',\n    '.m4a',\n    // Video\n    '.mp4',\n    '.avi',\n    '.mov',\n    '.wmv',\n    '.flv',\n    '.webm',\n    '.mkv',\n    '.m4v',\n    // Documents\n    '.pdf',\n    '.doc',\n    '.docx',\n    '.xls',\n    '.xlsx',\n    '.ppt',\n    '.pptx',\n    // Archives\n    '.zip',\n    '.rar',\n    '.7z',\n    '.tar',\n    '.gz',\n    '.bz2',\n    // Executables\n    '.exe',\n    '.dll',\n    '.so',\n    '.dylib',\n    // Other binary formats\n    '.dat',\n    '.db',\n    '.sqlite',\n    '.bin',\n    '.obj',\n    '.fbx',\n    '.3ds',\n] as const;\n\n/**\n * Check if a file extension indicates a binary file\n * \n * @param path - The file path or filename\n * @returns True if the file extension suggests binary content\n * \n * @example\n * ```typescript\n * isBinaryFileExtension('/path/to/image.jpg'); // true\n * isBinaryFileExtension('/path/to/document.txt'); // false\n * isBinaryFileExtension('data.bin'); // true\n * isBinaryFileExtension('data'); // true\n * ```\n */\nexport function isBinaryFileExtension(path: string): boolean {\n    const i = path.lastIndexOf('.');\n\n    if (i <= 0) {\n        return true;\n    }\n\n    const ext = path.slice(i).toLowerCase();\n\n    return BINARY_FILE_EXTENSIONS.includes(ext as any);\n}\n\nexport function encodeString(data: string, encoding: Encoding = 'utf-8'): Uint8Array {\n    switch (encoding) {\n        case 'utf8':\n        case 'utf-8':\n            return new TextEncoder().encode(data);\n\n        case 'utf16le':\n        case 'utf-16le':\n        case 'ucs2':\n        case 'ucs-2':\n            return encodeUtf16LE(data);\n\n        case 'ascii':\n            return encodeAscii(data);\n\n        case 'latin1':\n            return encodeLatin1(data);\n\n        case 'binary':\n            return Uint8Array.from(data, char => char.charCodeAt(0));\n\n        case 'base64':\n            return Uint8Array.from(atob(data), c => c.charCodeAt(0));\n\n        case 'hex':\n            if (!/^[\\da-f]+$/i.test(data) || data.length % 2 !== 0) {\n                throw new ValidationError('format', 'Invalid hex string');\n            }\n\n            return Uint8Array.from(data.match(/.{1,2}/g)!.map(b => parseInt(b, 16)));\n\n        default:\n            console.warn('Encoding not supported, falling back to UTF-8');\n\n            return new TextEncoder().encode(data);\n    }\n}\n\nexport function decodeBuffer(buffer: Uint8Array, encoding: Encoding = 'utf-8'): string {\n    // eslint-disable-next-line ts/switch-exhaustiveness-check\n    switch (encoding) {\n        case 'utf8':\n        case 'utf-8':\n            return new TextDecoder().decode(buffer);\n\n        case 'utf16le':\n        case 'utf-16le':\n        case 'ucs2':\n        case 'ucs-2':\n            return decodeUtf16LE(buffer);\n\n        case 'latin1':\n            return String.fromCharCode(...buffer);\n\n        case 'ascii':\n            return String.fromCharCode(...buffer.map(b => b & 0x7F));\n\n        case 'base64':\n            return btoa(String.fromCharCode(...buffer));\n\n        case 'hex':\n            return Array.from(buffer).map(b => b.toString(16).padStart(2, '0')).join('');\n\n        default:\n            console.warn('Unsupported encoding, falling back to UTF-8');\n\n            return new TextDecoder().decode(buffer);\n    }\n}\n\nfunction encodeUtf16LE(str: string): Uint8Array {\n    const buf = new Uint8Array(str.length * 2);\n\n    for (let i = 0; i < str.length; i++) {\n        const code = str.charCodeAt(i);\n\n        buf[(i * 2)] = code & 0xFF;\n        buf[(i * 2) + 1] = code >> 8;\n    }\n\n    return buf;\n}\n\nfunction decodeUtf16LE(buf: Uint8Array): string {\n    if (buf.length % 2 !== 0) {\n        console.warn('Invalid UTF-16LE buffer length, truncating last byte');\n        buf = buf.slice(0, buf.length - 1);\n    }\n\n    const codeUnits = new Uint16Array(buf.buffer, buf.byteOffset, buf.byteLength / 2);\n\n    return String.fromCharCode(...codeUnits);\n}\n\nfunction encodeLatin1(str: string): Uint8Array {\n    const buf = new Uint8Array(str.length);\n\n    for (let i = 0; i < str.length; i++) {\n        buf[i] = str.charCodeAt(i) & 0xFF;\n    }\n\n    return buf;\n}\n\nfunction encodeAscii(str: string): Uint8Array {\n    const buf = new Uint8Array(str.length);\n\n    for (let i = 0; i < str.length; i++) {\n        buf[i] = str.charCodeAt(i) & 0x7F;\n    }\n\n    return buf;\n}\n","import type { OPFSWorker } from './worker';\nimport type { Remote } from 'comlink';\n\n/**\n * Type for paths that can be either a string or URI\n */\nexport type PathLike = string | URL;\n\nexport type Kind = 'file' | 'directory';\n\nexport type StringEncoding = 'ascii'\n  | 'utf8'\n  | 'utf-8'\n  | 'utf16le'\n  | 'utf-16le'\n  | 'ucs2'\n  | 'ucs-2'\n  | 'base64'\n  | 'latin1'\n  | 'hex';\n\nexport type BinaryEncoding = 'binary';\n\nexport type Encoding = StringEncoding | BinaryEncoding;\n\nexport interface FileStat {\n    kind: Kind;\n    size: number;\n    mtime: string; // ISO string\n    ctime: string; // ISO string\n    isFile: boolean;\n    isDirectory: boolean;\n    /** Hash of file content (only for files, undefined for directories) */\n    hash?: string;\n}\n\nexport interface DirentData {\n    name: string;\n    kind: 'file' | 'directory';\n    isFile: boolean;\n    isDirectory: boolean;\n}\n\nexport enum WatchEventType {\n    Added = 'added',\n    Changed = 'changed',\n    Removed = 'removed'\n}\n\nexport interface WatchEvent {\n    namespace: string;\n    path: string;\n    type: WatchEventType;\n    isDirectory: boolean;\n    timestamp: string;\n    hash?: string;\n}\n\nexport type { OPFSWorker };\nexport type RemoteOPFSWorker = Remote<OPFSWorker>;\n\nexport interface OPFSOptions {\n    /** Root path for the file system (default: '/') */\n    root?: string;\n    /** Namespace for the events (default: 'opfs-worker:${root}') */\n    namespace?: string;\n    /** Hash algorithm for file hashing, or false/null to disable (default: 'etag') */\n    hashAlgorithm?: null | false | 'etag' | 'SHA-1' | 'SHA-256' | 'SHA-384' | 'SHA-512';\n    /** Maximum file size in bytes for hashing (default: 50MB) */\n    maxFileSize?: number;\n    /** Custom name for the broadcast channel (default: 'opfs-worker') */\n    broadcastChannel?: string | BroadcastChannel | null;\n}\n\nexport interface RenameOptions {\n    /** Whether to overwrite existing files (default: false) */\n    overwrite?: boolean;\n}\n\nexport interface WatchOptions {\n    /** Whether to watch recursively (default: true) */\n    recursive?: boolean;\n    /** Glob patterns to include in watching (minimatch syntax, default: ['**']) */\n    include?: string | string[];\n    /** Glob patterns to exclude from watching (minimatch syntax, default: []) */\n    exclude?: string | string[];\n}\n\nexport interface FileOpenOptions {\n    create?: boolean;\n    exclusive?: boolean;\n    truncate?: boolean;\n}\n\nexport interface WatchSnapshot {\n    pattern: string;\n    include: string[];\n    exclude: string[];\n}\n","export const balanced = (a, b, str) => {\n    const ma = a instanceof RegExp ? maybeMatch(a, str) : a;\n    const mb = b instanceof RegExp ? maybeMatch(b, str) : b;\n    const r = ma !== null && mb != null && range(ma, mb, str);\n    return (r && {\n        start: r[0],\n        end: r[1],\n        pre: str.slice(0, r[0]),\n        body: str.slice(r[0] + ma.length, r[1]),\n        post: str.slice(r[1] + mb.length),\n    });\n};\nconst maybeMatch = (reg, str) => {\n    const m = str.match(reg);\n    return m ? m[0] : null;\n};\nexport const range = (a, b, str) => {\n    let begs, beg, left, right = undefined, result;\n    let ai = str.indexOf(a);\n    let bi = str.indexOf(b, ai + 1);\n    let i = ai;\n    if (ai >= 0 && bi > 0) {\n        if (a === b) {\n            return [ai, bi];\n        }\n        begs = [];\n        left = str.length;\n        while (i >= 0 && !result) {\n            if (i === ai) {\n                begs.push(i);\n                ai = str.indexOf(a, i + 1);\n            }\n            else if (begs.length === 1) {\n                const r = begs.pop();\n                if (r !== undefined)\n                    result = [r, bi];\n            }\n            else {\n                beg = begs.pop();\n                if (beg !== undefined && beg < left) {\n                    left = beg;\n                    right = bi;\n                }\n                bi = str.indexOf(b, i + 1);\n            }\n            i = ai < bi && ai >= 0 ? ai : bi;\n        }\n        if (begs.length && right !== undefined) {\n            result = [left, right];\n        }\n    }\n    return result;\n};\n//# sourceMappingURL=index.js.map","import { balanced } from '@isaacs/balanced-match';\nconst escSlash = '\\0SLASH' + Math.random() + '\\0';\nconst escOpen = '\\0OPEN' + Math.random() + '\\0';\nconst escClose = '\\0CLOSE' + Math.random() + '\\0';\nconst escComma = '\\0COMMA' + Math.random() + '\\0';\nconst escPeriod = '\\0PERIOD' + Math.random() + '\\0';\nconst escSlashPattern = new RegExp(escSlash, 'g');\nconst escOpenPattern = new RegExp(escOpen, 'g');\nconst escClosePattern = new RegExp(escClose, 'g');\nconst escCommaPattern = new RegExp(escComma, 'g');\nconst escPeriodPattern = new RegExp(escPeriod, 'g');\nconst slashPattern = /\\\\\\\\/g;\nconst openPattern = /\\\\{/g;\nconst closePattern = /\\\\}/g;\nconst commaPattern = /\\\\,/g;\nconst periodPattern = /\\\\./g;\nfunction numeric(str) {\n    return !isNaN(str) ? parseInt(str, 10) : str.charCodeAt(0);\n}\nfunction escapeBraces(str) {\n    return str\n        .replace(slashPattern, escSlash)\n        .replace(openPattern, escOpen)\n        .replace(closePattern, escClose)\n        .replace(commaPattern, escComma)\n        .replace(periodPattern, escPeriod);\n}\nfunction unescapeBraces(str) {\n    return str\n        .replace(escSlashPattern, '\\\\')\n        .replace(escOpenPattern, '{')\n        .replace(escClosePattern, '}')\n        .replace(escCommaPattern, ',')\n        .replace(escPeriodPattern, '.');\n}\n/**\n * Basically just str.split(\",\"), but handling cases\n * where we have nested braced sections, which should be\n * treated as individual members, like {a,{b,c},d}\n */\nfunction parseCommaParts(str) {\n    if (!str) {\n        return [''];\n    }\n    const parts = [];\n    const m = balanced('{', '}', str);\n    if (!m) {\n        return str.split(',');\n    }\n    const { pre, body, post } = m;\n    const p = pre.split(',');\n    p[p.length - 1] += '{' + body + '}';\n    const postParts = parseCommaParts(post);\n    if (post.length) {\n        ;\n        p[p.length - 1] += postParts.shift();\n        p.push.apply(p, postParts);\n    }\n    parts.push.apply(parts, p);\n    return parts;\n}\nexport function expand(str) {\n    if (!str) {\n        return [];\n    }\n    // I don't know why Bash 4.3 does this, but it does.\n    // Anything starting with {} will have the first two bytes preserved\n    // but *only* at the top level, so {},a}b will not expand to anything,\n    // but a{},b}c will be expanded to [a}c,abc].\n    // One could argue that this is a bug in Bash, but since the goal of\n    // this module is to match Bash's rules, we escape a leading {}\n    if (str.slice(0, 2) === '{}') {\n        str = '\\\\{\\\\}' + str.slice(2);\n    }\n    return expand_(escapeBraces(str), true).map(unescapeBraces);\n}\nfunction embrace(str) {\n    return '{' + str + '}';\n}\nfunction isPadded(el) {\n    return /^-?0\\d/.test(el);\n}\nfunction lte(i, y) {\n    return i <= y;\n}\nfunction gte(i, y) {\n    return i >= y;\n}\nfunction expand_(str, isTop) {\n    /** @type {string[]} */\n    const expansions = [];\n    const m = balanced('{', '}', str);\n    if (!m)\n        return [str];\n    // no need to expand pre, since it is guaranteed to be free of brace-sets\n    const pre = m.pre;\n    const post = m.post.length ? expand_(m.post, false) : [''];\n    if (/\\$$/.test(m.pre)) {\n        for (let k = 0; k < post.length; k++) {\n            const expansion = pre + '{' + m.body + '}' + post[k];\n            expansions.push(expansion);\n        }\n    }\n    else {\n        const isNumericSequence = /^-?\\d+\\.\\.-?\\d+(?:\\.\\.-?\\d+)?$/.test(m.body);\n        const isAlphaSequence = /^[a-zA-Z]\\.\\.[a-zA-Z](?:\\.\\.-?\\d+)?$/.test(m.body);\n        const isSequence = isNumericSequence || isAlphaSequence;\n        const isOptions = m.body.indexOf(',') >= 0;\n        if (!isSequence && !isOptions) {\n            // {a},b}\n            if (m.post.match(/,(?!,).*\\}/)) {\n                str = m.pre + '{' + m.body + escClose + m.post;\n                return expand_(str);\n            }\n            return [str];\n        }\n        let n;\n        if (isSequence) {\n            n = m.body.split(/\\.\\./);\n        }\n        else {\n            n = parseCommaParts(m.body);\n            if (n.length === 1 && n[0] !== undefined) {\n                // x{{a,b}}y ==> x{a}y x{b}y\n                n = expand_(n[0], false).map(embrace);\n                //XXX is this necessary? Can't seem to hit it in tests.\n                /* c8 ignore start */\n                if (n.length === 1) {\n                    return post.map(p => m.pre + n[0] + p);\n                }\n                /* c8 ignore stop */\n            }\n        }\n        // at this point, n is the parts, and we know it's not a comma set\n        // with a single entry.\n        let N;\n        if (isSequence && n[0] !== undefined && n[1] !== undefined) {\n            const x = numeric(n[0]);\n            const y = numeric(n[1]);\n            const width = Math.max(n[0].length, n[1].length);\n            let incr = n.length === 3 && n[2] !== undefined ? Math.abs(numeric(n[2])) : 1;\n            let test = lte;\n            const reverse = y < x;\n            if (reverse) {\n                incr *= -1;\n                test = gte;\n            }\n            const pad = n.some(isPadded);\n            N = [];\n            for (let i = x; test(i, y); i += incr) {\n                let c;\n                if (isAlphaSequence) {\n                    c = String.fromCharCode(i);\n                    if (c === '\\\\') {\n                        c = '';\n                    }\n                }\n                else {\n                    c = String(i);\n                    if (pad) {\n                        const need = width - c.length;\n                        if (need > 0) {\n                            const z = new Array(need + 1).join('0');\n                            if (i < 0) {\n                                c = '-' + z + c.slice(1);\n                            }\n                            else {\n                                c = z + c;\n                            }\n                        }\n                    }\n                }\n                N.push(c);\n            }\n        }\n        else {\n            N = [];\n            for (let j = 0; j < n.length; j++) {\n                N.push.apply(N, expand_(n[j], false));\n            }\n        }\n        for (let j = 0; j < N.length; j++) {\n            for (let k = 0; k < post.length; k++) {\n                const expansion = pre + N[j] + post[k];\n                if (!isTop || isSequence || expansion) {\n                    expansions.push(expansion);\n                }\n            }\n        }\n    }\n    return expansions;\n}\n//# sourceMappingURL=index.js.map","const MAX_PATTERN_LENGTH = 1024 * 64;\nexport const assertValidPattern = (pattern) => {\n    if (typeof pattern !== 'string') {\n        throw new TypeError('invalid pattern');\n    }\n    if (pattern.length > MAX_PATTERN_LENGTH) {\n        throw new TypeError('pattern is too long');\n    }\n};\n//# sourceMappingURL=assert-valid-pattern.js.map","// translate the various posix character classes into unicode properties\n// this works across all unicode locales\n// { <posix class>: [<translation>, /u flag required, negated]\nconst posixClasses = {\n    '[:alnum:]': ['\\\\p{L}\\\\p{Nl}\\\\p{Nd}', true],\n    '[:alpha:]': ['\\\\p{L}\\\\p{Nl}', true],\n    '[:ascii:]': ['\\\\x' + '00-\\\\x' + '7f', false],\n    '[:blank:]': ['\\\\p{Zs}\\\\t', true],\n    '[:cntrl:]': ['\\\\p{Cc}', true],\n    '[:digit:]': ['\\\\p{Nd}', true],\n    '[:graph:]': ['\\\\p{Z}\\\\p{C}', true, true],\n    '[:lower:]': ['\\\\p{Ll}', true],\n    '[:print:]': ['\\\\p{C}', true],\n    '[:punct:]': ['\\\\p{P}', true],\n    '[:space:]': ['\\\\p{Z}\\\\t\\\\r\\\\n\\\\v\\\\f', true],\n    '[:upper:]': ['\\\\p{Lu}', true],\n    '[:word:]': ['\\\\p{L}\\\\p{Nl}\\\\p{Nd}\\\\p{Pc}', true],\n    '[:xdigit:]': ['A-Fa-f0-9', false],\n};\n// only need to escape a few things inside of brace expressions\n// escapes: [ \\ ] -\nconst braceEscape = (s) => s.replace(/[[\\]\\\\-]/g, '\\\\$&');\n// escape all regexp magic characters\nconst regexpEscape = (s) => s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n// everything has already been escaped, we just have to join\nconst rangesToString = (ranges) => ranges.join('');\n// takes a glob string at a posix brace expression, and returns\n// an equivalent regular expression source, and boolean indicating\n// whether the /u flag needs to be applied, and the number of chars\n// consumed to parse the character class.\n// This also removes out of order ranges, and returns ($.) if the\n// entire class just no good.\nexport const parseClass = (glob, position) => {\n    const pos = position;\n    /* c8 ignore start */\n    if (glob.charAt(pos) !== '[') {\n        throw new Error('not in a brace expression');\n    }\n    /* c8 ignore stop */\n    const ranges = [];\n    const negs = [];\n    let i = pos + 1;\n    let sawStart = false;\n    let uflag = false;\n    let escaping = false;\n    let negate = false;\n    let endPos = pos;\n    let rangeStart = '';\n    WHILE: while (i < glob.length) {\n        const c = glob.charAt(i);\n        if ((c === '!' || c === '^') && i === pos + 1) {\n            negate = true;\n            i++;\n            continue;\n        }\n        if (c === ']' && sawStart && !escaping) {\n            endPos = i + 1;\n            break;\n        }\n        sawStart = true;\n        if (c === '\\\\') {\n            if (!escaping) {\n                escaping = true;\n                i++;\n                continue;\n            }\n            // escaped \\ char, fall through and treat like normal char\n        }\n        if (c === '[' && !escaping) {\n            // either a posix class, a collation equivalent, or just a [\n            for (const [cls, [unip, u, neg]] of Object.entries(posixClasses)) {\n                if (glob.startsWith(cls, i)) {\n                    // invalid, [a-[] is fine, but not [a-[:alpha]]\n                    if (rangeStart) {\n                        return ['$.', false, glob.length - pos, true];\n                    }\n                    i += cls.length;\n                    if (neg)\n                        negs.push(unip);\n                    else\n                        ranges.push(unip);\n                    uflag = uflag || u;\n                    continue WHILE;\n                }\n            }\n        }\n        // now it's just a normal character, effectively\n        escaping = false;\n        if (rangeStart) {\n            // throw this range away if it's not valid, but others\n            // can still match.\n            if (c > rangeStart) {\n                ranges.push(braceEscape(rangeStart) + '-' + braceEscape(c));\n            }\n            else if (c === rangeStart) {\n                ranges.push(braceEscape(c));\n            }\n            rangeStart = '';\n            i++;\n            continue;\n        }\n        // now might be the start of a range.\n        // can be either c-d or c-] or c<more...>] or c] at this point\n        if (glob.startsWith('-]', i + 1)) {\n            ranges.push(braceEscape(c + '-'));\n            i += 2;\n            continue;\n        }\n        if (glob.startsWith('-', i + 1)) {\n            rangeStart = c;\n            i += 2;\n            continue;\n        }\n        // not the start of a range, just a single character\n        ranges.push(braceEscape(c));\n        i++;\n    }\n    if (endPos < i) {\n        // didn't see the end of the class, not a valid class,\n        // but might still be valid as a literal match.\n        return ['', false, 0, false];\n    }\n    // if we got no ranges and no negates, then we have a range that\n    // cannot possibly match anything, and that poisons the whole glob\n    if (!ranges.length && !negs.length) {\n        return ['$.', false, glob.length - pos, true];\n    }\n    // if we got one positive range, and it's a single character, then that's\n    // not actually a magic pattern, it's just that one literal character.\n    // we should not treat that as \"magic\", we should just return the literal\n    // character. [_] is a perfectly valid way to escape glob magic chars.\n    if (negs.length === 0 &&\n        ranges.length === 1 &&\n        /^\\\\?.$/.test(ranges[0]) &&\n        !negate) {\n        const r = ranges[0].length === 2 ? ranges[0].slice(-1) : ranges[0];\n        return [regexpEscape(r), false, endPos - pos, false];\n    }\n    const sranges = '[' + (negate ? '^' : '') + rangesToString(ranges) + ']';\n    const snegs = '[' + (negate ? '' : '^') + rangesToString(negs) + ']';\n    const comb = ranges.length && negs.length\n        ? '(' + sranges + '|' + snegs + ')'\n        : ranges.length\n            ? sranges\n            : snegs;\n    return [comb, uflag, endPos - pos, true];\n};\n//# sourceMappingURL=brace-expressions.js.map","/**\n * Un-escape a string that has been escaped with {@link escape}.\n *\n * If the {@link windowsPathsNoEscape} option is used, then square-brace\n * escapes are removed, but not backslash escapes.  For example, it will turn\n * the string `'[*]'` into `*`, but it will not turn `'\\\\*'` into `'*'`,\n * becuase `\\` is a path separator in `windowsPathsNoEscape` mode.\n *\n * When `windowsPathsNoEscape` is not set, then both brace escapes and\n * backslash escapes are removed.\n *\n * Slashes (and backslashes in `windowsPathsNoEscape` mode) cannot be escaped\n * or unescaped.\n */\nexport const unescape = (s, { windowsPathsNoEscape = false, } = {}) => {\n    return windowsPathsNoEscape\n        ? s.replace(/\\[([^\\/\\\\])\\]/g, '$1')\n        : s.replace(/((?!\\\\).|^)\\[([^\\/\\\\])\\]/g, '$1$2').replace(/\\\\([^\\/])/g, '$1');\n};\n//# sourceMappingURL=unescape.js.map","// parse a single path portion\nimport { parseClass } from './brace-expressions.js';\nimport { unescape } from './unescape.js';\nconst types = new Set(['!', '?', '+', '*', '@']);\nconst isExtglobType = (c) => types.has(c);\n// Patterns that get prepended to bind to the start of either the\n// entire string, or just a single path portion, to prevent dots\n// and/or traversal patterns, when needed.\n// Exts don't need the ^ or / bit, because the root binds that already.\nconst startNoTraversal = '(?!(?:^|/)\\\\.\\\\.?(?:$|/))';\nconst startNoDot = '(?!\\\\.)';\n// characters that indicate a start of pattern needs the \"no dots\" bit,\n// because a dot *might* be matched. ( is not in the list, because in\n// the case of a child extglob, it will handle the prevention itself.\nconst addPatternStart = new Set(['[', '.']);\n// cases where traversal is A-OK, no dot prevention needed\nconst justDots = new Set(['..', '.']);\nconst reSpecials = new Set('().*{}+?[]^$\\\\!');\nconst regExpEscape = (s) => s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n// any single thing other than /\nconst qmark = '[^/]';\n// * => any number of characters\nconst star = qmark + '*?';\n// use + when we need to ensure that *something* matches, because the * is\n// the only thing in the path portion.\nconst starNoEmpty = qmark + '+?';\n// remove the \\ chars that we added if we end up doing a nonmagic compare\n// const deslash = (s: string) => s.replace(/\\\\(.)/g, '$1')\nexport class AST {\n    type;\n    #root;\n    #hasMagic;\n    #uflag = false;\n    #parts = [];\n    #parent;\n    #parentIndex;\n    #negs;\n    #filledNegs = false;\n    #options;\n    #toString;\n    // set to true if it's an extglob with no children\n    // (which really means one child of '')\n    #emptyExt = false;\n    constructor(type, parent, options = {}) {\n        this.type = type;\n        // extglobs are inherently magical\n        if (type)\n            this.#hasMagic = true;\n        this.#parent = parent;\n        this.#root = this.#parent ? this.#parent.#root : this;\n        this.#options = this.#root === this ? options : this.#root.#options;\n        this.#negs = this.#root === this ? [] : this.#root.#negs;\n        if (type === '!' && !this.#root.#filledNegs)\n            this.#negs.push(this);\n        this.#parentIndex = this.#parent ? this.#parent.#parts.length : 0;\n    }\n    get hasMagic() {\n        /* c8 ignore start */\n        if (this.#hasMagic !== undefined)\n            return this.#hasMagic;\n        /* c8 ignore stop */\n        for (const p of this.#parts) {\n            if (typeof p === 'string')\n                continue;\n            if (p.type || p.hasMagic)\n                return (this.#hasMagic = true);\n        }\n        // note: will be undefined until we generate the regexp src and find out\n        return this.#hasMagic;\n    }\n    // reconstructs the pattern\n    toString() {\n        if (this.#toString !== undefined)\n            return this.#toString;\n        if (!this.type) {\n            return (this.#toString = this.#parts.map(p => String(p)).join(''));\n        }\n        else {\n            return (this.#toString =\n                this.type + '(' + this.#parts.map(p => String(p)).join('|') + ')');\n        }\n    }\n    #fillNegs() {\n        /* c8 ignore start */\n        if (this !== this.#root)\n            throw new Error('should only call on root');\n        if (this.#filledNegs)\n            return this;\n        /* c8 ignore stop */\n        // call toString() once to fill this out\n        this.toString();\n        this.#filledNegs = true;\n        let n;\n        while ((n = this.#negs.pop())) {\n            if (n.type !== '!')\n                continue;\n            // walk up the tree, appending everthing that comes AFTER parentIndex\n            let p = n;\n            let pp = p.#parent;\n            while (pp) {\n                for (let i = p.#parentIndex + 1; !pp.type && i < pp.#parts.length; i++) {\n                    for (const part of n.#parts) {\n                        /* c8 ignore start */\n                        if (typeof part === 'string') {\n                            throw new Error('string part in extglob AST??');\n                        }\n                        /* c8 ignore stop */\n                        part.copyIn(pp.#parts[i]);\n                    }\n                }\n                p = pp;\n                pp = p.#parent;\n            }\n        }\n        return this;\n    }\n    push(...parts) {\n        for (const p of parts) {\n            if (p === '')\n                continue;\n            /* c8 ignore start */\n            if (typeof p !== 'string' && !(p instanceof AST && p.#parent === this)) {\n                throw new Error('invalid part: ' + p);\n            }\n            /* c8 ignore stop */\n            this.#parts.push(p);\n        }\n    }\n    toJSON() {\n        const ret = this.type === null\n            ? this.#parts.slice().map(p => (typeof p === 'string' ? p : p.toJSON()))\n            : [this.type, ...this.#parts.map(p => p.toJSON())];\n        if (this.isStart() && !this.type)\n            ret.unshift([]);\n        if (this.isEnd() &&\n            (this === this.#root ||\n                (this.#root.#filledNegs && this.#parent?.type === '!'))) {\n            ret.push({});\n        }\n        return ret;\n    }\n    isStart() {\n        if (this.#root === this)\n            return true;\n        // if (this.type) return !!this.#parent?.isStart()\n        if (!this.#parent?.isStart())\n            return false;\n        if (this.#parentIndex === 0)\n            return true;\n        // if everything AHEAD of this is a negation, then it's still the \"start\"\n        const p = this.#parent;\n        for (let i = 0; i < this.#parentIndex; i++) {\n            const pp = p.#parts[i];\n            if (!(pp instanceof AST && pp.type === '!')) {\n                return false;\n            }\n        }\n        return true;\n    }\n    isEnd() {\n        if (this.#root === this)\n            return true;\n        if (this.#parent?.type === '!')\n            return true;\n        if (!this.#parent?.isEnd())\n            return false;\n        if (!this.type)\n            return this.#parent?.isEnd();\n        // if not root, it'll always have a parent\n        /* c8 ignore start */\n        const pl = this.#parent ? this.#parent.#parts.length : 0;\n        /* c8 ignore stop */\n        return this.#parentIndex === pl - 1;\n    }\n    copyIn(part) {\n        if (typeof part === 'string')\n            this.push(part);\n        else\n            this.push(part.clone(this));\n    }\n    clone(parent) {\n        const c = new AST(this.type, parent);\n        for (const p of this.#parts) {\n            c.copyIn(p);\n        }\n        return c;\n    }\n    static #parseAST(str, ast, pos, opt) {\n        let escaping = false;\n        let inBrace = false;\n        let braceStart = -1;\n        let braceNeg = false;\n        if (ast.type === null) {\n            // outside of a extglob, append until we find a start\n            let i = pos;\n            let acc = '';\n            while (i < str.length) {\n                const c = str.charAt(i++);\n                // still accumulate escapes at this point, but we do ignore\n                // starts that are escaped\n                if (escaping || c === '\\\\') {\n                    escaping = !escaping;\n                    acc += c;\n                    continue;\n                }\n                if (inBrace) {\n                    if (i === braceStart + 1) {\n                        if (c === '^' || c === '!') {\n                            braceNeg = true;\n                        }\n                    }\n                    else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {\n                        inBrace = false;\n                    }\n                    acc += c;\n                    continue;\n                }\n                else if (c === '[') {\n                    inBrace = true;\n                    braceStart = i;\n                    braceNeg = false;\n                    acc += c;\n                    continue;\n                }\n                if (!opt.noext && isExtglobType(c) && str.charAt(i) === '(') {\n                    ast.push(acc);\n                    acc = '';\n                    const ext = new AST(c, ast);\n                    i = AST.#parseAST(str, ext, i, opt);\n                    ast.push(ext);\n                    continue;\n                }\n                acc += c;\n            }\n            ast.push(acc);\n            return i;\n        }\n        // some kind of extglob, pos is at the (\n        // find the next | or )\n        let i = pos + 1;\n        let part = new AST(null, ast);\n        const parts = [];\n        let acc = '';\n        while (i < str.length) {\n            const c = str.charAt(i++);\n            // still accumulate escapes at this point, but we do ignore\n            // starts that are escaped\n            if (escaping || c === '\\\\') {\n                escaping = !escaping;\n                acc += c;\n                continue;\n            }\n            if (inBrace) {\n                if (i === braceStart + 1) {\n                    if (c === '^' || c === '!') {\n                        braceNeg = true;\n                    }\n                }\n                else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {\n                    inBrace = false;\n                }\n                acc += c;\n                continue;\n            }\n            else if (c === '[') {\n                inBrace = true;\n                braceStart = i;\n                braceNeg = false;\n                acc += c;\n                continue;\n            }\n            if (isExtglobType(c) && str.charAt(i) === '(') {\n                part.push(acc);\n                acc = '';\n                const ext = new AST(c, part);\n                part.push(ext);\n                i = AST.#parseAST(str, ext, i, opt);\n                continue;\n            }\n            if (c === '|') {\n                part.push(acc);\n                acc = '';\n                parts.push(part);\n                part = new AST(null, ast);\n                continue;\n            }\n            if (c === ')') {\n                if (acc === '' && ast.#parts.length === 0) {\n                    ast.#emptyExt = true;\n                }\n                part.push(acc);\n                acc = '';\n                ast.push(...parts, part);\n                return i;\n            }\n            acc += c;\n        }\n        // unfinished extglob\n        // if we got here, it was a malformed extglob! not an extglob, but\n        // maybe something else in there.\n        ast.type = null;\n        ast.#hasMagic = undefined;\n        ast.#parts = [str.substring(pos - 1)];\n        return i;\n    }\n    static fromGlob(pattern, options = {}) {\n        const ast = new AST(null, undefined, options);\n        AST.#parseAST(pattern, ast, 0, options);\n        return ast;\n    }\n    // returns the regular expression if there's magic, or the unescaped\n    // string if not.\n    toMMPattern() {\n        // should only be called on root\n        /* c8 ignore start */\n        if (this !== this.#root)\n            return this.#root.toMMPattern();\n        /* c8 ignore stop */\n        const glob = this.toString();\n        const [re, body, hasMagic, uflag] = this.toRegExpSource();\n        // if we're in nocase mode, and not nocaseMagicOnly, then we do\n        // still need a regular expression if we have to case-insensitively\n        // match capital/lowercase characters.\n        const anyMagic = hasMagic ||\n            this.#hasMagic ||\n            (this.#options.nocase &&\n                !this.#options.nocaseMagicOnly &&\n                glob.toUpperCase() !== glob.toLowerCase());\n        if (!anyMagic) {\n            return body;\n        }\n        const flags = (this.#options.nocase ? 'i' : '') + (uflag ? 'u' : '');\n        return Object.assign(new RegExp(`^${re}$`, flags), {\n            _src: re,\n            _glob: glob,\n        });\n    }\n    get options() {\n        return this.#options;\n    }\n    // returns the string match, the regexp source, whether there's magic\n    // in the regexp (so a regular expression is required) and whether or\n    // not the uflag is needed for the regular expression (for posix classes)\n    // TODO: instead of injecting the start/end at this point, just return\n    // the BODY of the regexp, along with the start/end portions suitable\n    // for binding the start/end in either a joined full-path makeRe context\n    // (where we bind to (^|/), or a standalone matchPart context (where\n    // we bind to ^, and not /).  Otherwise slashes get duped!\n    //\n    // In part-matching mode, the start is:\n    // - if not isStart: nothing\n    // - if traversal possible, but not allowed: ^(?!\\.\\.?$)\n    // - if dots allowed or not possible: ^\n    // - if dots possible and not allowed: ^(?!\\.)\n    // end is:\n    // - if not isEnd(): nothing\n    // - else: $\n    //\n    // In full-path matching mode, we put the slash at the START of the\n    // pattern, so start is:\n    // - if first pattern: same as part-matching mode\n    // - if not isStart(): nothing\n    // - if traversal possible, but not allowed: /(?!\\.\\.?(?:$|/))\n    // - if dots allowed or not possible: /\n    // - if dots possible and not allowed: /(?!\\.)\n    // end is:\n    // - if last pattern, same as part-matching mode\n    // - else nothing\n    //\n    // Always put the (?:$|/) on negated tails, though, because that has to be\n    // there to bind the end of the negated pattern portion, and it's easier to\n    // just stick it in now rather than try to inject it later in the middle of\n    // the pattern.\n    //\n    // We can just always return the same end, and leave it up to the caller\n    // to know whether it's going to be used joined or in parts.\n    // And, if the start is adjusted slightly, can do the same there:\n    // - if not isStart: nothing\n    // - if traversal possible, but not allowed: (?:/|^)(?!\\.\\.?$)\n    // - if dots allowed or not possible: (?:/|^)\n    // - if dots possible and not allowed: (?:/|^)(?!\\.)\n    //\n    // But it's better to have a simpler binding without a conditional, for\n    // performance, so probably better to return both start options.\n    //\n    // Then the caller just ignores the end if it's not the first pattern,\n    // and the start always gets applied.\n    //\n    // But that's always going to be $ if it's the ending pattern, or nothing,\n    // so the caller can just attach $ at the end of the pattern when building.\n    //\n    // So the todo is:\n    // - better detect what kind of start is needed\n    // - return both flavors of starting pattern\n    // - attach $ at the end of the pattern when creating the actual RegExp\n    //\n    // Ah, but wait, no, that all only applies to the root when the first pattern\n    // is not an extglob. If the first pattern IS an extglob, then we need all\n    // that dot prevention biz to live in the extglob portions, because eg\n    // +(*|.x*) can match .xy but not .yx.\n    //\n    // So, return the two flavors if it's #root and the first child is not an\n    // AST, otherwise leave it to the child AST to handle it, and there,\n    // use the (?:^|/) style of start binding.\n    //\n    // Even simplified further:\n    // - Since the start for a join is eg /(?!\\.) and the start for a part\n    // is ^(?!\\.), we can just prepend (?!\\.) to the pattern (either root\n    // or start or whatever) and prepend ^ or / at the Regexp construction.\n    toRegExpSource(allowDot) {\n        const dot = allowDot ?? !!this.#options.dot;\n        if (this.#root === this)\n            this.#fillNegs();\n        if (!this.type) {\n            const noEmpty = this.isStart() && this.isEnd();\n            const src = this.#parts\n                .map(p => {\n                const [re, _, hasMagic, uflag] = typeof p === 'string'\n                    ? AST.#parseGlob(p, this.#hasMagic, noEmpty)\n                    : p.toRegExpSource(allowDot);\n                this.#hasMagic = this.#hasMagic || hasMagic;\n                this.#uflag = this.#uflag || uflag;\n                return re;\n            })\n                .join('');\n            let start = '';\n            if (this.isStart()) {\n                if (typeof this.#parts[0] === 'string') {\n                    // this is the string that will match the start of the pattern,\n                    // so we need to protect against dots and such.\n                    // '.' and '..' cannot match unless the pattern is that exactly,\n                    // even if it starts with . or dot:true is set.\n                    const dotTravAllowed = this.#parts.length === 1 && justDots.has(this.#parts[0]);\n                    if (!dotTravAllowed) {\n                        const aps = addPatternStart;\n                        // check if we have a possibility of matching . or ..,\n                        // and prevent that.\n                        const needNoTrav = \n                        // dots are allowed, and the pattern starts with [ or .\n                        (dot && aps.has(src.charAt(0))) ||\n                            // the pattern starts with \\., and then [ or .\n                            (src.startsWith('\\\\.') && aps.has(src.charAt(2))) ||\n                            // the pattern starts with \\.\\., and then [ or .\n                            (src.startsWith('\\\\.\\\\.') && aps.has(src.charAt(4)));\n                        // no need to prevent dots if it can't match a dot, or if a\n                        // sub-pattern will be preventing it anyway.\n                        const needNoDot = !dot && !allowDot && aps.has(src.charAt(0));\n                        start = needNoTrav ? startNoTraversal : needNoDot ? startNoDot : '';\n                    }\n                }\n            }\n            // append the \"end of path portion\" pattern to negation tails\n            let end = '';\n            if (this.isEnd() &&\n                this.#root.#filledNegs &&\n                this.#parent?.type === '!') {\n                end = '(?:$|\\\\/)';\n            }\n            const final = start + src + end;\n            return [\n                final,\n                unescape(src),\n                (this.#hasMagic = !!this.#hasMagic),\n                this.#uflag,\n            ];\n        }\n        // We need to calculate the body *twice* if it's a repeat pattern\n        // at the start, once in nodot mode, then again in dot mode, so a\n        // pattern like *(?) can match 'x.y'\n        const repeated = this.type === '*' || this.type === '+';\n        // some kind of extglob\n        const start = this.type === '!' ? '(?:(?!(?:' : '(?:';\n        let body = this.#partsToRegExp(dot);\n        if (this.isStart() && this.isEnd() && !body && this.type !== '!') {\n            // invalid extglob, has to at least be *something* present, if it's\n            // the entire path portion.\n            const s = this.toString();\n            this.#parts = [s];\n            this.type = null;\n            this.#hasMagic = undefined;\n            return [s, unescape(this.toString()), false, false];\n        }\n        // XXX abstract out this map method\n        let bodyDotAllowed = !repeated || allowDot || dot || !startNoDot\n            ? ''\n            : this.#partsToRegExp(true);\n        if (bodyDotAllowed === body) {\n            bodyDotAllowed = '';\n        }\n        if (bodyDotAllowed) {\n            body = `(?:${body})(?:${bodyDotAllowed})*?`;\n        }\n        // an empty !() is exactly equivalent to a starNoEmpty\n        let final = '';\n        if (this.type === '!' && this.#emptyExt) {\n            final = (this.isStart() && !dot ? startNoDot : '') + starNoEmpty;\n        }\n        else {\n            const close = this.type === '!'\n                ? // !() must match something,but !(x) can match ''\n                    '))' +\n                        (this.isStart() && !dot && !allowDot ? startNoDot : '') +\n                        star +\n                        ')'\n                : this.type === '@'\n                    ? ')'\n                    : this.type === '?'\n                        ? ')?'\n                        : this.type === '+' && bodyDotAllowed\n                            ? ')'\n                            : this.type === '*' && bodyDotAllowed\n                                ? `)?`\n                                : `)${this.type}`;\n            final = start + body + close;\n        }\n        return [\n            final,\n            unescape(body),\n            (this.#hasMagic = !!this.#hasMagic),\n            this.#uflag,\n        ];\n    }\n    #partsToRegExp(dot) {\n        return this.#parts\n            .map(p => {\n            // extglob ASTs should only contain parent ASTs\n            /* c8 ignore start */\n            if (typeof p === 'string') {\n                throw new Error('string type in extglob ast??');\n            }\n            /* c8 ignore stop */\n            // can ignore hasMagic, because extglobs are already always magic\n            const [re, _, _hasMagic, uflag] = p.toRegExpSource(dot);\n            this.#uflag = this.#uflag || uflag;\n            return re;\n        })\n            .filter(p => !(this.isStart() && this.isEnd()) || !!p)\n            .join('|');\n    }\n    static #parseGlob(glob, hasMagic, noEmpty = false) {\n        let escaping = false;\n        let re = '';\n        let uflag = false;\n        for (let i = 0; i < glob.length; i++) {\n            const c = glob.charAt(i);\n            if (escaping) {\n                escaping = false;\n                re += (reSpecials.has(c) ? '\\\\' : '') + c;\n                continue;\n            }\n            if (c === '\\\\') {\n                if (i === glob.length - 1) {\n                    re += '\\\\\\\\';\n                }\n                else {\n                    escaping = true;\n                }\n                continue;\n            }\n            if (c === '[') {\n                const [src, needUflag, consumed, magic] = parseClass(glob, i);\n                if (consumed) {\n                    re += src;\n                    uflag = uflag || needUflag;\n                    i += consumed - 1;\n                    hasMagic = hasMagic || magic;\n                    continue;\n                }\n            }\n            if (c === '*') {\n                if (noEmpty && glob === '*')\n                    re += starNoEmpty;\n                else\n                    re += star;\n                hasMagic = true;\n                continue;\n            }\n            if (c === '?') {\n                re += qmark;\n                hasMagic = true;\n                continue;\n            }\n            re += regExpEscape(c);\n        }\n        return [re, unescape(glob), !!hasMagic, uflag];\n    }\n}\n//# sourceMappingURL=ast.js.map","/**\n * Escape all magic characters in a glob pattern.\n *\n * If the {@link windowsPathsNoEscape | GlobOptions.windowsPathsNoEscape}\n * option is used, then characters are escaped by wrapping in `[]`, because\n * a magic character wrapped in a character class can only be satisfied by\n * that exact character.  In this mode, `\\` is _not_ escaped, because it is\n * not interpreted as a magic character, but instead as a path separator.\n */\nexport const escape = (s, { windowsPathsNoEscape = false, } = {}) => {\n    // don't need to escape +@! because we escape the parens\n    // that make those magic, and escaping ! as [!] isn't valid,\n    // because [!]] is a valid glob class meaning not ']'.\n    return windowsPathsNoEscape\n        ? s.replace(/[?*()[\\]]/g, '[$&]')\n        : s.replace(/[?*()[\\]\\\\]/g, '\\\\$&');\n};\n//# sourceMappingURL=escape.js.map","import { expand } from '@isaacs/brace-expansion';\nimport { assertValidPattern } from './assert-valid-pattern.js';\nimport { AST } from './ast.js';\nimport { escape } from './escape.js';\nimport { unescape } from './unescape.js';\nexport const minimatch = (p, pattern, options = {}) => {\n    assertValidPattern(pattern);\n    // shortcut: comments match nothing.\n    if (!options.nocomment && pattern.charAt(0) === '#') {\n        return false;\n    }\n    return new Minimatch(pattern, options).match(p);\n};\n// Optimized checking for the most common glob patterns.\nconst starDotExtRE = /^\\*+([^+@!?\\*\\[\\(]*)$/;\nconst starDotExtTest = (ext) => (f) => !f.startsWith('.') && f.endsWith(ext);\nconst starDotExtTestDot = (ext) => (f) => f.endsWith(ext);\nconst starDotExtTestNocase = (ext) => {\n    ext = ext.toLowerCase();\n    return (f) => !f.startsWith('.') && f.toLowerCase().endsWith(ext);\n};\nconst starDotExtTestNocaseDot = (ext) => {\n    ext = ext.toLowerCase();\n    return (f) => f.toLowerCase().endsWith(ext);\n};\nconst starDotStarRE = /^\\*+\\.\\*+$/;\nconst starDotStarTest = (f) => !f.startsWith('.') && f.includes('.');\nconst starDotStarTestDot = (f) => f !== '.' && f !== '..' && f.includes('.');\nconst dotStarRE = /^\\.\\*+$/;\nconst dotStarTest = (f) => f !== '.' && f !== '..' && f.startsWith('.');\nconst starRE = /^\\*+$/;\nconst starTest = (f) => f.length !== 0 && !f.startsWith('.');\nconst starTestDot = (f) => f.length !== 0 && f !== '.' && f !== '..';\nconst qmarksRE = /^\\?+([^+@!?\\*\\[\\(]*)?$/;\nconst qmarksTestNocase = ([$0, ext = '']) => {\n    const noext = qmarksTestNoExt([$0]);\n    if (!ext)\n        return noext;\n    ext = ext.toLowerCase();\n    return (f) => noext(f) && f.toLowerCase().endsWith(ext);\n};\nconst qmarksTestNocaseDot = ([$0, ext = '']) => {\n    const noext = qmarksTestNoExtDot([$0]);\n    if (!ext)\n        return noext;\n    ext = ext.toLowerCase();\n    return (f) => noext(f) && f.toLowerCase().endsWith(ext);\n};\nconst qmarksTestDot = ([$0, ext = '']) => {\n    const noext = qmarksTestNoExtDot([$0]);\n    return !ext ? noext : (f) => noext(f) && f.endsWith(ext);\n};\nconst qmarksTest = ([$0, ext = '']) => {\n    const noext = qmarksTestNoExt([$0]);\n    return !ext ? noext : (f) => noext(f) && f.endsWith(ext);\n};\nconst qmarksTestNoExt = ([$0]) => {\n    const len = $0.length;\n    return (f) => f.length === len && !f.startsWith('.');\n};\nconst qmarksTestNoExtDot = ([$0]) => {\n    const len = $0.length;\n    return (f) => f.length === len && f !== '.' && f !== '..';\n};\n/* c8 ignore start */\nconst defaultPlatform = (typeof process === 'object' && process\n    ? (typeof process.env === 'object' &&\n        process.env &&\n        process.env.__MINIMATCH_TESTING_PLATFORM__) ||\n        process.platform\n    : 'posix');\nconst path = {\n    win32: { sep: '\\\\' },\n    posix: { sep: '/' },\n};\n/* c8 ignore stop */\nexport const sep = defaultPlatform === 'win32' ? path.win32.sep : path.posix.sep;\nminimatch.sep = sep;\nexport const GLOBSTAR = Symbol('globstar **');\nminimatch.GLOBSTAR = GLOBSTAR;\n// any single thing other than /\n// don't need to escape / when using new RegExp()\nconst qmark = '[^/]';\n// * => any number of characters\nconst star = qmark + '*?';\n// ** when dots are allowed.  Anything goes, except .. and .\n// not (^ or / followed by one or two dots followed by $ or /),\n// followed by anything, any number of times.\nconst twoStarDot = '(?:(?!(?:\\\\/|^)(?:\\\\.{1,2})($|\\\\/)).)*?';\n// not a ^ or / followed by a dot,\n// followed by anything, any number of times.\nconst twoStarNoDot = '(?:(?!(?:\\\\/|^)\\\\.).)*?';\nexport const filter = (pattern, options = {}) => (p) => minimatch(p, pattern, options);\nminimatch.filter = filter;\nconst ext = (a, b = {}) => Object.assign({}, a, b);\nexport const defaults = (def) => {\n    if (!def || typeof def !== 'object' || !Object.keys(def).length) {\n        return minimatch;\n    }\n    const orig = minimatch;\n    const m = (p, pattern, options = {}) => orig(p, pattern, ext(def, options));\n    return Object.assign(m, {\n        Minimatch: class Minimatch extends orig.Minimatch {\n            constructor(pattern, options = {}) {\n                super(pattern, ext(def, options));\n            }\n            static defaults(options) {\n                return orig.defaults(ext(def, options)).Minimatch;\n            }\n        },\n        AST: class AST extends orig.AST {\n            /* c8 ignore start */\n            constructor(type, parent, options = {}) {\n                super(type, parent, ext(def, options));\n            }\n            /* c8 ignore stop */\n            static fromGlob(pattern, options = {}) {\n                return orig.AST.fromGlob(pattern, ext(def, options));\n            }\n        },\n        unescape: (s, options = {}) => orig.unescape(s, ext(def, options)),\n        escape: (s, options = {}) => orig.escape(s, ext(def, options)),\n        filter: (pattern, options = {}) => orig.filter(pattern, ext(def, options)),\n        defaults: (options) => orig.defaults(ext(def, options)),\n        makeRe: (pattern, options = {}) => orig.makeRe(pattern, ext(def, options)),\n        braceExpand: (pattern, options = {}) => orig.braceExpand(pattern, ext(def, options)),\n        match: (list, pattern, options = {}) => orig.match(list, pattern, ext(def, options)),\n        sep: orig.sep,\n        GLOBSTAR: GLOBSTAR,\n    });\n};\nminimatch.defaults = defaults;\n// Brace expansion:\n// a{b,c}d -> abd acd\n// a{b,}c -> abc ac\n// a{0..3}d -> a0d a1d a2d a3d\n// a{b,c{d,e}f}g -> abg acdfg acefg\n// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg\n//\n// Invalid sets are not expanded.\n// a{2..}b -> a{2..}b\n// a{b}c -> a{b}c\nexport const braceExpand = (pattern, options = {}) => {\n    assertValidPattern(pattern);\n    // Thanks to Yeting Li <https://github.com/yetingli> for\n    // improving this regexp to avoid a ReDOS vulnerability.\n    if (options.nobrace || !/\\{(?:(?!\\{).)*\\}/.test(pattern)) {\n        // shortcut. no need to expand.\n        return [pattern];\n    }\n    return expand(pattern);\n};\nminimatch.braceExpand = braceExpand;\n// parse a component of the expanded set.\n// At this point, no pattern may contain \"/\" in it\n// so we're going to return a 2d array, where each entry is the full\n// pattern, split on '/', and then turned into a regular expression.\n// A regexp is made at the end which joins each array with an\n// escaped /, and another full one which joins each regexp with |.\n//\n// Following the lead of Bash 4.1, note that \"**\" only has special meaning\n// when it is the *only* thing in a path portion.  Otherwise, any series\n// of * is equivalent to a single *.  Globstar behavior is enabled by\n// default, and can be disabled by setting options.noglobstar.\nexport const makeRe = (pattern, options = {}) => new Minimatch(pattern, options).makeRe();\nminimatch.makeRe = makeRe;\nexport const match = (list, pattern, options = {}) => {\n    const mm = new Minimatch(pattern, options);\n    list = list.filter(f => mm.match(f));\n    if (mm.options.nonull && !list.length) {\n        list.push(pattern);\n    }\n    return list;\n};\nminimatch.match = match;\n// replace stuff like \\* with *\nconst globMagic = /[?*]|[+@!]\\(.*?\\)|\\[|\\]/;\nconst regExpEscape = (s) => s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\nexport class Minimatch {\n    options;\n    set;\n    pattern;\n    windowsPathsNoEscape;\n    nonegate;\n    negate;\n    comment;\n    empty;\n    preserveMultipleSlashes;\n    partial;\n    globSet;\n    globParts;\n    nocase;\n    isWindows;\n    platform;\n    windowsNoMagicRoot;\n    regexp;\n    constructor(pattern, options = {}) {\n        assertValidPattern(pattern);\n        options = options || {};\n        this.options = options;\n        this.pattern = pattern;\n        this.platform = options.platform || defaultPlatform;\n        this.isWindows = this.platform === 'win32';\n        this.windowsPathsNoEscape =\n            !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;\n        if (this.windowsPathsNoEscape) {\n            this.pattern = this.pattern.replace(/\\\\/g, '/');\n        }\n        this.preserveMultipleSlashes = !!options.preserveMultipleSlashes;\n        this.regexp = null;\n        this.negate = false;\n        this.nonegate = !!options.nonegate;\n        this.comment = false;\n        this.empty = false;\n        this.partial = !!options.partial;\n        this.nocase = !!this.options.nocase;\n        this.windowsNoMagicRoot =\n            options.windowsNoMagicRoot !== undefined\n                ? options.windowsNoMagicRoot\n                : !!(this.isWindows && this.nocase);\n        this.globSet = [];\n        this.globParts = [];\n        this.set = [];\n        // make the set of regexps etc.\n        this.make();\n    }\n    hasMagic() {\n        if (this.options.magicalBraces && this.set.length > 1) {\n            return true;\n        }\n        for (const pattern of this.set) {\n            for (const part of pattern) {\n                if (typeof part !== 'string')\n                    return true;\n            }\n        }\n        return false;\n    }\n    debug(..._) { }\n    make() {\n        const pattern = this.pattern;\n        const options = this.options;\n        // empty patterns and comments match nothing.\n        if (!options.nocomment && pattern.charAt(0) === '#') {\n            this.comment = true;\n            return;\n        }\n        if (!pattern) {\n            this.empty = true;\n            return;\n        }\n        // step 1: figure out negation, etc.\n        this.parseNegate();\n        // step 2: expand braces\n        this.globSet = [...new Set(this.braceExpand())];\n        if (options.debug) {\n            this.debug = (...args) => console.error(...args);\n        }\n        this.debug(this.pattern, this.globSet);\n        // step 3: now we have a set, so turn each one into a series of\n        // path-portion matching patterns.\n        // These will be regexps, except in the case of \"**\", which is\n        // set to the GLOBSTAR object for globstar behavior,\n        // and will not contain any / characters\n        //\n        // First, we preprocess to make the glob pattern sets a bit simpler\n        // and deduped.  There are some perf-killing patterns that can cause\n        // problems with a glob walk, but we can simplify them down a bit.\n        const rawGlobParts = this.globSet.map(s => this.slashSplit(s));\n        this.globParts = this.preprocess(rawGlobParts);\n        this.debug(this.pattern, this.globParts);\n        // glob --> regexps\n        let set = this.globParts.map((s, _, __) => {\n            if (this.isWindows && this.windowsNoMagicRoot) {\n                // check if it's a drive or unc path.\n                const isUNC = s[0] === '' &&\n                    s[1] === '' &&\n                    (s[2] === '?' || !globMagic.test(s[2])) &&\n                    !globMagic.test(s[3]);\n                const isDrive = /^[a-z]:/i.test(s[0]);\n                if (isUNC) {\n                    return [...s.slice(0, 4), ...s.slice(4).map(ss => this.parse(ss))];\n                }\n                else if (isDrive) {\n                    return [s[0], ...s.slice(1).map(ss => this.parse(ss))];\n                }\n            }\n            return s.map(ss => this.parse(ss));\n        });\n        this.debug(this.pattern, set);\n        // filter out everything that didn't compile properly.\n        this.set = set.filter(s => s.indexOf(false) === -1);\n        // do not treat the ? in UNC paths as magic\n        if (this.isWindows) {\n            for (let i = 0; i < this.set.length; i++) {\n                const p = this.set[i];\n                if (p[0] === '' &&\n                    p[1] === '' &&\n                    this.globParts[i][2] === '?' &&\n                    typeof p[3] === 'string' &&\n                    /^[a-z]:$/i.test(p[3])) {\n                    p[2] = '?';\n                }\n            }\n        }\n        this.debug(this.pattern, this.set);\n    }\n    // various transforms to equivalent pattern sets that are\n    // faster to process in a filesystem walk.  The goal is to\n    // eliminate what we can, and push all ** patterns as far\n    // to the right as possible, even if it increases the number\n    // of patterns that we have to process.\n    preprocess(globParts) {\n        // if we're not in globstar mode, then turn all ** into *\n        if (this.options.noglobstar) {\n            for (let i = 0; i < globParts.length; i++) {\n                for (let j = 0; j < globParts[i].length; j++) {\n                    if (globParts[i][j] === '**') {\n                        globParts[i][j] = '*';\n                    }\n                }\n            }\n        }\n        const { optimizationLevel = 1 } = this.options;\n        if (optimizationLevel >= 2) {\n            // aggressive optimization for the purpose of fs walking\n            globParts = this.firstPhasePreProcess(globParts);\n            globParts = this.secondPhasePreProcess(globParts);\n        }\n        else if (optimizationLevel >= 1) {\n            // just basic optimizations to remove some .. parts\n            globParts = this.levelOneOptimize(globParts);\n        }\n        else {\n            // just collapse multiple ** portions into one\n            globParts = this.adjascentGlobstarOptimize(globParts);\n        }\n        return globParts;\n    }\n    // just get rid of adjascent ** portions\n    adjascentGlobstarOptimize(globParts) {\n        return globParts.map(parts => {\n            let gs = -1;\n            while (-1 !== (gs = parts.indexOf('**', gs + 1))) {\n                let i = gs;\n                while (parts[i + 1] === '**') {\n                    i++;\n                }\n                if (i !== gs) {\n                    parts.splice(gs, i - gs);\n                }\n            }\n            return parts;\n        });\n    }\n    // get rid of adjascent ** and resolve .. portions\n    levelOneOptimize(globParts) {\n        return globParts.map(parts => {\n            parts = parts.reduce((set, part) => {\n                const prev = set[set.length - 1];\n                if (part === '**' && prev === '**') {\n                    return set;\n                }\n                if (part === '..') {\n                    if (prev && prev !== '..' && prev !== '.' && prev !== '**') {\n                        set.pop();\n                        return set;\n                    }\n                }\n                set.push(part);\n                return set;\n            }, []);\n            return parts.length === 0 ? [''] : parts;\n        });\n    }\n    levelTwoFileOptimize(parts) {\n        if (!Array.isArray(parts)) {\n            parts = this.slashSplit(parts);\n        }\n        let didSomething = false;\n        do {\n            didSomething = false;\n            // <pre>/<e>/<rest> -> <pre>/<rest>\n            if (!this.preserveMultipleSlashes) {\n                for (let i = 1; i < parts.length - 1; i++) {\n                    const p = parts[i];\n                    // don't squeeze out UNC patterns\n                    if (i === 1 && p === '' && parts[0] === '')\n                        continue;\n                    if (p === '.' || p === '') {\n                        didSomething = true;\n                        parts.splice(i, 1);\n                        i--;\n                    }\n                }\n                if (parts[0] === '.' &&\n                    parts.length === 2 &&\n                    (parts[1] === '.' || parts[1] === '')) {\n                    didSomething = true;\n                    parts.pop();\n                }\n            }\n            // <pre>/<p>/../<rest> -> <pre>/<rest>\n            let dd = 0;\n            while (-1 !== (dd = parts.indexOf('..', dd + 1))) {\n                const p = parts[dd - 1];\n                if (p && p !== '.' && p !== '..' && p !== '**') {\n                    didSomething = true;\n                    parts.splice(dd - 1, 2);\n                    dd -= 2;\n                }\n            }\n        } while (didSomething);\n        return parts.length === 0 ? [''] : parts;\n    }\n    // First phase: single-pattern processing\n    // <pre> is 1 or more portions\n    // <rest> is 1 or more portions\n    // <p> is any portion other than ., .., '', or **\n    // <e> is . or ''\n    //\n    // **/.. is *brutal* for filesystem walking performance, because\n    // it effectively resets the recursive walk each time it occurs,\n    // and ** cannot be reduced out by a .. pattern part like a regexp\n    // or most strings (other than .., ., and '') can be.\n    //\n    // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}\n    // <pre>/<e>/<rest> -> <pre>/<rest>\n    // <pre>/<p>/../<rest> -> <pre>/<rest>\n    // **/**/<rest> -> **/<rest>\n    //\n    // **/*/<rest> -> */**/<rest> <== not valid because ** doesn't follow\n    // this WOULD be allowed if ** did follow symlinks, or * didn't\n    firstPhasePreProcess(globParts) {\n        let didSomething = false;\n        do {\n            didSomething = false;\n            // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}\n            for (let parts of globParts) {\n                let gs = -1;\n                while (-1 !== (gs = parts.indexOf('**', gs + 1))) {\n                    let gss = gs;\n                    while (parts[gss + 1] === '**') {\n                        // <pre>/**/**/<rest> -> <pre>/**/<rest>\n                        gss++;\n                    }\n                    // eg, if gs is 2 and gss is 4, that means we have 3 **\n                    // parts, and can remove 2 of them.\n                    if (gss > gs) {\n                        parts.splice(gs + 1, gss - gs);\n                    }\n                    let next = parts[gs + 1];\n                    const p = parts[gs + 2];\n                    const p2 = parts[gs + 3];\n                    if (next !== '..')\n                        continue;\n                    if (!p ||\n                        p === '.' ||\n                        p === '..' ||\n                        !p2 ||\n                        p2 === '.' ||\n                        p2 === '..') {\n                        continue;\n                    }\n                    didSomething = true;\n                    // edit parts in place, and push the new one\n                    parts.splice(gs, 1);\n                    const other = parts.slice(0);\n                    other[gs] = '**';\n                    globParts.push(other);\n                    gs--;\n                }\n                // <pre>/<e>/<rest> -> <pre>/<rest>\n                if (!this.preserveMultipleSlashes) {\n                    for (let i = 1; i < parts.length - 1; i++) {\n                        const p = parts[i];\n                        // don't squeeze out UNC patterns\n                        if (i === 1 && p === '' && parts[0] === '')\n                            continue;\n                        if (p === '.' || p === '') {\n                            didSomething = true;\n                            parts.splice(i, 1);\n                            i--;\n                        }\n                    }\n                    if (parts[0] === '.' &&\n                        parts.length === 2 &&\n                        (parts[1] === '.' || parts[1] === '')) {\n                        didSomething = true;\n                        parts.pop();\n                    }\n                }\n                // <pre>/<p>/../<rest> -> <pre>/<rest>\n                let dd = 0;\n                while (-1 !== (dd = parts.indexOf('..', dd + 1))) {\n                    const p = parts[dd - 1];\n                    if (p && p !== '.' && p !== '..' && p !== '**') {\n                        didSomething = true;\n                        const needDot = dd === 1 && parts[dd + 1] === '**';\n                        const splin = needDot ? ['.'] : [];\n                        parts.splice(dd - 1, 2, ...splin);\n                        if (parts.length === 0)\n                            parts.push('');\n                        dd -= 2;\n                    }\n                }\n            }\n        } while (didSomething);\n        return globParts;\n    }\n    // second phase: multi-pattern dedupes\n    // {<pre>/*/<rest>,<pre>/<p>/<rest>} -> <pre>/*/<rest>\n    // {<pre>/<rest>,<pre>/<rest>} -> <pre>/<rest>\n    // {<pre>/**/<rest>,<pre>/<rest>} -> <pre>/**/<rest>\n    //\n    // {<pre>/**/<rest>,<pre>/**/<p>/<rest>} -> <pre>/**/<rest>\n    // ^-- not valid because ** doens't follow symlinks\n    secondPhasePreProcess(globParts) {\n        for (let i = 0; i < globParts.length - 1; i++) {\n            for (let j = i + 1; j < globParts.length; j++) {\n                const matched = this.partsMatch(globParts[i], globParts[j], !this.preserveMultipleSlashes);\n                if (matched) {\n                    globParts[i] = [];\n                    globParts[j] = matched;\n                    break;\n                }\n            }\n        }\n        return globParts.filter(gs => gs.length);\n    }\n    partsMatch(a, b, emptyGSMatch = false) {\n        let ai = 0;\n        let bi = 0;\n        let result = [];\n        let which = '';\n        while (ai < a.length && bi < b.length) {\n            if (a[ai] === b[bi]) {\n                result.push(which === 'b' ? b[bi] : a[ai]);\n                ai++;\n                bi++;\n            }\n            else if (emptyGSMatch && a[ai] === '**' && b[bi] === a[ai + 1]) {\n                result.push(a[ai]);\n                ai++;\n            }\n            else if (emptyGSMatch && b[bi] === '**' && a[ai] === b[bi + 1]) {\n                result.push(b[bi]);\n                bi++;\n            }\n            else if (a[ai] === '*' &&\n                b[bi] &&\n                (this.options.dot || !b[bi].startsWith('.')) &&\n                b[bi] !== '**') {\n                if (which === 'b')\n                    return false;\n                which = 'a';\n                result.push(a[ai]);\n                ai++;\n                bi++;\n            }\n            else if (b[bi] === '*' &&\n                a[ai] &&\n                (this.options.dot || !a[ai].startsWith('.')) &&\n                a[ai] !== '**') {\n                if (which === 'a')\n                    return false;\n                which = 'b';\n                result.push(b[bi]);\n                ai++;\n                bi++;\n            }\n            else {\n                return false;\n            }\n        }\n        // if we fall out of the loop, it means they two are identical\n        // as long as their lengths match\n        return a.length === b.length && result;\n    }\n    parseNegate() {\n        if (this.nonegate)\n            return;\n        const pattern = this.pattern;\n        let negate = false;\n        let negateOffset = 0;\n        for (let i = 0; i < pattern.length && pattern.charAt(i) === '!'; i++) {\n            negate = !negate;\n            negateOffset++;\n        }\n        if (negateOffset)\n            this.pattern = pattern.slice(negateOffset);\n        this.negate = negate;\n    }\n    // set partial to true to test if, for example,\n    // \"/a/b\" matches the start of \"/*/b/*/d\"\n    // Partial means, if you run out of file before you run\n    // out of pattern, then that's fine, as long as all\n    // the parts match.\n    matchOne(file, pattern, partial = false) {\n        const options = this.options;\n        // UNC paths like //?/X:/... can match X:/... and vice versa\n        // Drive letters in absolute drive or unc paths are always compared\n        // case-insensitively.\n        if (this.isWindows) {\n            const fileDrive = typeof file[0] === 'string' && /^[a-z]:$/i.test(file[0]);\n            const fileUNC = !fileDrive &&\n                file[0] === '' &&\n                file[1] === '' &&\n                file[2] === '?' &&\n                /^[a-z]:$/i.test(file[3]);\n            const patternDrive = typeof pattern[0] === 'string' && /^[a-z]:$/i.test(pattern[0]);\n            const patternUNC = !patternDrive &&\n                pattern[0] === '' &&\n                pattern[1] === '' &&\n                pattern[2] === '?' &&\n                typeof pattern[3] === 'string' &&\n                /^[a-z]:$/i.test(pattern[3]);\n            const fdi = fileUNC ? 3 : fileDrive ? 0 : undefined;\n            const pdi = patternUNC ? 3 : patternDrive ? 0 : undefined;\n            if (typeof fdi === 'number' && typeof pdi === 'number') {\n                const [fd, pd] = [file[fdi], pattern[pdi]];\n                if (fd.toLowerCase() === pd.toLowerCase()) {\n                    pattern[pdi] = fd;\n                    if (pdi > fdi) {\n                        pattern = pattern.slice(pdi);\n                    }\n                    else if (fdi > pdi) {\n                        file = file.slice(fdi);\n                    }\n                }\n            }\n        }\n        // resolve and reduce . and .. portions in the file as well.\n        // dont' need to do the second phase, because it's only one string[]\n        const { optimizationLevel = 1 } = this.options;\n        if (optimizationLevel >= 2) {\n            file = this.levelTwoFileOptimize(file);\n        }\n        this.debug('matchOne', this, { file, pattern });\n        this.debug('matchOne', file.length, pattern.length);\n        for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {\n            this.debug('matchOne loop');\n            var p = pattern[pi];\n            var f = file[fi];\n            this.debug(pattern, p, f);\n            // should be impossible.\n            // some invalid regexp stuff in the set.\n            /* c8 ignore start */\n            if (p === false) {\n                return false;\n            }\n            /* c8 ignore stop */\n            if (p === GLOBSTAR) {\n                this.debug('GLOBSTAR', [pattern, p, f]);\n                // \"**\"\n                // a/**/b/**/c would match the following:\n                // a/b/x/y/z/c\n                // a/x/y/z/b/c\n                // a/b/x/b/x/c\n                // a/b/c\n                // To do this, take the rest of the pattern after\n                // the **, and see if it would match the file remainder.\n                // If so, return success.\n                // If not, the ** \"swallows\" a segment, and try again.\n                // This is recursively awful.\n                //\n                // a/**/b/**/c matching a/b/x/y/z/c\n                // - a matches a\n                // - doublestar\n                //   - matchOne(b/x/y/z/c, b/**/c)\n                //     - b matches b\n                //     - doublestar\n                //       - matchOne(x/y/z/c, c) -> no\n                //       - matchOne(y/z/c, c) -> no\n                //       - matchOne(z/c, c) -> no\n                //       - matchOne(c, c) yes, hit\n                var fr = fi;\n                var pr = pi + 1;\n                if (pr === pl) {\n                    this.debug('** at the end');\n                    // a ** at the end will just swallow the rest.\n                    // We have found a match.\n                    // however, it will not swallow /.x, unless\n                    // options.dot is set.\n                    // . and .. are *never* matched by **, for explosively\n                    // exponential reasons.\n                    for (; fi < fl; fi++) {\n                        if (file[fi] === '.' ||\n                            file[fi] === '..' ||\n                            (!options.dot && file[fi].charAt(0) === '.'))\n                            return false;\n                    }\n                    return true;\n                }\n                // ok, let's see if we can swallow whatever we can.\n                while (fr < fl) {\n                    var swallowee = file[fr];\n                    this.debug('\\nglobstar while', file, fr, pattern, pr, swallowee);\n                    // XXX remove this slice.  Just pass the start index.\n                    if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {\n                        this.debug('globstar found match!', fr, fl, swallowee);\n                        // found a match.\n                        return true;\n                    }\n                    else {\n                        // can't swallow \".\" or \"..\" ever.\n                        // can only swallow \".foo\" when explicitly asked.\n                        if (swallowee === '.' ||\n                            swallowee === '..' ||\n                            (!options.dot && swallowee.charAt(0) === '.')) {\n                            this.debug('dot detected!', file, fr, pattern, pr);\n                            break;\n                        }\n                        // ** swallows a segment, and continue.\n                        this.debug('globstar swallow a segment, and continue');\n                        fr++;\n                    }\n                }\n                // no match was found.\n                // However, in partial mode, we can't say this is necessarily over.\n                /* c8 ignore start */\n                if (partial) {\n                    // ran out of file\n                    this.debug('\\n>>> no match, partial?', file, fr, pattern, pr);\n                    if (fr === fl) {\n                        return true;\n                    }\n                }\n                /* c8 ignore stop */\n                return false;\n            }\n            // something other than **\n            // non-magic patterns just have to match exactly\n            // patterns with magic have been turned into regexps.\n            let hit;\n            if (typeof p === 'string') {\n                hit = f === p;\n                this.debug('string match', p, f, hit);\n            }\n            else {\n                hit = p.test(f);\n                this.debug('pattern match', p, f, hit);\n            }\n            if (!hit)\n                return false;\n        }\n        // Note: ending in / means that we'll get a final \"\"\n        // at the end of the pattern.  This can only match a\n        // corresponding \"\" at the end of the file.\n        // If the file ends in /, then it can only match a\n        // a pattern that ends in /, unless the pattern just\n        // doesn't have any more for it. But, a/b/ should *not*\n        // match \"a/b/*\", even though \"\" matches against the\n        // [^/]*? pattern, except in partial mode, where it might\n        // simply not be reached yet.\n        // However, a/b/ should still satisfy a/*\n        // now either we fell off the end of the pattern, or we're done.\n        if (fi === fl && pi === pl) {\n            // ran out of pattern and filename at the same time.\n            // an exact hit!\n            return true;\n        }\n        else if (fi === fl) {\n            // ran out of file, but still had pattern left.\n            // this is ok if we're doing the match as part of\n            // a glob fs traversal.\n            return partial;\n        }\n        else if (pi === pl) {\n            // ran out of pattern, still have file left.\n            // this is only acceptable if we're on the very last\n            // empty segment of a file with a trailing slash.\n            // a/* should match a/b/\n            return fi === fl - 1 && file[fi] === '';\n            /* c8 ignore start */\n        }\n        else {\n            // should be unreachable.\n            throw new Error('wtf?');\n        }\n        /* c8 ignore stop */\n    }\n    braceExpand() {\n        return braceExpand(this.pattern, this.options);\n    }\n    parse(pattern) {\n        assertValidPattern(pattern);\n        const options = this.options;\n        // shortcuts\n        if (pattern === '**')\n            return GLOBSTAR;\n        if (pattern === '')\n            return '';\n        // far and away, the most common glob pattern parts are\n        // *, *.*, and *.<ext>  Add a fast check method for those.\n        let m;\n        let fastTest = null;\n        if ((m = pattern.match(starRE))) {\n            fastTest = options.dot ? starTestDot : starTest;\n        }\n        else if ((m = pattern.match(starDotExtRE))) {\n            fastTest = (options.nocase\n                ? options.dot\n                    ? starDotExtTestNocaseDot\n                    : starDotExtTestNocase\n                : options.dot\n                    ? starDotExtTestDot\n                    : starDotExtTest)(m[1]);\n        }\n        else if ((m = pattern.match(qmarksRE))) {\n            fastTest = (options.nocase\n                ? options.dot\n                    ? qmarksTestNocaseDot\n                    : qmarksTestNocase\n                : options.dot\n                    ? qmarksTestDot\n                    : qmarksTest)(m);\n        }\n        else if ((m = pattern.match(starDotStarRE))) {\n            fastTest = options.dot ? starDotStarTestDot : starDotStarTest;\n        }\n        else if ((m = pattern.match(dotStarRE))) {\n            fastTest = dotStarTest;\n        }\n        const re = AST.fromGlob(pattern, this.options).toMMPattern();\n        if (fastTest && typeof re === 'object') {\n            // Avoids overriding in frozen environments\n            Reflect.defineProperty(re, 'test', { value: fastTest });\n        }\n        return re;\n    }\n    makeRe() {\n        if (this.regexp || this.regexp === false)\n            return this.regexp;\n        // at this point, this.set is a 2d array of partial\n        // pattern strings, or \"**\".\n        //\n        // It's better to use .match().  This function shouldn't\n        // be used, really, but it's pretty convenient sometimes,\n        // when you just want to work with a regex.\n        const set = this.set;\n        if (!set.length) {\n            this.regexp = false;\n            return this.regexp;\n        }\n        const options = this.options;\n        const twoStar = options.noglobstar\n            ? star\n            : options.dot\n                ? twoStarDot\n                : twoStarNoDot;\n        const flags = new Set(options.nocase ? ['i'] : []);\n        // regexpify non-globstar patterns\n        // if ** is only item, then we just do one twoStar\n        // if ** is first, and there are more, prepend (\\/|twoStar\\/)? to next\n        // if ** is last, append (\\/twoStar|) to previous\n        // if ** is in the middle, append (\\/|\\/twoStar\\/) to previous\n        // then filter out GLOBSTAR symbols\n        let re = set\n            .map(pattern => {\n            const pp = pattern.map(p => {\n                if (p instanceof RegExp) {\n                    for (const f of p.flags.split(''))\n                        flags.add(f);\n                }\n                return typeof p === 'string'\n                    ? regExpEscape(p)\n                    : p === GLOBSTAR\n                        ? GLOBSTAR\n                        : p._src;\n            });\n            pp.forEach((p, i) => {\n                const next = pp[i + 1];\n                const prev = pp[i - 1];\n                if (p !== GLOBSTAR || prev === GLOBSTAR) {\n                    return;\n                }\n                if (prev === undefined) {\n                    if (next !== undefined && next !== GLOBSTAR) {\n                        pp[i + 1] = '(?:\\\\/|' + twoStar + '\\\\/)?' + next;\n                    }\n                    else {\n                        pp[i] = twoStar;\n                    }\n                }\n                else if (next === undefined) {\n                    pp[i - 1] = prev + '(?:\\\\/|' + twoStar + ')?';\n                }\n                else if (next !== GLOBSTAR) {\n                    pp[i - 1] = prev + '(?:\\\\/|\\\\/' + twoStar + '\\\\/)' + next;\n                    pp[i + 1] = GLOBSTAR;\n                }\n            });\n            return pp.filter(p => p !== GLOBSTAR).join('/');\n        })\n            .join('|');\n        // need to wrap in parens if we had more than one thing with |,\n        // otherwise only the first will be anchored to ^ and the last to $\n        const [open, close] = set.length > 1 ? ['(?:', ')'] : ['', ''];\n        // must match entire pattern\n        // ending in a * or ** will make it less strict.\n        re = '^' + open + re + close + '$';\n        // can match anything, as long as it's not this.\n        if (this.negate)\n            re = '^(?!' + re + ').+$';\n        try {\n            this.regexp = new RegExp(re, [...flags].join(''));\n            /* c8 ignore start */\n        }\n        catch (ex) {\n            // should be impossible\n            this.regexp = false;\n        }\n        /* c8 ignore stop */\n        return this.regexp;\n    }\n    slashSplit(p) {\n        // if p starts with // on windows, we preserve that\n        // so that UNC paths aren't broken.  Otherwise, any number of\n        // / characters are coalesced into one, unless\n        // preserveMultipleSlashes is set to true.\n        if (this.preserveMultipleSlashes) {\n            return p.split('/');\n        }\n        else if (this.isWindows && /^\\/\\/[^\\/]+/.test(p)) {\n            // add an extra '' for the one we lose\n            return ['', ...p.split(/\\/+/)];\n        }\n        else {\n            return p.split(/\\/+/);\n        }\n    }\n    match(f, partial = this.partial) {\n        this.debug('match', f, this.pattern);\n        // short-circuit in the case of busted things.\n        // comments, etc.\n        if (this.comment) {\n            return false;\n        }\n        if (this.empty) {\n            return f === '';\n        }\n        if (f === '/' && partial) {\n            return true;\n        }\n        const options = this.options;\n        // windows: need to use /, not \\\n        if (this.isWindows) {\n            f = f.split('\\\\').join('/');\n        }\n        // treat the test path as a set of pathparts.\n        const ff = this.slashSplit(f);\n        this.debug(this.pattern, 'split', ff);\n        // just ONE of the pattern sets in this.set needs to match\n        // in order for it to be valid.  If negating, then just one\n        // match means that we have failed.\n        // Either way, return on the first hit.\n        const set = this.set;\n        this.debug(this.pattern, 'set', set);\n        // Find the basename of the path by looking for the last non-empty segment\n        let filename = ff[ff.length - 1];\n        if (!filename) {\n            for (let i = ff.length - 2; !filename && i >= 0; i--) {\n                filename = ff[i];\n            }\n        }\n        for (let i = 0; i < set.length; i++) {\n            const pattern = set[i];\n            let file = ff;\n            if (options.matchBase && pattern.length === 1) {\n                file = [filename];\n            }\n            const hit = this.matchOne(file, pattern, partial);\n            if (hit) {\n                if (options.flipNegate) {\n                    return true;\n                }\n                return !this.negate;\n            }\n        }\n        // didn't get any hits.  this is success if it's a negative\n        // pattern, failure otherwise.\n        if (options.flipNegate) {\n            return false;\n        }\n        return this.negate;\n    }\n    static defaults(def) {\n        return minimatch.defaults(def).Minimatch;\n    }\n}\n/* c8 ignore start */\nexport { AST } from './ast.js';\nexport { escape } from './escape.js';\nexport { unescape } from './unescape.js';\n/* c8 ignore stop */\nminimatch.AST = AST;\nminimatch.Minimatch = Minimatch;\nminimatch.escape = escape;\nminimatch.unescape = unescape;\n//# sourceMappingURL=index.js.map","import { minimatch } from 'minimatch';\n\nimport { encodeString } from './encoder';\nimport {\n    DirectoryOperationError,\n    ExistenceError,\n    FileTypeError,\n    OPFSNotSupportedError,\n    ValidationError,\n    mapDomError\n} from './errors';\n\nimport type { Encoding } from '../types';\n\n\n/**\n * Check if the browser supports the OPFS API\n * \n * @throws {OPFSNotSupportedError} If the browser does not support the OPFS API\n */\nexport function checkOPFSSupport(): void {\n    if (!('storage' in navigator) || !('getDirectory' in (navigator.storage as any))) {\n        throw new OPFSNotSupportedError();\n    }\n}\n\nexport async function withLock<T>(\n    path: string,\n    mode: 'shared' | 'exclusive',\n    fn: () => Promise<T>\n): Promise<T> {\n    if (typeof navigator !== 'undefined' && navigator.locks?.request) {\n        return navigator.locks.request(`opfs:${ path.replace(/\\/+/g, '/') }`, { mode }, fn);\n    }\n\n    return fn();\n}\n\n/** \n * Split a path into an array of segments\n * \n * @param path - The path to split\n * @returns The array of segments\n * \n * @example\n * ```typescript\n * splitPath('/path/to/file'); // ['path', 'to', 'file']\n * splitPath('~/path/to/file'); // ['path', 'to', 'file'] (home dir handled)\n * splitPath('relative/path'); // ['relative', 'path']\n * ```\n */\nexport function splitPath(path: string | string[]): string[] {\n    if (Array.isArray(path)) {\n        return path;\n    }\n\n    const normalizedPath = path.startsWith('~/') ? path.slice(2) : path;\n\n    return normalizedPath.split('/').filter(Boolean);\n}\n\n\n/**\n * Join an array of path segments into a single path\n * \n * @param segments - The array of path segments\n * @returns The joined path\n */\nexport function joinPath(segments: string[] | string): string {\n    return typeof segments === 'string'\n        ? (segments ?? '/')\n        : `/${ segments.join('/') }`;\n}\n\n/**\n * Extract the filename from a path\n * \n * @param path - The file path\n * @returns The filename without the directory path\n * \n * @example\n * ```typescript\n * basename('/path/to/file.txt'); // 'file.txt'\n * basename('/path/to/directory/'); // ''\n * basename('file.txt'); // 'file.txt'\n * ```\n */\nexport function basename(path: string): string {\n    const segments = splitPath(path);\n\n    return segments[segments.length - 1] || '';\n}\n\n/**\n * Extract the directory path from a file path\n * \n * @param path - The file path\n * @returns The directory path without the filename\n * \n * @example\n * ```typescript\n * dirname('/path/to/file.txt'); // '/path/to'\n * dirname('/path/to/directory/'); // '/path/to/directory'\n * dirname('file.txt'); // '/'\n * ```\n */\nexport function dirname(path: string): string {\n    const segments = splitPath(path);\n\n    segments.pop();\n\n    return joinPath(segments);\n}\n\n/**\n * Normalize a path to ensure it starts with '/'\n * \n * @param path - The path to normalize\n * @returns The normalized path\n * \n * @example\n * ```typescript\n * normalizePath('path/to/file'); // '/path/to/file'\n * normalizePath('/path/to/file'); // '/path/to/file'\n * normalizePath('~/path/to/file'); // '/path/to/file' (home dir normalized to root)\n * normalizePath(''); // '/'\n * ```\n */\nexport function normalizePath(path: string): string {\n    if (!path || path === '/') {\n        return '/';\n    }\n\n    if (path.startsWith('~/')) {\n        return `/${ path.slice(2) }`;\n    }\n\n    return path.startsWith('/') ? path : `/${ path }`;\n}\n\nexport function normalizeMinimatch(path: string, recursive: boolean = false): string {\n    path = path.replace(/\\/$/, '');\n    if (recursive && !path.includes('*')) {\n        return `${ path }/**`;\n    }\n\n    return path;\n}\n\nexport function matchMinimatch(path: string, pattern: string): boolean {\n    return minimatch(path, pattern, {\n        dot: true,\n        matchBase: true,\n    });\n}\n\n/**\n * Check if a path matches any of the provided exclude patterns (minimatch syntax)\n *\n * @param path - Absolute or relative path\n * @param patterns - Glob pattern(s) to match against\n * @returns true if excluded, false otherwise\n */\nexport function isPathExcluded(path: string, patterns?: string | string[]): boolean {\n    if (!patterns || (Array.isArray(patterns) && patterns.length === 0)) {\n        return false;\n    }\n\n    const normalized = normalizePath(path);\n    const list = Array.isArray(patterns) ? patterns : [patterns];\n\n    return list.some(pattern => minimatch(normalized, pattern, { dot: true }));\n}\n\n/**\n * Resolve a path to an absolute path, handling relative segments\n * \n * @param path - The path to resolve\n * @returns The resolved absolute path\n * \n * @example\n * ```typescript\n * resolvePath('./config/../data/file.txt'); // '/data/file.txt'\n * resolvePath('/path/to/../file.txt'); // '/path/file.txt'\n * resolvePath('../../file.txt'); // '/file.txt' (truncated to root)\n * resolvePath('~/config/../data/file.txt'); // '/data/file.txt' (home dir normalized to root)\n * ```\n */\nexport function resolvePath(path: string): string {\n    // First normalize the path to handle home directory references\n    const normalizedPath = normalizePath(path);\n    const segments = splitPath(normalizedPath);\n    const normalizedSegments: string[] = [];\n\n    for (const segment of segments) {\n        if (segment === '.' || segment === '') {\n            // Skip current directory references and empty segments\n            continue;\n        }\n        else if (segment === '..') {\n            if (normalizedSegments.length === 0) {\n                // Path escapes root, keep at root level\n                continue;\n            }\n\n            // Go up one directory\n            normalizedSegments.pop();\n        }\n        else {\n            normalizedSegments.push(segment);\n        }\n    }\n\n    return joinPath(normalizedSegments);\n}\n\n/**\n * Get the file extension from a path\n * \n * @param path - The file path\n * @returns The file extension including the dot, or empty string if no extension\n * \n * @example\n * ```typescript\n * extname('/path/to/file.txt'); // '.txt'\n * extname('/path/to/file'); // ''\n * extname('/path/to/file.name.ext'); // '.ext'\n * extname('/path/to/.hidden'); // ''\n * ```\n */\nexport function extname(path: string): string {\n    const filename = basename(path);\n    const lastDotIndex = filename.lastIndexOf('.');\n\n    if (lastDotIndex <= 0 || lastDotIndex === filename.length - 1) {\n        return '';\n    }\n\n    return filename.slice(lastDotIndex);\n}\n\nexport function createBuffer(data: string | Uint8Array | ArrayBuffer, encoding: Encoding = 'utf-8'): Uint8Array {\n    if (typeof data === 'string') {\n        return encodeString(data, encoding);\n    }\n\n    return data instanceof Uint8Array ? data : new Uint8Array(data);\n}\n\n/**\n * Calculate file hash using Web Crypto API\n * \n * @param buffer - The file content as File, ArrayBuffer, or Uint8Array\n * @param algorithm - Hash algorithm to use (default: 'SHA-1')\n * @param maxSize - Maximum file size in bytes. If file is larger, throws error (default: 50MB)\n * @returns Promise that resolves to the hash string\n * @throws Error if file size exceeds maxSize\n */\nexport async function calculateFileHash(\n    buffer: File | ArrayBuffer | Uint8Array,\n    algorithm: string = 'SHA-1',\n    maxSize: number = 50 * 1024 * 1024 // 50MB default\n): Promise<string> {\n    if (buffer instanceof File) {\n        buffer = await buffer.arrayBuffer();\n    }\n\n    // Check file size before processing\n    if (buffer.byteLength > maxSize) {\n        throw new Error(`File size ${ buffer.byteLength } bytes exceeds maximum allowed size ${ maxSize } bytes`);\n    }\n\n    const bufferSource = new Uint8Array(buffer);\n    const hashBuffer = await crypto.subtle.digest(algorithm, bufferSource);\n    const hashArray = Array.from(new Uint8Array(hashBuffer));\n\n    return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');\n}\n\n/**\n * Compare two Uint8Array buffers for equality\n * \n * @param a - First buffer\n * @param b - Second buffer\n * @returns true if buffers are equal, false otherwise\n */\nexport function buffersEqual(a: Uint8Array, b: Uint8Array): boolean {\n    if (a.length !== b.length) {\n        return false;\n    }\n\n    for (let i = 0; i < a.length; i++) {\n        if (a[i] !== b[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n/**\n * Convert a Blob to Uint8Array\n * \n * This function converts a Blob object to a Uint8Array for use with file operations.\n * It's useful when working with file uploads or other Blob data sources.\n * \n * @param blob - The Blob to convert\n * @returns Promise that resolves to the Uint8Array representation of the Blob\n * \n * @example\n * ```typescript\n * const fileInput = document.getElementById('file') as HTMLInputElement;\n * const file = fileInput.files?.[0];\n * if (file) {\n *   const data = await convertBlobToUint8Array(file);\n *   await fs.writeFile('/uploaded-file', data);\n * }\n * }\n * ```\n */\nexport async function convertBlobToUint8Array(blob: Blob): Promise<Uint8Array> {\n    const arrayBuffer = await blob.arrayBuffer();\n\n    return new Uint8Array(arrayBuffer);\n}\n\n/**\n * Remove a file or directory entry using a directory handle\n *\n * @param parentHandle - The parent directory handle\n * @param path - The full path of the entry to remove\n * @param options - Remove options (recursive, force, useTrash)\n */\nexport async function removeEntry(\n    parentHandle: FileSystemDirectoryHandle,\n    path: string,\n    options: { recursive?: boolean; force?: boolean; useTrash?: boolean } = {}\n): Promise<void> {\n    const name = basename(path);\n\n    return withLock(path, 'exclusive', async() => {\n        const recursive = options.recursive ?? false;\n        const force = options.force ?? false;\n\n        try {\n            await parentHandle.removeEntry(name, { recursive });\n        }\n        catch (e: any) {\n            if (e.name === 'NotFoundError') {\n                if (!force) {\n                    throw new ExistenceError('file', path, e);\n                }\n            }\n            else if (e.name === 'InvalidModificationError') {\n                throw new DirectoryOperationError('clear', path, e);\n            }\n            else if (e.name === 'TypeMismatchError' && !recursive) {\n                throw new FileTypeError('file', 'directory', path, e);\n            }\n            else {\n                throw new DirectoryOperationError('remove', path, e);\n            }\n        }\n    });\n}\n\n/**\n * Validate read/write arguments for file descriptor operations\n * \n * @param bufferLen - Length of the buffer\n * @param offset - Offset in the buffer\n * @param length - Number of bytes to read/write\n * @param position - Position in the file (null for current position)\n * @param opts - Options for validation\n * @throws {OPFSError} If arguments are invalid\n */\nexport function validateReadWriteArgs(\n    bufferLen: number,\n    offset: number,\n    length: number,\n    position: number | null | undefined\n): void {\n    if (!Number.isInteger(offset) || !Number.isInteger(length)) {\n        throw new ValidationError('argument', 'Invalid offset or length');\n    }\n\n    if (offset < 0 || length < 0) {\n        throw new ValidationError('argument', 'Negative offset or length not allowed');\n    }\n\n    if (offset + length > bufferLen) {\n        throw new ValidationError('overflow', 'Operation would overflow buffer');\n    }\n\n    if (position != null && (!Number.isInteger(position) || position < 0)) {\n        throw new ValidationError('argument', 'Invalid position');\n    }\n}\n\n/**\n * Safely close a file descriptor's sync handle\n * \n * @param fd - The file descriptor number (for logging)\n * @param syncHandle - The sync handle to close\n * @param path - The file path (for logging)\n */\nexport function safeCloseSyncHandle(fd: number, syncHandle: any, path: string): void {\n    try {\n        syncHandle.flush();\n        syncHandle.close();\n    }\n    catch (error) {\n        // Log warning but don't throw, as the fd should still be removed\n        console.warn(`Warning: Failed to properly close file descriptor ${ fd } (${ path }):`, error);\n    }\n}\n\n/**\n * Check if position is at or beyond end of file and calculate actual read length\n * \n * @param position - The position to read from\n * @param requestedLength - The requested length to read\n * @param fileSize - The current file size\n * @returns Object with isEOF flag and actual length to read\n */\nexport function calculateReadLength(position: number, requestedLength: number, fileSize: number): { isEOF: boolean; actualLength: number } {\n    // Check if we're at or beyond end of file\n    if (position >= fileSize) {\n        return { isEOF: true, actualLength: 0 };\n    }\n\n    // Calculate actual length to read (don't read beyond file end)\n    const actualLength = Math.min(requestedLength, fileSize - position);\n\n    if (actualLength <= 0) {\n        return { isEOF: true, actualLength: 0 };\n    }\n\n    return { isEOF: false, actualLength };\n}\n\n/**\n * Safely create a sync access handle with proper error mapping\n * \n * @param fileHandle - The file handle to create sync access handle from\n * @param path - The file path for error context\n * @returns Promise that resolves to FileSystemSyncAccessHandle\n * @throws {OPFSError} If creation fails\n */\nexport async function createSyncHandleSafe(\n    fileHandle: FileSystemFileHandle,\n    path: string\n): Promise<FileSystemSyncAccessHandle> {\n    try {\n        return await fileHandle.createSyncAccessHandle();\n    }\n    catch (error: any) {\n        throw mapDomError(error, { path, isDirectory: false });\n    }\n}\n"],"names":["ERROR_CODE_TO_ERRNO","OPFSError","message","code","path","syscall","cause","OPFSNotSupportedError","PathError","ExistenceError","type","messages","PermissionError","operation","StorageError","TimeoutError","FileBusyError","FileTypeError","expectedType","actualType","ValidationError","codes","OperationAbortedError","IOError","OperationNotSupportedError","DirectoryOperationError","InitializationFailedError","FileSystemOperationError","PathResolutionFailedError","AlreadyExistsError","createFDError","fd","error","errorCode","mapDomError","context","isDirectory","BINARY_FILE_EXTENSIONS","isBinaryFileExtension","i","ext","encodeString","data","encoding","encodeUtf16LE","encodeAscii","encodeLatin1","char","c","b","decodeBuffer","buffer","decodeUtf16LE","str","buf","codeUnits","WatchEventType","balanced","a","ma","maybeMatch","mb","r","range","reg","m","begs","beg","left","right","result","ai","bi","escSlash","escOpen","escClose","escComma","escPeriod","escSlashPattern","escOpenPattern","escClosePattern","escCommaPattern","escPeriodPattern","slashPattern","openPattern","closePattern","commaPattern","periodPattern","numeric","escapeBraces","unescapeBraces","parseCommaParts","parts","pre","body","post","p","postParts","expand","expand_","embrace","isPadded","el","lte","y","gte","isTop","expansions","k","expansion","isNumericSequence","isAlphaSequence","isSequence","isOptions","n","N","x","width","incr","test","pad","need","z","j","MAX_PATTERN_LENGTH","assertValidPattern","pattern","posixClasses","braceEscape","regexpEscape","rangesToString","ranges","parseClass","glob","position","pos","negs","sawStart","uflag","escaping","negate","endPos","rangeStart","WHILE","cls","unip","u","neg","sranges","snegs","unescape","windowsPathsNoEscape","types","isExtglobType","startNoTraversal","startNoDot","addPatternStart","justDots","reSpecials","regExpEscape","qmark","star","starNoEmpty","AST","#root","#hasMagic","#uflag","#parts","#parent","#parentIndex","#negs","#filledNegs","#options","#toString","#emptyExt","parent","options","#fillNegs","pp","part","ret","pl","#parseAST","ast","opt","inBrace","braceStart","braceNeg","acc","re","hasMagic","flags","allowDot","dot","noEmpty","src","_","#parseGlob","start","aps","needNoTrav","needNoDot","end","repeated","#partsToRegExp","s","bodyDotAllowed","final","close","_hasMagic","needUflag","consumed","magic","escape","minimatch","Minimatch","starDotExtRE","starDotExtTest","f","starDotExtTestDot","starDotExtTestNocase","starDotExtTestNocaseDot","starDotStarRE","starDotStarTest","starDotStarTestDot","dotStarRE","dotStarTest","starRE","starTest","starTestDot","qmarksRE","qmarksTestNocase","$0","noext","qmarksTestNoExt","qmarksTestNocaseDot","qmarksTestNoExtDot","qmarksTestDot","qmarksTest","len","defaultPlatform","sep","GLOBSTAR","twoStarDot","twoStarNoDot","filter","defaults","def","orig","list","braceExpand","makeRe","match","mm","globMagic","args","rawGlobParts","set","__","isUNC","isDrive","ss","globParts","optimizationLevel","gs","prev","didSomething","dd","gss","next","p2","other","splin","matched","emptyGSMatch","which","negateOffset","file","partial","fileDrive","fileUNC","patternDrive","patternUNC","fdi","pdi","pd","fi","pi","fl","fr","pr","swallowee","hit","fastTest","twoStar","open","ff","filename","checkOPFSSupport","withLock","mode","fn","splitPath","joinPath","segments","basename","dirname","normalizePath","normalizeMinimatch","recursive","matchMinimatch","isPathExcluded","patterns","normalized","resolvePath","normalizedPath","normalizedSegments","segment","extname","lastDotIndex","createBuffer","calculateFileHash","algorithm","maxSize","bufferSource","hashBuffer","buffersEqual","convertBlobToUint8Array","blob","arrayBuffer","removeEntry","parentHandle","name","force","e","validateReadWriteArgs","bufferLen","offset","length","safeCloseSyncHandle","syncHandle","calculateReadLength","requestedLength","fileSize","actualLength","createSyncHandleSafe","fileHandle"],"mappings":"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","x_google_ignoreList":[3,4,5,6,7,8,9,10]}