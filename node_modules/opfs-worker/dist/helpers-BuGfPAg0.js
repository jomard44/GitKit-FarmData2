const le = {
  ENOENT: -2,
  // No such file or directory
  EISDIR: -21,
  // Is a directory
  ENOTDIR: -20,
  // Not a directory
  EACCES: -13,
  // Permission denied
  EEXIST: -17,
  // File exists
  ENOTEMPTY: -39,
  // Directory not empty
  EINVAL: -22,
  // Invalid argument
  EIO: -5,
  // I/O error
  ENOSPC: -28,
  // No space left on device
  EBUSY: -16,
  // Device or resource busy
  EINTR: -4,
  // Interrupted system call
  ENOTSUP: -95,
  // Operation not supported
  ERANGE: -34,
  // Result too large
  EBADF: -9,
  // Bad file descriptor
  EROOT: -1
  // Custom: Cannot remove root directory
};
class m extends Error {
  errno;
  syscall;
  path;
  constructor(e, t, n, r, i) {
    super(e, { cause: i }), this.name = t, this.errno = le[t] || -1, this.path = n, this.syscall = r;
  }
}
class he extends m {
  constructor(e) {
    super("OPFS is not supported in this browser", "OPFS_NOT_SUPPORTED", void 0, void 0, e);
  }
}
class Tt extends m {
  constructor(e, t, n) {
    super(e, "INVALID_PATH", t, "access", n);
  }
}
class Z extends m {
  constructor(e, t, n) {
    const r = {
      file: `File not found: ${t}`,
      directory: `Directory not found: ${t}`,
      source: `Source does not exist: ${t}`
    };
    super(r[e], "ENOENT", t, "access", n);
  }
}
class ue extends m {
  constructor(e, t, n) {
    super(`Permission denied for ${t} on: ${e}`, "PERMISSION_DENIED", e, t, n);
  }
}
class fe extends m {
  constructor(e, t, n) {
    super(e, "ENOSPC", t, "write", n);
  }
}
class Rt extends m {
  constructor(e, t, n) {
    super(`Operation timed out: ${e}`, "TIMEOUT_ERROR", t, e, n);
  }
}
class pe extends m {
  constructor(e, t) {
    super(`File is busy: ${e}`, "EBUSY", e, "open", t);
  }
}
class F extends m {
  constructor(e, t, n, r) {
    const i = t === "directory" ? `Is a directory: ${n}` : `Not a directory: ${n}`, o = t === "directory" ? "EISDIR" : "ENOTDIR";
    super(i, o, n, "access", r);
  }
}
class b extends m {
  constructor(e, t, n, r) {
    const i = {
      argument: "EINVAL",
      format: "INVALID_FORMAT",
      descriptor: "EBADF",
      overflow: "ERANGE"
    };
    super(t, i[e], n, "validate", r);
  }
}
class de extends m {
  constructor(e, t) {
    super(`Operation aborted: ${e}`, "EINTR", e, "interrupt", t);
  }
}
class W extends m {
  constructor(e, t, n) {
    super(e, "EIO", t, "io", n);
  }
}
class ge extends m {
  constructor(e, t) {
    super(`Operation not supported: ${e}`, "ENOTSUP", e, "operation", t);
  }
}
class z extends m {
  constructor(e, t, n) {
    const r = {
      remove: `Failed to remove entry: ${t}`,
      clear: `Directory not empty: ${t}. Use recursive option to force removal.`,
      root: "Cannot remove root directory"
    }, i = {
      remove: "RM_FAILED",
      clear: "ENOTEMPTY",
      root: "EROOT"
    };
    super(r[e], i[e], t, "unlink", n);
  }
}
class Pt extends m {
  constructor(e, t) {
    super("Failed to initialize OPFS", "INIT_FAILED", e, "init", t);
  }
}
class It extends m {
  constructor(e, t, n) {
    super(`Failed to ${e}: ${t}`, `${e.toUpperCase()}_FAILED`, t, e, n);
  }
}
class Mt extends m {
  constructor(e, t) {
    super(`Failed to resolve path: ${e}`, "REALPATH_FAILED", e, "realpath", t);
  }
}
class Ct extends m {
  constructor(e, t) {
    super(`Destination already exists: ${e}`, "EEXIST", e, "open", t);
  }
}
function Dt(s, e, t, n) {
  const r = `${s.toUpperCase()}_FAILED`;
  return new m(`Failed to ${s} file descriptor: ${e}`, r, t, s, n);
}
function me(s, e) {
  const t = e?.path, n = e?.isDirectory;
  switch (s.name) {
    case "InvalidStateError":
      return new pe(t || "unknown", s);
    case "QuotaExceededError":
      return new fe(`No space left on device: ${t || "unknown"}`, t, s);
    case "NotFoundError":
      return new Z("file", t, s);
    case "TypeMismatchError":
      return n !== void 0 ? n ? new F("file", "directory", t || "unknown", s) : new F("directory", "file", t || "unknown", s) : new b("argument", `Type mismatch: ${t || "unknown"}`, t, s);
    case "NotAllowedError":
    case "SecurityError":
      return new ue(t, "unknown", s);
    case "InvalidModificationError":
      return new b("argument", `Invalid modification: ${t || "unknown"}`, t, s);
    case "AbortError":
      return new de(t || "unknown", s);
    case "OperationError":
      return new W(`Operation failed: ${t || "unknown"}`, t, s);
    case "TypeError":
      return new ge(t || "unknown", s);
    default:
      return new W(`I/O error: ${t || "unknown"}`, t, s);
  }
}
const we = [
  // Images
  ".jpg",
  ".jpeg",
  ".png",
  ".gif",
  ".bmp",
  ".webp",
  ".ico",
  ".tiff",
  ".tga",
  // Audio
  ".mp3",
  ".wav",
  ".ogg",
  ".flac",
  ".aac",
  ".wma",
  ".m4a",
  // Video
  ".mp4",
  ".avi",
  ".mov",
  ".wmv",
  ".flv",
  ".webm",
  ".mkv",
  ".m4v",
  // Documents
  ".pdf",
  ".doc",
  ".docx",
  ".xls",
  ".xlsx",
  ".ppt",
  ".pptx",
  // Archives
  ".zip",
  ".rar",
  ".7z",
  ".tar",
  ".gz",
  ".bz2",
  // Executables
  ".exe",
  ".dll",
  ".so",
  ".dylib",
  // Other binary formats
  ".dat",
  ".db",
  ".sqlite",
  ".bin",
  ".obj",
  ".fbx",
  ".3ds"
];
function Lt(s) {
  const e = s.lastIndexOf(".");
  if (e <= 0)
    return !0;
  const t = s.slice(e).toLowerCase();
  return we.includes(t);
}
function Ee(s, e = "utf-8") {
  switch (e) {
    case "utf8":
    case "utf-8":
      return new TextEncoder().encode(s);
    case "utf16le":
    case "utf-16le":
    case "ucs2":
    case "ucs-2":
      return ye(s);
    case "ascii":
      return Oe(s);
    case "latin1":
      return Se(s);
    case "binary":
      return Uint8Array.from(s, (t) => t.charCodeAt(0));
    case "base64":
      return Uint8Array.from(atob(s), (t) => t.charCodeAt(0));
    case "hex":
      if (!/^[\da-f]+$/i.test(s) || s.length % 2 !== 0)
        throw new b("format", "Invalid hex string");
      return Uint8Array.from(s.match(/.{1,2}/g).map((t) => parseInt(t, 16)));
    default:
      return console.warn("Encoding not supported, falling back to UTF-8"), new TextEncoder().encode(s);
  }
}
function Ft(s, e = "utf-8") {
  switch (e) {
    case "utf8":
    case "utf-8":
      return new TextDecoder().decode(s);
    case "utf16le":
    case "utf-16le":
    case "ucs2":
    case "ucs-2":
      return xe(s);
    case "latin1":
      return String.fromCharCode(...s);
    case "ascii":
      return String.fromCharCode(...s.map((t) => t & 127));
    case "base64":
      return btoa(String.fromCharCode(...s));
    case "hex":
      return Array.from(s).map((t) => t.toString(16).padStart(2, "0")).join("");
    default:
      return console.warn("Unsupported encoding, falling back to UTF-8"), new TextDecoder().decode(s);
  }
}
function ye(s) {
  const e = new Uint8Array(s.length * 2);
  for (let t = 0; t < s.length; t++) {
    const n = s.charCodeAt(t);
    e[t * 2] = n & 255, e[t * 2 + 1] = n >> 8;
  }
  return e;
}
function xe(s) {
  s.length % 2 !== 0 && (console.warn("Invalid UTF-16LE buffer length, truncating last byte"), s = s.slice(0, s.length - 1));
  const e = new Uint16Array(s.buffer, s.byteOffset, s.byteLength / 2);
  return String.fromCharCode(...e);
}
function Se(s) {
  const e = new Uint8Array(s.length);
  for (let t = 0; t < s.length; t++)
    e[t] = s.charCodeAt(t) & 255;
  return e;
}
function Oe(s) {
  const e = new Uint8Array(s.length);
  for (let t = 0; t < s.length; t++)
    e[t] = s.charCodeAt(t) & 127;
  return e;
}
var Ae = /* @__PURE__ */ ((s) => (s.Added = "added", s.Changed = "changed", s.Removed = "removed", s))(Ae || {});
const J = (s, e, t) => {
  const n = s instanceof RegExp ? B(s, t) : s, r = e instanceof RegExp ? B(e, t) : e, i = n !== null && r != null && Ne(n, r, t);
  return i && {
    start: i[0],
    end: i[1],
    pre: t.slice(0, i[0]),
    body: t.slice(i[0] + n.length, i[1]),
    post: t.slice(i[1] + r.length)
  };
}, B = (s, e) => {
  const t = e.match(s);
  return t ? t[0] : null;
}, Ne = (s, e, t) => {
  let n, r, i, o, a, l = t.indexOf(s), h = t.indexOf(e, l + 1), c = l;
  if (l >= 0 && h > 0) {
    if (s === e)
      return [l, h];
    for (n = [], i = t.length; c >= 0 && !a; ) {
      if (c === l)
        n.push(c), l = t.indexOf(s, c + 1);
      else if (n.length === 1) {
        const p = n.pop();
        p !== void 0 && (a = [p, h]);
      } else
        r = n.pop(), r !== void 0 && r < i && (i = r, o = h), h = t.indexOf(e, c + 1);
      c = l < h && l >= 0 ? l : h;
    }
    n.length && o !== void 0 && (a = [i, o]);
  }
  return a;
}, X = "\0SLASH" + Math.random() + "\0", K = "\0OPEN" + Math.random() + "\0", k = "\0CLOSE" + Math.random() + "\0", Q = "\0COMMA" + Math.random() + "\0", ee = "\0PERIOD" + Math.random() + "\0", be = new RegExp(X, "g"), ve = new RegExp(K, "g"), $e = new RegExp(k, "g"), Te = new RegExp(Q, "g"), Re = new RegExp(ee, "g"), Pe = /\\\\/g, Ie = /\\{/g, Me = /\\}/g, Ce = /\\,/g, De = /\\./g;
function L(s) {
  return isNaN(s) ? s.charCodeAt(0) : parseInt(s, 10);
}
function Le(s) {
  return s.replace(Pe, X).replace(Ie, K).replace(Me, k).replace(Ce, Q).replace(De, ee);
}
function Fe(s) {
  return s.replace(be, "\\").replace(ve, "{").replace($e, "}").replace(Te, ",").replace(Re, ".");
}
function te(s) {
  if (!s)
    return [""];
  const e = [], t = J("{", "}", s);
  if (!t)
    return s.split(",");
  const { pre: n, body: r, post: i } = t, o = n.split(",");
  o[o.length - 1] += "{" + r + "}";
  const a = te(i);
  return i.length && (o[o.length - 1] += a.shift(), o.push.apply(o, a)), e.push.apply(e, o), e;
}
function ke(s) {
  return s ? (s.slice(0, 2) === "{}" && (s = "\\{\\}" + s.slice(2)), R(Le(s), !0).map(Fe)) : [];
}
function je(s) {
  return "{" + s + "}";
}
function Ue(s) {
  return /^-?0\d/.test(s);
}
function We(s, e) {
  return s <= e;
}
function ze(s, e) {
  return s >= e;
}
function R(s, e) {
  const t = [], n = J("{", "}", s);
  if (!n)
    return [s];
  const r = n.pre, i = n.post.length ? R(n.post, !1) : [""];
  if (/\$$/.test(n.pre))
    for (let o = 0; o < i.length; o++) {
      const a = r + "{" + n.body + "}" + i[o];
      t.push(a);
    }
  else {
    const o = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(n.body), a = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(n.body), l = o || a, h = n.body.indexOf(",") >= 0;
    if (!l && !h)
      return n.post.match(/,(?!,).*\}/) ? (s = n.pre + "{" + n.body + k + n.post, R(s)) : [s];
    let c;
    if (l)
      c = n.body.split(/\.\./);
    else if (c = te(n.body), c.length === 1 && c[0] !== void 0 && (c = R(c[0], !1).map(je), c.length === 1))
      return i.map((f) => n.pre + c[0] + f);
    let p;
    if (l && c[0] !== void 0 && c[1] !== void 0) {
      const f = L(c[0]), u = L(c[1]), g = Math.max(c[0].length, c[1].length);
      let d = c.length === 3 && c[2] !== void 0 ? Math.abs(L(c[2])) : 1, x = We;
      u < f && (d *= -1, x = ze);
      const v = c.some(Ue);
      p = [];
      for (let S = f; x(S, u); S += d) {
        let w;
        if (a)
          w = String.fromCharCode(S), w === "\\" && (w = "");
        else if (w = String(S), v) {
          const $ = g - w.length;
          if ($ > 0) {
            const I = new Array($ + 1).join("0");
            S < 0 ? w = "-" + I + w.slice(1) : w = I + w;
          }
        }
        p.push(w);
      }
    } else {
      p = [];
      for (let f = 0; f < c.length; f++)
        p.push.apply(p, R(c[f], !1));
    }
    for (let f = 0; f < p.length; f++)
      for (let u = 0; u < i.length; u++) {
        const g = r + p[f] + i[u];
        (!e || l || g) && t.push(g);
      }
  }
  return t;
}
const Be = 1024 * 64, C = (s) => {
  if (typeof s != "string")
    throw new TypeError("invalid pattern");
  if (s.length > Be)
    throw new TypeError("pattern is too long");
}, _e = {
  "[:alnum:]": ["\\p{L}\\p{Nl}\\p{Nd}", !0],
  "[:alpha:]": ["\\p{L}\\p{Nl}", !0],
  "[:ascii:]": ["\\x00-\\x7f", !1],
  "[:blank:]": ["\\p{Zs}\\t", !0],
  "[:cntrl:]": ["\\p{Cc}", !0],
  "[:digit:]": ["\\p{Nd}", !0],
  "[:graph:]": ["\\p{Z}\\p{C}", !0, !0],
  "[:lower:]": ["\\p{Ll}", !0],
  "[:print:]": ["\\p{C}", !0],
  "[:punct:]": ["\\p{P}", !0],
  "[:space:]": ["\\p{Z}\\t\\r\\n\\v\\f", !0],
  "[:upper:]": ["\\p{Lu}", !0],
  "[:word:]": ["\\p{L}\\p{Nl}\\p{Nd}\\p{Pc}", !0],
  "[:xdigit:]": ["A-Fa-f0-9", !1]
}, T = (s) => s.replace(/[[\]\\-]/g, "\\$&"), qe = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&"), _ = (s) => s.join(""), Ge = (s, e) => {
  const t = e;
  if (s.charAt(t) !== "[")
    throw new Error("not in a brace expression");
  const n = [], r = [];
  let i = t + 1, o = !1, a = !1, l = !1, h = !1, c = t, p = "";
  e: for (; i < s.length; ) {
    const d = s.charAt(i);
    if ((d === "!" || d === "^") && i === t + 1) {
      h = !0, i++;
      continue;
    }
    if (d === "]" && o && !l) {
      c = i + 1;
      break;
    }
    if (o = !0, d === "\\" && !l) {
      l = !0, i++;
      continue;
    }
    if (d === "[" && !l) {
      for (const [x, [N, v, S]] of Object.entries(_e))
        if (s.startsWith(x, i)) {
          if (p)
            return ["$.", !1, s.length - t, !0];
          i += x.length, S ? r.push(N) : n.push(N), a = a || v;
          continue e;
        }
    }
    if (l = !1, p) {
      d > p ? n.push(T(p) + "-" + T(d)) : d === p && n.push(T(d)), p = "", i++;
      continue;
    }
    if (s.startsWith("-]", i + 1)) {
      n.push(T(d + "-")), i += 2;
      continue;
    }
    if (s.startsWith("-", i + 1)) {
      p = d, i += 2;
      continue;
    }
    n.push(T(d)), i++;
  }
  if (c < i)
    return ["", !1, 0, !1];
  if (!n.length && !r.length)
    return ["$.", !1, s.length - t, !0];
  if (r.length === 0 && n.length === 1 && /^\\?.$/.test(n[0]) && !h) {
    const d = n[0].length === 2 ? n[0].slice(-1) : n[0];
    return [qe(d), !1, c - t, !1];
  }
  const f = "[" + (h ? "^" : "") + _(n) + "]", u = "[" + (h ? "" : "^") + _(r) + "]";
  return [n.length && r.length ? "(" + f + "|" + u + ")" : n.length ? f : u, a, c - t, !0];
}, P = (s, { windowsPathsNoEscape: e = !1 } = {}) => e ? s.replace(/\[([^\/\\])\]/g, "$1") : s.replace(/((?!\\).|^)\[([^\/\\])\]/g, "$1$2").replace(/\\([^\/])/g, "$1"), He = /* @__PURE__ */ new Set(["!", "?", "+", "*", "@"]), q = (s) => He.has(s), Ve = "(?!(?:^|/)\\.\\.?(?:$|/))", M = "(?!\\.)", Ye = /* @__PURE__ */ new Set(["[", "."]), Ze = /* @__PURE__ */ new Set(["..", "."]), Je = new Set("().*{}+?[]^$\\!"), Xe = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&"), j = "[^/]", G = j + "*?", H = j + "+?";
class y {
  type;
  #s;
  #n;
  #i = !1;
  #e = [];
  #t;
  #o;
  #a;
  #c = !1;
  #r;
  #l;
  // set to true if it's an extglob with no children
  // (which really means one child of '')
  #u = !1;
  constructor(e, t, n = {}) {
    this.type = e, e && (this.#n = !0), this.#t = t, this.#s = this.#t ? this.#t.#s : this, this.#r = this.#s === this ? n : this.#s.#r, this.#a = this.#s === this ? [] : this.#s.#a, e === "!" && !this.#s.#c && this.#a.push(this), this.#o = this.#t ? this.#t.#e.length : 0;
  }
  get hasMagic() {
    if (this.#n !== void 0)
      return this.#n;
    for (const e of this.#e)
      if (typeof e != "string" && (e.type || e.hasMagic))
        return this.#n = !0;
    return this.#n;
  }
  // reconstructs the pattern
  toString() {
    return this.#l !== void 0 ? this.#l : this.type ? this.#l = this.type + "(" + this.#e.map((e) => String(e)).join("|") + ")" : this.#l = this.#e.map((e) => String(e)).join("");
  }
  #p() {
    if (this !== this.#s)
      throw new Error("should only call on root");
    if (this.#c)
      return this;
    this.toString(), this.#c = !0;
    let e;
    for (; e = this.#a.pop(); ) {
      if (e.type !== "!")
        continue;
      let t = e, n = t.#t;
      for (; n; ) {
        for (let r = t.#o + 1; !n.type && r < n.#e.length; r++)
          for (const i of e.#e) {
            if (typeof i == "string")
              throw new Error("string part in extglob AST??");
            i.copyIn(n.#e[r]);
          }
        t = n, n = t.#t;
      }
    }
    return this;
  }
  push(...e) {
    for (const t of e)
      if (t !== "") {
        if (typeof t != "string" && !(t instanceof y && t.#t === this))
          throw new Error("invalid part: " + t);
        this.#e.push(t);
      }
  }
  toJSON() {
    const e = this.type === null ? this.#e.slice().map((t) => typeof t == "string" ? t : t.toJSON()) : [this.type, ...this.#e.map((t) => t.toJSON())];
    return this.isStart() && !this.type && e.unshift([]), this.isEnd() && (this === this.#s || this.#s.#c && this.#t?.type === "!") && e.push({}), e;
  }
  isStart() {
    if (this.#s === this)
      return !0;
    if (!this.#t?.isStart())
      return !1;
    if (this.#o === 0)
      return !0;
    const e = this.#t;
    for (let t = 0; t < this.#o; t++) {
      const n = e.#e[t];
      if (!(n instanceof y && n.type === "!"))
        return !1;
    }
    return !0;
  }
  isEnd() {
    if (this.#s === this || this.#t?.type === "!")
      return !0;
    if (!this.#t?.isEnd())
      return !1;
    if (!this.type)
      return this.#t?.isEnd();
    const e = this.#t ? this.#t.#e.length : 0;
    return this.#o === e - 1;
  }
  copyIn(e) {
    typeof e == "string" ? this.push(e) : this.push(e.clone(this));
  }
  clone(e) {
    const t = new y(this.type, e);
    for (const n of this.#e)
      t.copyIn(n);
    return t;
  }
  static #h(e, t, n, r) {
    let i = !1, o = !1, a = -1, l = !1;
    if (t.type === null) {
      let u = n, g = "";
      for (; u < e.length; ) {
        const d = e.charAt(u++);
        if (i || d === "\\") {
          i = !i, g += d;
          continue;
        }
        if (o) {
          u === a + 1 ? (d === "^" || d === "!") && (l = !0) : d === "]" && !(u === a + 2 && l) && (o = !1), g += d;
          continue;
        } else if (d === "[") {
          o = !0, a = u, l = !1, g += d;
          continue;
        }
        if (!r.noext && q(d) && e.charAt(u) === "(") {
          t.push(g), g = "";
          const x = new y(d, t);
          u = y.#h(e, x, u, r), t.push(x);
          continue;
        }
        g += d;
      }
      return t.push(g), u;
    }
    let h = n + 1, c = new y(null, t);
    const p = [];
    let f = "";
    for (; h < e.length; ) {
      const u = e.charAt(h++);
      if (i || u === "\\") {
        i = !i, f += u;
        continue;
      }
      if (o) {
        h === a + 1 ? (u === "^" || u === "!") && (l = !0) : u === "]" && !(h === a + 2 && l) && (o = !1), f += u;
        continue;
      } else if (u === "[") {
        o = !0, a = h, l = !1, f += u;
        continue;
      }
      if (q(u) && e.charAt(h) === "(") {
        c.push(f), f = "";
        const g = new y(u, c);
        c.push(g), h = y.#h(e, g, h, r);
        continue;
      }
      if (u === "|") {
        c.push(f), f = "", p.push(c), c = new y(null, t);
        continue;
      }
      if (u === ")")
        return f === "" && t.#e.length === 0 && (t.#u = !0), c.push(f), f = "", t.push(...p, c), h;
      f += u;
    }
    return t.type = null, t.#n = void 0, t.#e = [e.substring(n - 1)], h;
  }
  static fromGlob(e, t = {}) {
    const n = new y(null, void 0, t);
    return y.#h(e, n, 0, t), n;
  }
  // returns the regular expression if there's magic, or the unescaped
  // string if not.
  toMMPattern() {
    if (this !== this.#s)
      return this.#s.toMMPattern();
    const e = this.toString(), [t, n, r, i] = this.toRegExpSource();
    if (!(r || this.#n || this.#r.nocase && !this.#r.nocaseMagicOnly && e.toUpperCase() !== e.toLowerCase()))
      return n;
    const a = (this.#r.nocase ? "i" : "") + (i ? "u" : "");
    return Object.assign(new RegExp(`^${t}$`, a), {
      _src: t,
      _glob: e
    });
  }
  get options() {
    return this.#r;
  }
  // returns the string match, the regexp source, whether there's magic
  // in the regexp (so a regular expression is required) and whether or
  // not the uflag is needed for the regular expression (for posix classes)
  // TODO: instead of injecting the start/end at this point, just return
  // the BODY of the regexp, along with the start/end portions suitable
  // for binding the start/end in either a joined full-path makeRe context
  // (where we bind to (^|/), or a standalone matchPart context (where
  // we bind to ^, and not /).  Otherwise slashes get duped!
  //
  // In part-matching mode, the start is:
  // - if not isStart: nothing
  // - if traversal possible, but not allowed: ^(?!\.\.?$)
  // - if dots allowed or not possible: ^
  // - if dots possible and not allowed: ^(?!\.)
  // end is:
  // - if not isEnd(): nothing
  // - else: $
  //
  // In full-path matching mode, we put the slash at the START of the
  // pattern, so start is:
  // - if first pattern: same as part-matching mode
  // - if not isStart(): nothing
  // - if traversal possible, but not allowed: /(?!\.\.?(?:$|/))
  // - if dots allowed or not possible: /
  // - if dots possible and not allowed: /(?!\.)
  // end is:
  // - if last pattern, same as part-matching mode
  // - else nothing
  //
  // Always put the (?:$|/) on negated tails, though, because that has to be
  // there to bind the end of the negated pattern portion, and it's easier to
  // just stick it in now rather than try to inject it later in the middle of
  // the pattern.
  //
  // We can just always return the same end, and leave it up to the caller
  // to know whether it's going to be used joined or in parts.
  // And, if the start is adjusted slightly, can do the same there:
  // - if not isStart: nothing
  // - if traversal possible, but not allowed: (?:/|^)(?!\.\.?$)
  // - if dots allowed or not possible: (?:/|^)
  // - if dots possible and not allowed: (?:/|^)(?!\.)
  //
  // But it's better to have a simpler binding without a conditional, for
  // performance, so probably better to return both start options.
  //
  // Then the caller just ignores the end if it's not the first pattern,
  // and the start always gets applied.
  //
  // But that's always going to be $ if it's the ending pattern, or nothing,
  // so the caller can just attach $ at the end of the pattern when building.
  //
  // So the todo is:
  // - better detect what kind of start is needed
  // - return both flavors of starting pattern
  // - attach $ at the end of the pattern when creating the actual RegExp
  //
  // Ah, but wait, no, that all only applies to the root when the first pattern
  // is not an extglob. If the first pattern IS an extglob, then we need all
  // that dot prevention biz to live in the extglob portions, because eg
  // +(*|.x*) can match .xy but not .yx.
  //
  // So, return the two flavors if it's #root and the first child is not an
  // AST, otherwise leave it to the child AST to handle it, and there,
  // use the (?:^|/) style of start binding.
  //
  // Even simplified further:
  // - Since the start for a join is eg /(?!\.) and the start for a part
  // is ^(?!\.), we can just prepend (?!\.) to the pattern (either root
  // or start or whatever) and prepend ^ or / at the Regexp construction.
  toRegExpSource(e) {
    const t = e ?? !!this.#r.dot;
    if (this.#s === this && this.#p(), !this.type) {
      const l = this.isStart() && this.isEnd(), h = this.#e.map((u) => {
        const [g, d, x, N] = typeof u == "string" ? y.#d(u, this.#n, l) : u.toRegExpSource(e);
        return this.#n = this.#n || x, this.#i = this.#i || N, g;
      }).join("");
      let c = "";
      if (this.isStart() && typeof this.#e[0] == "string" && !(this.#e.length === 1 && Ze.has(this.#e[0]))) {
        const g = Ye, d = (
          // dots are allowed, and the pattern starts with [ or .
          t && g.has(h.charAt(0)) || // the pattern starts with \., and then [ or .
          h.startsWith("\\.") && g.has(h.charAt(2)) || // the pattern starts with \.\., and then [ or .
          h.startsWith("\\.\\.") && g.has(h.charAt(4))
        ), x = !t && !e && g.has(h.charAt(0));
        c = d ? Ve : x ? M : "";
      }
      let p = "";
      return this.isEnd() && this.#s.#c && this.#t?.type === "!" && (p = "(?:$|\\/)"), [
        c + h + p,
        P(h),
        this.#n = !!this.#n,
        this.#i
      ];
    }
    const n = this.type === "*" || this.type === "+", r = this.type === "!" ? "(?:(?!(?:" : "(?:";
    let i = this.#f(t);
    if (this.isStart() && this.isEnd() && !i && this.type !== "!") {
      const l = this.toString();
      return this.#e = [l], this.type = null, this.#n = void 0, [l, P(this.toString()), !1, !1];
    }
    let o = !n || e || t || !M ? "" : this.#f(!0);
    o === i && (o = ""), o && (i = `(?:${i})(?:${o})*?`);
    let a = "";
    if (this.type === "!" && this.#u)
      a = (this.isStart() && !t ? M : "") + H;
    else {
      const l = this.type === "!" ? (
        // !() must match something,but !(x) can match ''
        "))" + (this.isStart() && !t && !e ? M : "") + G + ")"
      ) : this.type === "@" ? ")" : this.type === "?" ? ")?" : this.type === "+" && o ? ")" : this.type === "*" && o ? ")?" : `)${this.type}`;
      a = r + i + l;
    }
    return [
      a,
      P(i),
      this.#n = !!this.#n,
      this.#i
    ];
  }
  #f(e) {
    return this.#e.map((t) => {
      if (typeof t == "string")
        throw new Error("string type in extglob ast??");
      const [n, r, i, o] = t.toRegExpSource(e);
      return this.#i = this.#i || o, n;
    }).filter((t) => !(this.isStart() && this.isEnd()) || !!t).join("|");
  }
  static #d(e, t, n = !1) {
    let r = !1, i = "", o = !1;
    for (let a = 0; a < e.length; a++) {
      const l = e.charAt(a);
      if (r) {
        r = !1, i += (Je.has(l) ? "\\" : "") + l;
        continue;
      }
      if (l === "\\") {
        a === e.length - 1 ? i += "\\\\" : r = !0;
        continue;
      }
      if (l === "[") {
        const [h, c, p, f] = Ge(e, a);
        if (p) {
          i += h, o = o || c, a += p - 1, t = t || f;
          continue;
        }
      }
      if (l === "*") {
        n && e === "*" ? i += H : i += G, t = !0;
        continue;
      }
      if (l === "?") {
        i += j, t = !0;
        continue;
      }
      i += Xe(l);
    }
    return [i, P(e), !!t, o];
  }
}
const Ke = (s, { windowsPathsNoEscape: e = !1 } = {}) => e ? s.replace(/[?*()[\]]/g, "[$&]") : s.replace(/[?*()[\]\\]/g, "\\$&"), E = (s, e, t = {}) => (C(e), !t.nocomment && e.charAt(0) === "#" ? !1 : new D(e, t).match(s)), Qe = /^\*+([^+@!?\*\[\(]*)$/, et = (s) => (e) => !e.startsWith(".") && e.endsWith(s), tt = (s) => (e) => e.endsWith(s), st = (s) => (s = s.toLowerCase(), (e) => !e.startsWith(".") && e.toLowerCase().endsWith(s)), nt = (s) => (s = s.toLowerCase(), (e) => e.toLowerCase().endsWith(s)), rt = /^\*+\.\*+$/, it = (s) => !s.startsWith(".") && s.includes("."), ot = (s) => s !== "." && s !== ".." && s.includes("."), ct = /^\.\*+$/, at = (s) => s !== "." && s !== ".." && s.startsWith("."), lt = /^\*+$/, ht = (s) => s.length !== 0 && !s.startsWith("."), ut = (s) => s.length !== 0 && s !== "." && s !== "..", ft = /^\?+([^+@!?\*\[\(]*)?$/, pt = ([s, e = ""]) => {
  const t = se([s]);
  return e ? (e = e.toLowerCase(), (n) => t(n) && n.toLowerCase().endsWith(e)) : t;
}, dt = ([s, e = ""]) => {
  const t = ne([s]);
  return e ? (e = e.toLowerCase(), (n) => t(n) && n.toLowerCase().endsWith(e)) : t;
}, gt = ([s, e = ""]) => {
  const t = ne([s]);
  return e ? (n) => t(n) && n.endsWith(e) : t;
}, mt = ([s, e = ""]) => {
  const t = se([s]);
  return e ? (n) => t(n) && n.endsWith(e) : t;
}, se = ([s]) => {
  const e = s.length;
  return (t) => t.length === e && !t.startsWith(".");
}, ne = ([s]) => {
  const e = s.length;
  return (t) => t.length === e && t !== "." && t !== "..";
}, re = typeof process == "object" && process ? typeof process.env == "object" && process.env && process.env.__MINIMATCH_TESTING_PLATFORM__ || process.platform : "posix", V = {
  win32: { sep: "\\" },
  posix: { sep: "/" }
}, wt = re === "win32" ? V.win32.sep : V.posix.sep;
E.sep = wt;
const A = Symbol("globstar **");
E.GLOBSTAR = A;
const Et = "[^/]", yt = Et + "*?", xt = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?", St = "(?:(?!(?:\\/|^)\\.).)*?", Ot = (s, e = {}) => (t) => E(t, s, e);
E.filter = Ot;
const O = (s, e = {}) => Object.assign({}, s, e), At = (s) => {
  if (!s || typeof s != "object" || !Object.keys(s).length)
    return E;
  const e = E;
  return Object.assign((n, r, i = {}) => e(n, r, O(s, i)), {
    Minimatch: class extends e.Minimatch {
      constructor(r, i = {}) {
        super(r, O(s, i));
      }
      static defaults(r) {
        return e.defaults(O(s, r)).Minimatch;
      }
    },
    AST: class extends e.AST {
      /* c8 ignore start */
      constructor(r, i, o = {}) {
        super(r, i, O(s, o));
      }
      /* c8 ignore stop */
      static fromGlob(r, i = {}) {
        return e.AST.fromGlob(r, O(s, i));
      }
    },
    unescape: (n, r = {}) => e.unescape(n, O(s, r)),
    escape: (n, r = {}) => e.escape(n, O(s, r)),
    filter: (n, r = {}) => e.filter(n, O(s, r)),
    defaults: (n) => e.defaults(O(s, n)),
    makeRe: (n, r = {}) => e.makeRe(n, O(s, r)),
    braceExpand: (n, r = {}) => e.braceExpand(n, O(s, r)),
    match: (n, r, i = {}) => e.match(n, r, O(s, i)),
    sep: e.sep,
    GLOBSTAR: A
  });
};
E.defaults = At;
const ie = (s, e = {}) => (C(s), e.nobrace || !/\{(?:(?!\{).)*\}/.test(s) ? [s] : ke(s));
E.braceExpand = ie;
const Nt = (s, e = {}) => new D(s, e).makeRe();
E.makeRe = Nt;
const bt = (s, e, t = {}) => {
  const n = new D(e, t);
  return s = s.filter((r) => n.match(r)), n.options.nonull && !s.length && s.push(e), s;
};
E.match = bt;
const Y = /[?*]|[+@!]\(.*?\)|\[|\]/, vt = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
class D {
  options;
  set;
  pattern;
  windowsPathsNoEscape;
  nonegate;
  negate;
  comment;
  empty;
  preserveMultipleSlashes;
  partial;
  globSet;
  globParts;
  nocase;
  isWindows;
  platform;
  windowsNoMagicRoot;
  regexp;
  constructor(e, t = {}) {
    C(e), t = t || {}, this.options = t, this.pattern = e, this.platform = t.platform || re, this.isWindows = this.platform === "win32", this.windowsPathsNoEscape = !!t.windowsPathsNoEscape || t.allowWindowsEscape === !1, this.windowsPathsNoEscape && (this.pattern = this.pattern.replace(/\\/g, "/")), this.preserveMultipleSlashes = !!t.preserveMultipleSlashes, this.regexp = null, this.negate = !1, this.nonegate = !!t.nonegate, this.comment = !1, this.empty = !1, this.partial = !!t.partial, this.nocase = !!this.options.nocase, this.windowsNoMagicRoot = t.windowsNoMagicRoot !== void 0 ? t.windowsNoMagicRoot : !!(this.isWindows && this.nocase), this.globSet = [], this.globParts = [], this.set = [], this.make();
  }
  hasMagic() {
    if (this.options.magicalBraces && this.set.length > 1)
      return !0;
    for (const e of this.set)
      for (const t of e)
        if (typeof t != "string")
          return !0;
    return !1;
  }
  debug(...e) {
  }
  make() {
    const e = this.pattern, t = this.options;
    if (!t.nocomment && e.charAt(0) === "#") {
      this.comment = !0;
      return;
    }
    if (!e) {
      this.empty = !0;
      return;
    }
    this.parseNegate(), this.globSet = [...new Set(this.braceExpand())], t.debug && (this.debug = (...i) => console.error(...i)), this.debug(this.pattern, this.globSet);
    const n = this.globSet.map((i) => this.slashSplit(i));
    this.globParts = this.preprocess(n), this.debug(this.pattern, this.globParts);
    let r = this.globParts.map((i, o, a) => {
      if (this.isWindows && this.windowsNoMagicRoot) {
        const l = i[0] === "" && i[1] === "" && (i[2] === "?" || !Y.test(i[2])) && !Y.test(i[3]), h = /^[a-z]:/i.test(i[0]);
        if (l)
          return [...i.slice(0, 4), ...i.slice(4).map((c) => this.parse(c))];
        if (h)
          return [i[0], ...i.slice(1).map((c) => this.parse(c))];
      }
      return i.map((l) => this.parse(l));
    });
    if (this.debug(this.pattern, r), this.set = r.filter((i) => i.indexOf(!1) === -1), this.isWindows)
      for (let i = 0; i < this.set.length; i++) {
        const o = this.set[i];
        o[0] === "" && o[1] === "" && this.globParts[i][2] === "?" && typeof o[3] == "string" && /^[a-z]:$/i.test(o[3]) && (o[2] = "?");
      }
    this.debug(this.pattern, this.set);
  }
  // various transforms to equivalent pattern sets that are
  // faster to process in a filesystem walk.  The goal is to
  // eliminate what we can, and push all ** patterns as far
  // to the right as possible, even if it increases the number
  // of patterns that we have to process.
  preprocess(e) {
    if (this.options.noglobstar)
      for (let n = 0; n < e.length; n++)
        for (let r = 0; r < e[n].length; r++)
          e[n][r] === "**" && (e[n][r] = "*");
    const { optimizationLevel: t = 1 } = this.options;
    return t >= 2 ? (e = this.firstPhasePreProcess(e), e = this.secondPhasePreProcess(e)) : t >= 1 ? e = this.levelOneOptimize(e) : e = this.adjascentGlobstarOptimize(e), e;
  }
  // just get rid of adjascent ** portions
  adjascentGlobstarOptimize(e) {
    return e.map((t) => {
      let n = -1;
      for (; (n = t.indexOf("**", n + 1)) !== -1; ) {
        let r = n;
        for (; t[r + 1] === "**"; )
          r++;
        r !== n && t.splice(n, r - n);
      }
      return t;
    });
  }
  // get rid of adjascent ** and resolve .. portions
  levelOneOptimize(e) {
    return e.map((t) => (t = t.reduce((n, r) => {
      const i = n[n.length - 1];
      return r === "**" && i === "**" ? n : r === ".." && i && i !== ".." && i !== "." && i !== "**" ? (n.pop(), n) : (n.push(r), n);
    }, []), t.length === 0 ? [""] : t));
  }
  levelTwoFileOptimize(e) {
    Array.isArray(e) || (e = this.slashSplit(e));
    let t = !1;
    do {
      if (t = !1, !this.preserveMultipleSlashes) {
        for (let r = 1; r < e.length - 1; r++) {
          const i = e[r];
          r === 1 && i === "" && e[0] === "" || (i === "." || i === "") && (t = !0, e.splice(r, 1), r--);
        }
        e[0] === "." && e.length === 2 && (e[1] === "." || e[1] === "") && (t = !0, e.pop());
      }
      let n = 0;
      for (; (n = e.indexOf("..", n + 1)) !== -1; ) {
        const r = e[n - 1];
        r && r !== "." && r !== ".." && r !== "**" && (t = !0, e.splice(n - 1, 2), n -= 2);
      }
    } while (t);
    return e.length === 0 ? [""] : e;
  }
  // First phase: single-pattern processing
  // <pre> is 1 or more portions
  // <rest> is 1 or more portions
  // <p> is any portion other than ., .., '', or **
  // <e> is . or ''
  //
  // **/.. is *brutal* for filesystem walking performance, because
  // it effectively resets the recursive walk each time it occurs,
  // and ** cannot be reduced out by a .. pattern part like a regexp
  // or most strings (other than .., ., and '') can be.
  //
  // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}
  // <pre>/<e>/<rest> -> <pre>/<rest>
  // <pre>/<p>/../<rest> -> <pre>/<rest>
  // **/**/<rest> -> **/<rest>
  //
  // **/*/<rest> -> */**/<rest> <== not valid because ** doesn't follow
  // this WOULD be allowed if ** did follow symlinks, or * didn't
  firstPhasePreProcess(e) {
    let t = !1;
    do {
      t = !1;
      for (let n of e) {
        let r = -1;
        for (; (r = n.indexOf("**", r + 1)) !== -1; ) {
          let o = r;
          for (; n[o + 1] === "**"; )
            o++;
          o > r && n.splice(r + 1, o - r);
          let a = n[r + 1];
          const l = n[r + 2], h = n[r + 3];
          if (a !== ".." || !l || l === "." || l === ".." || !h || h === "." || h === "..")
            continue;
          t = !0, n.splice(r, 1);
          const c = n.slice(0);
          c[r] = "**", e.push(c), r--;
        }
        if (!this.preserveMultipleSlashes) {
          for (let o = 1; o < n.length - 1; o++) {
            const a = n[o];
            o === 1 && a === "" && n[0] === "" || (a === "." || a === "") && (t = !0, n.splice(o, 1), o--);
          }
          n[0] === "." && n.length === 2 && (n[1] === "." || n[1] === "") && (t = !0, n.pop());
        }
        let i = 0;
        for (; (i = n.indexOf("..", i + 1)) !== -1; ) {
          const o = n[i - 1];
          if (o && o !== "." && o !== ".." && o !== "**") {
            t = !0;
            const l = i === 1 && n[i + 1] === "**" ? ["."] : [];
            n.splice(i - 1, 2, ...l), n.length === 0 && n.push(""), i -= 2;
          }
        }
      }
    } while (t);
    return e;
  }
  // second phase: multi-pattern dedupes
  // {<pre>/*/<rest>,<pre>/<p>/<rest>} -> <pre>/*/<rest>
  // {<pre>/<rest>,<pre>/<rest>} -> <pre>/<rest>
  // {<pre>/**/<rest>,<pre>/<rest>} -> <pre>/**/<rest>
  //
  // {<pre>/**/<rest>,<pre>/**/<p>/<rest>} -> <pre>/**/<rest>
  // ^-- not valid because ** doens't follow symlinks
  secondPhasePreProcess(e) {
    for (let t = 0; t < e.length - 1; t++)
      for (let n = t + 1; n < e.length; n++) {
        const r = this.partsMatch(e[t], e[n], !this.preserveMultipleSlashes);
        if (r) {
          e[t] = [], e[n] = r;
          break;
        }
      }
    return e.filter((t) => t.length);
  }
  partsMatch(e, t, n = !1) {
    let r = 0, i = 0, o = [], a = "";
    for (; r < e.length && i < t.length; )
      if (e[r] === t[i])
        o.push(a === "b" ? t[i] : e[r]), r++, i++;
      else if (n && e[r] === "**" && t[i] === e[r + 1])
        o.push(e[r]), r++;
      else if (n && t[i] === "**" && e[r] === t[i + 1])
        o.push(t[i]), i++;
      else if (e[r] === "*" && t[i] && (this.options.dot || !t[i].startsWith(".")) && t[i] !== "**") {
        if (a === "b")
          return !1;
        a = "a", o.push(e[r]), r++, i++;
      } else if (t[i] === "*" && e[r] && (this.options.dot || !e[r].startsWith(".")) && e[r] !== "**") {
        if (a === "a")
          return !1;
        a = "b", o.push(t[i]), r++, i++;
      } else
        return !1;
    return e.length === t.length && o;
  }
  parseNegate() {
    if (this.nonegate)
      return;
    const e = this.pattern;
    let t = !1, n = 0;
    for (let r = 0; r < e.length && e.charAt(r) === "!"; r++)
      t = !t, n++;
    n && (this.pattern = e.slice(n)), this.negate = t;
  }
  // set partial to true to test if, for example,
  // "/a/b" matches the start of "/*/b/*/d"
  // Partial means, if you run out of file before you run
  // out of pattern, then that's fine, as long as all
  // the parts match.
  matchOne(e, t, n = !1) {
    const r = this.options;
    if (this.isWindows) {
      const d = typeof e[0] == "string" && /^[a-z]:$/i.test(e[0]), x = !d && e[0] === "" && e[1] === "" && e[2] === "?" && /^[a-z]:$/i.test(e[3]), N = typeof t[0] == "string" && /^[a-z]:$/i.test(t[0]), v = !N && t[0] === "" && t[1] === "" && t[2] === "?" && typeof t[3] == "string" && /^[a-z]:$/i.test(t[3]), S = x ? 3 : d ? 0 : void 0, w = v ? 3 : N ? 0 : void 0;
      if (typeof S == "number" && typeof w == "number") {
        const [$, I] = [e[S], t[w]];
        $.toLowerCase() === I.toLowerCase() && (t[w] = $, w > S ? t = t.slice(w) : S > w && (e = e.slice(S)));
      }
    }
    const { optimizationLevel: i = 1 } = this.options;
    i >= 2 && (e = this.levelTwoFileOptimize(e)), this.debug("matchOne", this, { file: e, pattern: t }), this.debug("matchOne", e.length, t.length);
    for (var o = 0, a = 0, l = e.length, h = t.length; o < l && a < h; o++, a++) {
      this.debug("matchOne loop");
      var c = t[a], p = e[o];
      if (this.debug(t, c, p), c === !1)
        return !1;
      if (c === A) {
        this.debug("GLOBSTAR", [t, c, p]);
        var f = o, u = a + 1;
        if (u === h) {
          for (this.debug("** at the end"); o < l; o++)
            if (e[o] === "." || e[o] === ".." || !r.dot && e[o].charAt(0) === ".")
              return !1;
          return !0;
        }
        for (; f < l; ) {
          var g = e[f];
          if (this.debug(`
globstar while`, e, f, t, u, g), this.matchOne(e.slice(f), t.slice(u), n))
            return this.debug("globstar found match!", f, l, g), !0;
          if (g === "." || g === ".." || !r.dot && g.charAt(0) === ".") {
            this.debug("dot detected!", e, f, t, u);
            break;
          }
          this.debug("globstar swallow a segment, and continue"), f++;
        }
        return !!(n && (this.debug(`
>>> no match, partial?`, e, f, t, u), f === l));
      }
      let d;
      if (typeof c == "string" ? (d = p === c, this.debug("string match", c, p, d)) : (d = c.test(p), this.debug("pattern match", c, p, d)), !d)
        return !1;
    }
    if (o === l && a === h)
      return !0;
    if (o === l)
      return n;
    if (a === h)
      return o === l - 1 && e[o] === "";
    throw new Error("wtf?");
  }
  braceExpand() {
    return ie(this.pattern, this.options);
  }
  parse(e) {
    C(e);
    const t = this.options;
    if (e === "**")
      return A;
    if (e === "")
      return "";
    let n, r = null;
    (n = e.match(lt)) ? r = t.dot ? ut : ht : (n = e.match(Qe)) ? r = (t.nocase ? t.dot ? nt : st : t.dot ? tt : et)(n[1]) : (n = e.match(ft)) ? r = (t.nocase ? t.dot ? dt : pt : t.dot ? gt : mt)(n) : (n = e.match(rt)) ? r = t.dot ? ot : it : (n = e.match(ct)) && (r = at);
    const i = y.fromGlob(e, this.options).toMMPattern();
    return r && typeof i == "object" && Reflect.defineProperty(i, "test", { value: r }), i;
  }
  makeRe() {
    if (this.regexp || this.regexp === !1)
      return this.regexp;
    const e = this.set;
    if (!e.length)
      return this.regexp = !1, this.regexp;
    const t = this.options, n = t.noglobstar ? yt : t.dot ? xt : St, r = new Set(t.nocase ? ["i"] : []);
    let i = e.map((l) => {
      const h = l.map((c) => {
        if (c instanceof RegExp)
          for (const p of c.flags.split(""))
            r.add(p);
        return typeof c == "string" ? vt(c) : c === A ? A : c._src;
      });
      return h.forEach((c, p) => {
        const f = h[p + 1], u = h[p - 1];
        c !== A || u === A || (u === void 0 ? f !== void 0 && f !== A ? h[p + 1] = "(?:\\/|" + n + "\\/)?" + f : h[p] = n : f === void 0 ? h[p - 1] = u + "(?:\\/|" + n + ")?" : f !== A && (h[p - 1] = u + "(?:\\/|\\/" + n + "\\/)" + f, h[p + 1] = A));
      }), h.filter((c) => c !== A).join("/");
    }).join("|");
    const [o, a] = e.length > 1 ? ["(?:", ")"] : ["", ""];
    i = "^" + o + i + a + "$", this.negate && (i = "^(?!" + i + ").+$");
    try {
      this.regexp = new RegExp(i, [...r].join(""));
    } catch {
      this.regexp = !1;
    }
    return this.regexp;
  }
  slashSplit(e) {
    return this.preserveMultipleSlashes ? e.split("/") : this.isWindows && /^\/\/[^\/]+/.test(e) ? ["", ...e.split(/\/+/)] : e.split(/\/+/);
  }
  match(e, t = this.partial) {
    if (this.debug("match", e, this.pattern), this.comment)
      return !1;
    if (this.empty)
      return e === "";
    if (e === "/" && t)
      return !0;
    const n = this.options;
    this.isWindows && (e = e.split("\\").join("/"));
    const r = this.slashSplit(e);
    this.debug(this.pattern, "split", r);
    const i = this.set;
    this.debug(this.pattern, "set", i);
    let o = r[r.length - 1];
    if (!o)
      for (let a = r.length - 2; !o && a >= 0; a--)
        o = r[a];
    for (let a = 0; a < i.length; a++) {
      const l = i[a];
      let h = r;
      if (n.matchBase && l.length === 1 && (h = [o]), this.matchOne(h, l, t))
        return n.flipNegate ? !0 : !this.negate;
    }
    return n.flipNegate ? !1 : this.negate;
  }
  static defaults(e) {
    return E.defaults(e).Minimatch;
  }
}
E.AST = y;
E.Minimatch = D;
E.escape = Ke;
E.unescape = P;
function Ut() {
  if (!("storage" in navigator) || !("getDirectory" in navigator.storage))
    throw new he();
}
async function $t(s, e, t) {
  return typeof navigator < "u" && navigator.locks?.request ? navigator.locks.request(`opfs:${s.replace(/\/+/g, "/")}`, { mode: e }, t) : t();
}
function U(s) {
  return Array.isArray(s) ? s : (s.startsWith("~/") ? s.slice(2) : s).split("/").filter(Boolean);
}
function oe(s) {
  return typeof s == "string" ? s ?? "/" : `/${s.join("/")}`;
}
function ce(s) {
  const e = U(s);
  return e[e.length - 1] || "";
}
function Wt(s) {
  const e = U(s);
  return e.pop(), oe(e);
}
function ae(s) {
  return !s || s === "/" ? "/" : s.startsWith("~/") ? `/${s.slice(2)}` : s.startsWith("/") ? s : `/${s}`;
}
function zt(s, e = !1) {
  return s = s.replace(/\/$/, ""), e && !s.includes("*") ? `${s}/**` : s;
}
function Bt(s, e) {
  return E(s, e, {
    dot: !0,
    matchBase: !0
  });
}
function _t(s, e) {
  if (!e || Array.isArray(e) && e.length === 0)
    return !1;
  const t = ae(s);
  return (Array.isArray(e) ? e : [e]).some((r) => E(t, r, { dot: !0 }));
}
function qt(s) {
  const e = ae(s), t = U(e), n = [];
  for (const r of t)
    if (!(r === "." || r === ""))
      if (r === "..") {
        if (n.length === 0)
          continue;
        n.pop();
      } else
        n.push(r);
  return oe(n);
}
function Gt(s) {
  const e = ce(s), t = e.lastIndexOf(".");
  return t <= 0 || t === e.length - 1 ? "" : e.slice(t);
}
function Ht(s, e = "utf-8") {
  return typeof s == "string" ? Ee(s, e) : s instanceof Uint8Array ? s : new Uint8Array(s);
}
async function Vt(s, e = "SHA-1", t = 50 * 1024 * 1024) {
  if (s instanceof File && (s = await s.arrayBuffer()), s.byteLength > t)
    throw new Error(`File size ${s.byteLength} bytes exceeds maximum allowed size ${t} bytes`);
  const n = new Uint8Array(s), r = await crypto.subtle.digest(e, n);
  return Array.from(new Uint8Array(r)).map((o) => o.toString(16).padStart(2, "0")).join("");
}
function Yt(s, e) {
  if (s.length !== e.length)
    return !1;
  for (let t = 0; t < s.length; t++)
    if (s[t] !== e[t])
      return !1;
  return !0;
}
async function Zt(s) {
  const e = await s.arrayBuffer();
  return new Uint8Array(e);
}
async function Jt(s, e, t = {}) {
  const n = ce(e);
  return $t(e, "exclusive", async () => {
    const r = t.recursive ?? !1, i = t.force ?? !1;
    try {
      await s.removeEntry(n, { recursive: r });
    } catch (o) {
      if (o.name === "NotFoundError") {
        if (!i)
          throw new Z("file", e, o);
      } else throw o.name === "InvalidModificationError" ? new z("clear", e, o) : o.name === "TypeMismatchError" && !r ? new F("file", "directory", e, o) : new z("remove", e, o);
    }
  });
}
function Xt(s, e, t, n) {
  if (!Number.isInteger(e) || !Number.isInteger(t))
    throw new b("argument", "Invalid offset or length");
  if (e < 0 || t < 0)
    throw new b("argument", "Negative offset or length not allowed");
  if (e + t > s)
    throw new b("overflow", "Operation would overflow buffer");
  if (n != null && (!Number.isInteger(n) || n < 0))
    throw new b("argument", "Invalid position");
}
function Kt(s, e, t) {
  try {
    e.flush(), e.close();
  } catch (n) {
    console.warn(`Warning: Failed to properly close file descriptor ${s} (${t}):`, n);
  }
}
function Qt(s, e, t) {
  if (s >= t)
    return { isEOF: !0, actualLength: 0 };
  const n = Math.min(e, t - s);
  return n <= 0 ? { isEOF: !0, actualLength: 0 } : { isEOF: !1, actualLength: n };
}
async function es(s, e) {
  try {
    return await s.createSyncAccessHandle();
  } catch (t) {
    throw me(t, { path: e, isDirectory: !1 });
  }
}
export {
  Ct as A,
  Vt as B,
  Yt as C,
  z as D,
  Z as E,
  pe as F,
  Zt as G,
  Jt as H,
  W as I,
  Xt as J,
  Kt as K,
  Qt as L,
  es as M,
  we as N,
  m as O,
  Tt as P,
  fe as S,
  Rt as T,
  b as V,
  Ae as W,
  he as a,
  ue as b,
  F as c,
  Ft as d,
  Ee as e,
  de as f,
  ge as g,
  Pt as h,
  Lt as i,
  It as j,
  Mt as k,
  Dt as l,
  me as m,
  Ut as n,
  oe as o,
  ce as p,
  Wt as q,
  ae as r,
  U as s,
  zt as t,
  Bt as u,
  _t as v,
  $t as w,
  qt as x,
  Gt as y,
  Ht as z
};
//# sourceMappingURL=helpers-BuGfPAg0.js.map
