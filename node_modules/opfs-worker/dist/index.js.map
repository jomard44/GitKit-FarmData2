{"version":3,"file":"index.js","sources":["../src/facade.ts","../src/index.ts"],"sourcesContent":["import { wrap } from 'comlink';\n\nimport { decodeBuffer, encodeString, isBinaryFileExtension } from './utils/encoder';\nimport WorkerCtor from './worker?worker&inline';\n\nimport type {\n    BinaryEncoding,\n    DirentData,\n    Encoding,\n    FileOpenOptions,\n    FileStat,\n    OPFSOptions,\n    PathLike,\n    RemoteOPFSWorker,\n    RenameOptions,\n    StringEncoding,\n    WatchOptions\n} from './types';\n\n/**\n * Utility function to convert a PathLike to a string path\n * If it's a URI, extracts the pathname; otherwise returns the string as-is\n */\nfunction normalizePath(path: PathLike): string {\n    if (path instanceof URL) {\n        return path.pathname;\n    }\n\n    return path;\n}\n\n/**\n * Facade class that provides a clean interface for communicating with the OPFS worker\n * while hiding Comlink implementation details.\n */\nexport class OPFSFileSystem {\n    #worker: RemoteOPFSWorker;\n    promises: OPFSFileSystem = this;\n\n    constructor(options?: OPFSOptions) {\n        this.#worker = wrap<RemoteOPFSWorker>(new WorkerCtor());\n\n        // Set up options if provided\n        if (options) {\n            // We can't pass a BroadcastChannel instance to the worker, so we need to convert it to a string first\n            if (options.broadcastChannel && options.broadcastChannel instanceof BroadcastChannel) {\n                options.broadcastChannel = options.broadcastChannel.name;\n            }\n\n            // Initialize options asynchronously\n            void this.setOptions(options);\n        }\n    }\n\n    /**\n     * Start watching a file or directory for changes\n     */\n    watch(path: PathLike, options?: WatchOptions): () => void {\n        const normalizedPath = normalizePath(path);\n\n        void this.#worker.watch(normalizedPath, options);\n\n        return () => this.unwatch(normalizedPath);\n    }\n\n    /**\n     * Stop watching a previously watched path\n     */\n    unwatch(path: PathLike) {\n        const normalizedPath = normalizePath(path);\n\n        void this.#worker.unwatch(normalizedPath);\n    }\n\n    /**\n     * Update configuration options\n     */\n    async setOptions(options: OPFSOptions) {\n        return this.#worker.setOptions(options);\n    }\n\n    /**\n     * Get a complete index of all files and directories in the file system\n     */\n    async index(): Promise<Map<string, FileStat>> {\n        return this.#worker.index();\n    }\n\n    /**\n     * Read a file from the file system\n     */\n    // Overload for explicit string encoding - returns string\n    async readFile(path: PathLike, encoding: StringEncoding): Promise<string>;\n    // Overload for explicit binary encoding - returns Uint8Array\n    async readFile(path: PathLike, encoding: BinaryEncoding): Promise<Uint8Array>;\n    // Overload for options object with string encoding - returns string\n    async readFile(path: PathLike, options: { encoding: StringEncoding }): Promise<string>;\n    // Overload for options object with binary encoding - returns Uint8Array\n    async readFile(path: PathLike, options: { encoding: BinaryEncoding }): Promise<Uint8Array>;\n    // Overload for no encoding (auto-detected) - returns string | Uint8Array based on file extension\n    async readFile(path: PathLike): Promise<string | Uint8Array>;\n    // Implementation\n    async readFile(\n        path: PathLike,\n        optionsOrEncoding?: Encoding | { encoding?: Encoding }\n    ): Promise<string | Uint8Array> {\n        const normalizedPath = normalizePath(path);\n\n        // Handle both options object and direct encoding parameter for backward compatibility\n        let encoding: Encoding | undefined;\n\n        if (typeof optionsOrEncoding === 'string') {\n            encoding = optionsOrEncoding;\n        }\n        else if (optionsOrEncoding && typeof optionsOrEncoding === 'object') {\n            encoding = optionsOrEncoding.encoding;\n        }\n\n        // Get binary data from worker\n        const buffer = await this.#worker.readFile(normalizedPath);\n\n        // If no encoding specified, auto-detect based on file extension\n        if (!encoding) {\n            encoding = isBinaryFileExtension(normalizedPath) ? 'binary' : 'utf-8';\n        }\n\n        // Return binary data or decode to string\n        return (encoding === 'binary') ? buffer : decodeBuffer(buffer, encoding);\n    }\n\n    /**\n     * Write data to a file\n     */\n    async writeFile(\n        path: PathLike,\n        data: string | Uint8Array | ArrayBuffer,\n        options?: { encoding?: Encoding } | Encoding\n    ): Promise<void> {\n        const normalizedPath = normalizePath(path);\n\n        let encoding: Encoding | undefined;\n\n        if (typeof options === 'string') {\n            encoding = options;\n        }\n        else if (options && typeof options === 'object') {\n            encoding = options.encoding;\n        }\n\n        // If no encoding specified, auto-detect based on file extension\n        if (!encoding) {\n            encoding = (typeof data !== 'string' || isBinaryFileExtension(normalizedPath)) ? 'binary' : 'utf-8';\n        }\n\n        // Convert data to Uint8Array\n        const buffer = typeof data === 'string'\n            ? encodeString(data, encoding)\n            : (data instanceof Uint8Array ? data : new Uint8Array(data));\n\n        return this.#worker.writeFile(normalizedPath, buffer);\n    }\n\n    /**\n     * Append data to a file\n     */\n    async appendFile(\n        path: PathLike,\n        data: string | Uint8Array | ArrayBuffer,\n        encoding?: Encoding\n    ): Promise<void> {\n        const normalizedPath = normalizePath(path);\n\n        // If no encoding specified, auto-detect based on file extension\n        if (!encoding) {\n            encoding = (typeof data !== 'string' || isBinaryFileExtension(normalizedPath)) ? 'binary' : 'utf-8';\n        }\n\n        // Convert data to Uint8Array\n        const buffer = typeof data === 'string'\n            ? encodeString(data, encoding)\n            : (data instanceof Uint8Array ? data : new Uint8Array(data));\n\n        return this.#worker.appendFile(normalizedPath, buffer);\n    }\n\n    /**\n     * Create a directory\n     */\n    async mkdir(path: PathLike, mode?: number | { recursive?: boolean }): Promise<void> {\n        const normalizedPath = normalizePath(path);\n\n        let options: { recursive?: boolean } | undefined;\n\n        // OPFS doesn't support file modes, so we ignore the mode parameter\n        if (typeof mode === 'number') {\n            options = { recursive: false };\n        }\n        else {\n            options = mode;\n        }\n\n        return this.#worker.mkdir(normalizedPath, options);\n    }\n\n    /**\n     * Get file or directory statistics\n     */\n    async stat(path: PathLike): Promise<FileStat> {\n        const normalizedPath = normalizePath(path);\n\n        return this.#worker.stat(normalizedPath);\n    }\n\n    /**\n     * Read a directory's contents\n     */\n    async readDir(path: PathLike): Promise<DirentData[]> {\n        const normalizedPath = normalizePath(path);\n\n        return this.#worker.readDir(normalizedPath);\n    }\n\n    /**\n     * Check if a file or directory exists\n     */\n    async exists(path: PathLike): Promise<boolean> {\n        const normalizedPath = normalizePath(path);\n\n        return this.#worker.exists(normalizedPath);\n    }\n\n    /**\n     * Clear all contents of a directory without removing the directory itself\n     */\n    async clear(path?: PathLike): Promise<void> {\n        const normalizedPath = path ? normalizePath(path) : undefined;\n\n        return this.#worker.clear(normalizedPath);\n    }\n\n    /**\n     * Remove files and directories\n     */\n    async remove(path: PathLike, options?: { recursive?: boolean; force?: boolean }): Promise<void> {\n        const normalizedPath = normalizePath(path);\n\n        return this.#worker.remove(normalizedPath, options);\n    }\n\n    /**\n     * Alias for remove() for NodeJS like API compatibility\n     */\n    async unlink(path: PathLike): Promise<void> {\n        return this.remove(path);\n    }\n\n    /**\n     * Alias for remove() for NodeJS like API compatibility\n     */\n    async rm(path: PathLike, options?: { recursive?: boolean; force?: boolean }): Promise<void> {\n        return this.remove(path, options);\n    }\n\n    /**\n     * Alias for remove() for NodeJS like API compatibility\n     */\n    async rmdir(path: PathLike): Promise<void> {\n        return this.remove(path);\n    }\n\n    /**\n     * Alias for readDir() for NodeJS like API compatibility\n     */\n    async readdir(path: PathLike, _options?: unknown): Promise<DirentData[]> {\n        return this.readDir(path);\n    }\n\n    /**\n     * Alias for stat() for NodeJS like API compatibility\n     */\n    async lstat(path: PathLike): Promise<FileStat> {\n        return this.stat(path);\n    }\n\n    /**\n     * Note: OPFS doesn't support file modes, so this is a no-op and exists only for compatibility with tools like isomorphic-git\n     */\n    async chmod(_path: PathLike, _mode: number): Promise<void> {\n        return Promise.resolve();\n    }\n\n    /**\n     * Resolve a path to an absolute path\n     */\n    async realpath(path: PathLike): Promise<string> {\n        const normalizedPath = normalizePath(path);\n\n        return this.#worker.realpath(normalizedPath);\n    }\n\n    /**\n     * Rename a file or directory\n     */\n    async rename(oldPath: PathLike, newPath: PathLike, options?: RenameOptions): Promise<void> {\n        const normalizedOldPath = normalizePath(oldPath);\n        const normalizedNewPath = normalizePath(newPath);\n\n        return this.#worker.rename(normalizedOldPath, normalizedNewPath, options);\n    }\n\n    /**\n     * Copy files and directories\n     */\n    async copy(source: PathLike, destination: PathLike, options?: { recursive?: boolean; overwrite?: boolean }): Promise<void> {\n        const normalizedSource = normalizePath(source);\n        const normalizedDestination = normalizePath(destination);\n\n        return this.#worker.copy(normalizedSource, normalizedDestination, options);\n    }\n\n    /**\n     * Open a file and return a file descriptor\n     */\n    async open(path: PathLike, options?: FileOpenOptions): Promise<number> {\n        const normalizedPath = normalizePath(path);\n\n        return this.#worker.open(normalizedPath, options);\n    }\n\n    /**\n     * Close a file descriptor\n     */\n    async close(fd: number): Promise<void> {\n        return this.#worker.close(fd);\n    }\n\n    /**\n     * Read data from a file descriptor\n     * \n     * This method requires special handling due to Comlink transfer requirements.\n     * The buffer is transferred to the worker and back, so the original buffer\n     * becomes unusable after the call.\n     */\n    async read(\n        fd: number,\n        buffer: Uint8Array,\n        offset: number,\n        length: number,\n        position?: number | null | undefined\n    ): Promise<{ bytesRead: number; buffer: Uint8Array }> {\n        const { bytesRead, buffer: transferred } = await this.#worker.read(\n            fd,\n            // Temp buffer to preserve the original buffer\n            new Uint8Array(length),\n            0,\n            length,\n            position\n        );\n\n        // Copy the data from the transferred buffer to the original buffer\n        if (bytesRead > 0) {\n            buffer.set(transferred.subarray(0, bytesRead), offset);\n        }\n\n        return { bytesRead, buffer };\n    }\n\n    /**\n     * Write data to a file descriptor\n     */\n    async write(\n        fd: number,\n        buffer: Uint8Array,\n        offset?: number,\n        length?: number,\n        position?: number | null | undefined,\n        emitEvent?: boolean\n    ): Promise<number> {\n        return this.#worker.write(fd, buffer, offset, length, position, emitEvent);\n    }\n\n    /**\n     * Get file status information by file descriptor\n     */\n    async fstat(fd: number): Promise<FileStat> {\n        return this.#worker.fstat(fd);\n    }\n\n    /**\n     * Truncate file to specified size\n     */\n    async ftruncate(fd: number, size?: number): Promise<void> {\n        return this.#worker.ftruncate(fd, size);\n    }\n\n    /**\n     * Synchronize file data to storage (fsync equivalent)\n     */\n    async fsync(fd: number): Promise<void> {\n        return this.#worker.fsync(fd);\n    }\n\n    /**\n     * Dispose of resources and clean up the file system instance\n     */\n    dispose() {\n        void this.#worker.dispose();\n    }\n\n    /**\n     * Synchronize the file system with external data\n     */\n    async createIndex(entries: [PathLike, string | Uint8Array | Blob][]): Promise<void> {\n        const normalizedEntries = entries.map(([path, data]) => [normalizePath(path), data] as [string, string | Uint8Array | Blob]);\n\n        return this.#worker.createIndex(normalizedEntries);\n    }\n\n    /**\n     * Read a file as text with automatic encoding detection\n     */\n    async readText(path: PathLike, encoding: Encoding = 'utf-8'): Promise<string> {\n        const normalizedPath = normalizePath(path);\n        const buffer = await this.#worker.readFile(normalizedPath);\n\n        return decodeBuffer(buffer, encoding);\n    }\n\n    /**\n     * Write text to a file with specified encoding\n     */\n    async writeText(path: PathLike, text: string, encoding: Encoding = 'utf-8'): Promise<void> {\n        const normalizedPath = normalizePath(path);\n        const buffer = encodeString(text, encoding);\n\n        return this.#worker.writeFile(normalizedPath, buffer);\n    }\n\n    /**\n     * Append text to a file with specified encoding\n     */\n    async appendText(path: PathLike, text: string, encoding: Encoding = 'utf-8'): Promise<void> {\n        const normalizedPath = normalizePath(path);\n        const buffer = encodeString(text, encoding);\n\n        return this.#worker.appendFile(normalizedPath, buffer);\n    }\n}\n","import { OPFSFileSystem } from './facade';\n\nimport type { OPFSOptions } from './types';\n\nexport * from './types';\nexport * from './utils/errors';\nexport * from './utils/helpers';\nexport * from './utils/encoder';\nexport * from './facade';\n\n/**\n * Creates a new file system instance with inline worker\n * @param options - Optional configuration options\n * @returns Promise resolving to the file system interface\n */\nexport function createWorker(\n    options?: OPFSOptions\n): OPFSFileSystem {\n    return new OPFSFileSystem(options);\n}\n"],"names":["normalizePath","path","OPFSFileSystem","#worker","options","wrap","WorkerCtor","normalizedPath","optionsOrEncoding","encoding","buffer","isBinaryFileExtension","decodeBuffer","data","encodeString","mode","_options","_path","_mode","oldPath","newPath","normalizedOldPath","normalizedNewPath","source","destination","normalizedSource","normalizedDestination","fd","offset","length","position","bytesRead","transferred","emitEvent","size","entries","normalizedEntries","text","createWorker"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;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"}