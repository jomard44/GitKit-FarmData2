import { expose as k, transfer as p } from "comlink";
import { V as E, t as D, l as z, h as P, q as F, s as v, P as M, w as m, E as d, n as $, c as b, j as S, W as h, o as H, p as x, z as T, O as f, m as l, D as _, G as N, v as A, A as C, g as R, r as B, L as U, J as I, H as O, K as W, k as g, C as L } from "./helpers-CKOebsbw.js";
class j {
  /** Root directory handle for the file system */
  root;
  /** Map of watched paths and options */
  watchers = /* @__PURE__ */ new Map();
  /** Promise to prevent concurrent mount operations */
  mountingPromise = null;
  /** BroadcastChannel instance for sending events */
  broadcastChannel = null;
  /** Configuration options */
  options = {
    root: "/",
    namespace: "",
    maxFileSize: 50 * 1024 * 1024,
    hashAlgorithm: "etag",
    broadcastChannel: "opfs-worker"
  };
  /** Map of open file descriptors to their metadata */
  openFiles = /* @__PURE__ */ new Map();
  /** Next available file descriptor number */
  nextFd = 1;
  /**
   * Get file info by descriptor with validation
   * @private
   */
  _getFileDescriptor(t) {
    const e = this.openFiles.get(t);
    if (!e)
      throw new E("descriptor", `Invalid file descriptor: ${t}`);
    return e;
  }
  /**
   * Notify about internal changes to the file system
   * 
   * This method is called by internal operations to notify clients about
   * changes, even when no specific paths are being watched.
   * 
   * @param path - The path that was changed
   * @param type - The type of change (create, change, delete)
   */
  async notifyChange(t) {
    if (!this.options.broadcastChannel)
      return;
    const e = t.path;
    if (![...this.watchers.values()].some((r) => D(e, r.pattern) && r.include.some((s) => s && D(e, s)) && !r.exclude.some((s) => s && D(e, s))))
      return;
    let i;
    if (this.options.hashAlgorithm)
      try {
        i = (await this.stat(e)).hash;
      } catch {
      }
    try {
      this.broadcastChannel || (this.broadcastChannel = new BroadcastChannel(this.options.broadcastChannel));
      const r = {
        namespace: this.options.namespace,
        timestamp: (/* @__PURE__ */ new Date()).toISOString(),
        ...t,
        ...i && { hash: i }
      };
      this.broadcastChannel.postMessage(r);
    } catch (r) {
      console.warn("Failed to send event via BroadcastChannel:", r);
    }
  }
  /**
   * Creates a new OPFSFileSystem instance
   * 
   * @param options - Optional configuration options
   * @param options.root - Root path for the file system (default: '/')
   * @param options.watchInterval - Polling interval in milliseconds for file watching
   * @param options.hashAlgorithm - Hash algorithm for file hashing
   * @param options.maxFileSize - Maximum file size for hashing in bytes (default: 50MB)
   * @throws {OPFSError} If OPFS is not supported in the current browser
   */
  constructor(t) {
    z(), t && this.setOptions(t);
  }
  /**
   * Initialize the file system within a given directory
   * 
   * This method sets up the root directory for all subsequent operations.
   * If no root is specified, it will use the OPFS root directory.
   * 
   * @param root - The root path for the file system (default: '/')
   * @returns Promise that resolves to true if initialization was successful
   * @throws {OPFSError} If initialization fails
   * 
   * @example
   * ```typescript
   * const fs = new OPFSFileSystem();
   * 
   * // Use OPFS root (default)
   * await fs.mount();
   * 
   * // Use custom directory
   * await fs.mount('/my-app');
   * ```
   */
  async mount() {
    const t = this.options.root;
    return this.mountingPromise && await this.mountingPromise, this.mountingPromise = new Promise(async (e, a) => {
      try {
        const i = await navigator.storage.getDirectory();
        this.root = t === "/" ? i : await this.getDirectoryHandle(t, !0, i), e(!0);
      } catch (i) {
        a(new P(t, i));
      } finally {
        this.mountingPromise = null;
      }
    }), this.mountingPromise;
  }
  /**
   * Update configuration options
   * 
   * @param options - Configuration options to update
   * @param options.root - Root path for the file system
   * @param options.watchInterval - Polling interval in milliseconds for file watching
   * @param options.hashAlgorithm - Hash algorithm for file hashing
   * @param options.maxFileSize - Maximum file size for hashing in bytes
   * @param options.broadcastChannel - Custom name for the broadcast channel
   */
  async setOptions(t) {
    t.hashAlgorithm !== void 0 && (this.options.hashAlgorithm = t.hashAlgorithm), t.maxFileSize !== void 0 && (this.options.maxFileSize = t.maxFileSize), t.broadcastChannel !== void 0 && (this.broadcastChannel && this.options.broadcastChannel !== t.broadcastChannel && (this.broadcastChannel.close(), this.broadcastChannel = null), this.options.broadcastChannel = t.broadcastChannel), t.namespace && (this.options.namespace = t.namespace), t.root !== void 0 && (this.options.root = F(t.root), this.options.namespace || (this.options.namespace = `opfs-worker:${this.options.root}`), await this.mount());
  }
  /**
   * Get a directory handle from a path
   * 
   * Navigates through the directory structure to find or create a directory
   * at the specified path.
   * 
   * @param path - The path to the directory (string or array of segments)
   * @param create - Whether to create the directory if it doesn't exist (default: false)
   * @param from - The directory to start from (default: root directory)
   * @returns Promise that resolves to the directory handle
   * @throws {OPFSError} If the directory cannot be accessed or created
   * 
   * @example
   * ```typescript
   * const docsDir = await fs.getDirectoryHandle('/users/john/documents', true);
   * const docsDir2 = await fs.getDirectoryHandle(['users', 'john', 'documents'], true);
   * ```
   */
  async getDirectoryHandle(t, e = !1, a = this.root) {
    const i = Array.isArray(t) ? t : v(t);
    let r = a;
    for (const s of i)
      r = await r.getDirectoryHandle(s, { create: e });
    return r;
  }
  /**
   * Get a file handle from a path
   * 
   * Navigates to the parent directory and retrieves or creates a file handle
   * for the specified file path.
   * 
   * @param path - The path to the file (string or array of segments)
   * @param create - Whether to create the file if it doesn't exist (default: false)
   * @param _from - The directory to start from (default: root directory)
   * @returns Promise that resolves to the file handle
   * @throws {PathError} If the path is empty
   * @throws {OPFSError} If the file cannot be accessed or created
   * 
   * @example
   * ```typescript
   * const fileHandle = await fs.getFileHandle('/config/settings.json', true);
   * const fileHandle2 = await fs.getFileHandle(['config', 'settings.json'], true);
   * ```
   */
  async getFileHandle(t, e = !1, a = this.root) {
    const i = v(t);
    if (i.length === 0)
      throw new M("Path must not be empty", Array.isArray(t) ? t.join("/") : t);
    const r = i.pop();
    return (await this.getDirectoryHandle(i, e, a)).getFileHandle(r, { create: e });
  }
  /**
   * Get a complete index of all files and directories in the file system
   * 
   * This method recursively traverses the entire file system and returns
   * a Map containing FileStat objects for every file and directory.
   * 
   * @returns Promise that resolves to a Map of paths to FileStat objects
   * @throws {OPFSError} If the file system is not mounted
   * 
   * @example
   * ```typescript
   * const index = await fs.index();
   * const fileStats = index.get('/data/config.json');
   * if (fileStats) {
   *   console.log(`File size: ${fileStats.size} bytes`);
   *   if (fileStats.hash) console.log(`Hash: ${fileStats.hash}`);
   * }
   * ```
   */
  async index() {
    const t = /* @__PURE__ */ new Map(), e = async (a) => {
      const i = await this.readDir(a);
      for (const r of i) {
        const s = `${a === "/" ? "" : a}/${r.name}`;
        try {
          const n = await this.stat(s);
          t.set(s, n), n.isDirectory && await e(s);
        } catch (n) {
          console.warn(`Skipping broken entry: ${s}`, n);
        }
      }
    };
    return t.set("/", {
      kind: "directory",
      size: 0,
      mtime: (/* @__PURE__ */ new Date(0)).toISOString(),
      ctime: (/* @__PURE__ */ new Date(0)).toISOString(),
      isFile: !1,
      isDirectory: !0
    }), await e("/"), t;
  }
  /**
   * Read a file from the file system
   * 
   * Reads the contents of a file and returns it as binary data.
   * 
   * @param path - The path to the file to read
   * @returns Promise that resolves to the file contents as Uint8Array
   * @throws {FileNotFoundError} If the file does not exist
   * @throws {OPFSError} If reading the file fails
   * 
   * @example
   * ```typescript
   * // Read as binary data
   * const content = await fs.readFile('/config/settings.json');
   * 
   * // Read binary file
   * const binaryData = await fs.readFile('/images/logo.png');
   * ```
   */
  async readFile(t) {
    await this.mount();
    try {
      return await m(t, "shared", async () => {
        const e = await this.open(t);
        try {
          const { size: a } = await this.fstat(e), i = new Uint8Array(a);
          return a > 0 && await this.read(e, i, 0, a, 0), p(i, [i.buffer]);
        } finally {
          await this.close(e);
        }
      });
    } catch (e) {
      throw new d("file", t, e);
    }
  }
  /**
   * Write data to a file
   * 
   * Creates or overwrites a file with the specified binary data. If the file already
   * exists, it will be truncated before writing.
   * 
   * @param path - The path to the file to write
   * @param data - The binary data to write to the file (Uint8Array or ArrayBuffer)
   * @returns Promise that resolves when the write operation is complete
   * @throws {OPFSError} If writing the file fails
   * 
   * @example
   * ```typescript
   * // Write binary data
   * const binaryData = new Uint8Array([1, 2, 3, 4, 5]);
   * await fs.writeFile('/data/binary.dat', binaryData);
   * 
   * // Write from ArrayBuffer
   * const arrayBuffer = new ArrayBuffer(10);
   * await fs.writeFile('/data/buffer.dat', arrayBuffer);
   * ```
   */
  async writeFile(t, e) {
    await this.mount();
    const a = e instanceof Uint8Array ? e : new Uint8Array(e);
    await m(t, "exclusive", async () => {
      const i = await this.exists(t), r = await this.open(t, { create: !0, truncate: !0 });
      try {
        await this.write(r, a, 0, a.length, null, !1), await this.fsync(r);
      } finally {
        await this.close(r);
      }
      await this.notifyChange({ path: t, type: i ? h.Changed : h.Added, isDirectory: !1 });
    });
  }
  /**
   * Append data to a file
   * 
   * Adds binary data to the end of an existing file. If the file doesn't exist,
   * it will be created.
   * 
   * @param path - The path to the file to append to
   * @param data - The binary data to append to the file (Uint8Array or ArrayBuffer)
   * @returns Promise that resolves when the append operation is complete
   * @throws {OPFSError} If appending to the file fails
   * 
   * @example
   * ```typescript
   * // Append binary data
   * const additionalData = new Uint8Array([6, 7, 8]);
   * await fs.appendFile('/data/binary.dat', additionalData);
   * 
   * // Append from ArrayBuffer
   * const arrayBuffer = new ArrayBuffer(5);
   * await fs.appendFile('/data/buffer.dat', arrayBuffer);
   * ```
   */
  async appendFile(t, e) {
    await this.mount();
    const a = e instanceof Uint8Array ? e : new Uint8Array(e);
    await m(t, "exclusive", async () => {
      const i = await this.open(t, { create: !0 });
      try {
        const { size: r } = await this.fstat(i);
        await this.write(i, a, 0, a.length, r, !1), await this.fsync(i);
      } finally {
        await this.close(i);
      }
      await this.notifyChange({ path: t, type: h.Changed, isDirectory: !1 });
    });
  }
  /**
   * Create a directory
   * 
   * Creates a new directory at the specified path. If the recursive option
   * is enabled, parent directories will be created as needed.
   * 
   * @param path - The path where the directory should be created
   * @param options - Options for directory creation
   * @param options.recursive - Whether to create parent directories if they don't exist (default: false)
   * @returns Promise that resolves when the directory is created
   * @throws {OPFSError} If the directory cannot be created
   * 
   * @example
   * ```typescript
   * // Create a single directory
   * await fs.mkdir('/users/john');
   * 
   * // Create nested directories
   * await fs.mkdir('/users/john/documents/projects', { recursive: true });
   * ```
   */
  async mkdir(t, e) {
    await this.mount();
    const a = e?.recursive ?? !1, i = v(t);
    let r = this.root;
    for (let s = 0; s < i.length; s++) {
      const n = i[s];
      try {
        r = await r.getDirectoryHandle(n, { create: a || s === i.length - 1 });
      } catch (o) {
        throw o.name === "NotFoundError" ? new d("directory", $(i.slice(0, s + 1)), o) : o.name === "TypeMismatchError" ? new b("file", n, o) : new S("create directory", n, o);
      }
    }
    await this.notifyChange({ path: t, type: h.Added, isDirectory: !0 });
  }
  /**
   * Get file or directory statistics
   * 
   * Returns detailed information about a file or directory, including
   * size, modification time, and optionally a hash of the file content.
   * 
   * @param path - The path to the file or directory
   * @returns Promise that resolves to FileStat object
   * @throws {OPFSError} If the path does not exist or cannot be accessed
   * 
   * @example
   * ```typescript
   * const stats = await fs.stat('/data/config.json');
   * console.log(`File size: ${stats.size} bytes`);
   * console.log(`Last modified: ${stats.mtime}`);
   * 
   * // If hashing is enabled, hash will be included
   * if (stats.hash) {
   *   console.log(`Hash: ${stats.hash}`);
   * }
   * ```
   */
  async stat(t) {
    if (await this.mount(), t === "/")
      return {
        kind: "directory",
        size: 0,
        mtime: (/* @__PURE__ */ new Date(0)).toISOString(),
        ctime: (/* @__PURE__ */ new Date(0)).toISOString(),
        isFile: !1,
        isDirectory: !0
      };
    const e = H(t);
    let a;
    try {
      a = await this.getDirectoryHandle(x(t), !1);
      const i = this.options.hashAlgorithm, s = await (await a.getFileHandle(e, { create: !1 })).getFile(), n = {
        kind: "file",
        size: s.size,
        mtime: new Date(s.lastModified).toISOString(),
        ctime: new Date(s.lastModified).toISOString(),
        isFile: !0,
        isDirectory: !1
      };
      if (i === "etag")
        n.hash = `${s.lastModified.toString(36)}-${s.size.toString(36)}`;
      else if (typeof i == "string")
        try {
          const o = await T(s, i, this.options.maxFileSize);
          n.hash = o;
        } catch (o) {
          console.warn(`Failed to calculate hash for ${t}:`, o);
        }
      return n;
    } catch (i) {
      if (i.name === "NotFoundError")
        throw new d("file", t, i);
      if (i.name !== "TypeMismatchError")
        throw new S("stat", t, i);
    }
    try {
      return await a.getDirectoryHandle(e, { create: !1 }), {
        kind: "directory",
        size: 0,
        mtime: (/* @__PURE__ */ new Date(0)).toISOString(),
        ctime: (/* @__PURE__ */ new Date(0)).toISOString(),
        isFile: !1,
        isDirectory: !0
      };
    } catch (i) {
      throw new S("stat", t, i);
    }
  }
  /**
   * Read a directory's contents
   * 
   * Lists all files and subdirectories within the specified directory.
   * 
   * @param path - The path to the directory to read
   * @returns Promise that resolves to an array of detailed file/directory information
   * @throws {OPFSError} If the directory does not exist or cannot be accessed
   * 
   * @example
   * ```typescript
   * // Get detailed information about files and directories
   * const detailed = await fs.readDir('/users/john/documents');
   * detailed.forEach(item => {
   *   console.log(`${item.name} - ${item.isFile ? 'file' : 'directory'}`);
   * });
   * ```
   */
  async readDir(t) {
    await this.mount();
    const e = await this.getDirectoryHandle(t, !1), a = [];
    for await (const [i, r] of e.entries()) {
      const s = r.kind === "file";
      a.push({
        name: i,
        kind: r.kind,
        isFile: s,
        isDirectory: !s
      });
    }
    return a;
  }
  /**
   * Check if a file or directory exists
   * 
   * Verifies if a file or directory exists at the specified path.
   * 
   * @param path - The path to check
   * @returns Promise that resolves to true if the file or directory exists, false otherwise  
   * 
   * @example
   * ```typescript
   * const exists = await fs.exists('/config/settings.json');
   * console.log(`File exists: ${exists}`);
   * ```
   */
  async exists(t) {
    if (await this.mount(), t === "/")
      return !0;
    const e = H(t);
    let a = null;
    try {
      a = await this.getDirectoryHandle(x(t), !1);
    } catch (i) {
      if (a = null, i.name !== "NotFoundError" && i.name !== "TypeMismatchError")
        throw i;
    }
    if (!a || !e)
      return !1;
    try {
      return await a.getFileHandle(e, { create: !1 }), !0;
    } catch (i) {
      if (i.name !== "NotFoundError" && i.name !== "TypeMismatchError")
        throw i;
      try {
        return await a.getDirectoryHandle(e, { create: !1 }), !0;
      } catch (r) {
        if (r.name !== "NotFoundError" && r.name !== "TypeMismatchError")
          throw r;
        return !1;
      }
    }
  }
  /**
   * Clear all contents of a directory without removing the directory itself
   * 
   * Removes all files and subdirectories within the specified directory,
   * but keeps the directory itself.
   * 
   * @param path - The path to the directory to clear (default: '/')
   * @returns Promise that resolves when all contents are removed
   * @throws {OPFSError} If the operation fails
   * 
   * @example
   * ```typescript
   * // Clear root directory contents
   * await fs.clear('/');
   * 
   * // Clear specific directory contents
   * await fs.clear('/data');
   * ```
   */
  async clear(t = "/") {
    await this.mount();
    try {
      const e = await this.readDir(t);
      for (const a of e) {
        const i = `${t === "/" ? "" : t}/${a.name}`;
        await this.remove(i, { recursive: !0 });
      }
      await this.notifyChange({ path: t, type: h.Changed, isDirectory: !0 });
    } catch (e) {
      throw e instanceof f ? e : l(e, { path: t, isDirectory: !0 });
    }
  }
  /**
   * Remove files and directories
   * 
   * Removes files and directories. Similar to Node.js fs.rm().
   * 
   * @param path - The path to remove
   * @param options - Options for removal
   * @param options.recursive - Whether to remove directories and their contents recursively (default: false)
   * @param options.force - Whether to ignore errors if the path doesn't exist (default: false)
   * @returns Promise that resolves when the removal is complete
   * @throws {OPFSError} If the removal fails
   * 
   * @example
   * ```typescript
   * // Remove a file
   * await fs.rm('/path/to/file.txt');
   * 
   * // Remove a directory and all its contents
   * await fs.rm('/path/to/directory', { recursive: true });
   * 
   * // Remove with force (ignore if doesn't exist)
   * await fs.rm('/maybe/exists', { force: true });
   * ```
   */
  async remove(t, e) {
    if (await this.mount(), t === "/")
      throw new _("EROOT", t);
    const { recursive: a = !1, force: i = !1 } = e || {}, r = await this.getDirectoryHandle(x(t), !1), s = await this.stat(t);
    await N(r, t, { recursive: a, force: i }), await this.notifyChange({ path: t, type: h.Removed, isDirectory: s.isDirectory });
  }
  /**
   * Resolve a path to an absolute path
   * 
   * Resolves relative paths and normalizes path segments (like '..' and '.').
   * Similar to Node.js fs.realpath() but without symlink resolution since OPFS doesn't support symlinks.
   * 
   * @param path - The path to resolve
   * @returns Promise that resolves to the absolute normalized path
   * @throws {FileNotFoundError} If the path does not exist
   * @throws {OPFSError} If path resolution fails
   * 
   * @example
   * ```typescript
   * // Resolve relative path
   * const absolute = await fs.realpath('./config/../data/file.txt');
   * console.log(absolute); // '/data/file.txt'
   * ```
   */
  async realpath(t) {
    await this.mount();
    try {
      const e = A(t);
      if (!await this.exists(e))
        throw new d("file", e);
      return e;
    } catch (e) {
      throw e instanceof f ? e : l(e, { path: t });
    }
  }
  /**
   * Rename a file or directory
   * 
   * Changes the name of a file or directory. If the target path already exists,
   * it will be replaced only if overwrite option is enabled.
   * 
   * @param oldPath - The current path of the file or directory
   * @param newPath - The new path for the file or directory
   * @param options - Options for renaming
   * @param options.overwrite - Whether to overwrite existing files (default: false)
   * @returns Promise that resolves when the rename operation is complete
   * @throws {OPFSError} If the rename operation fails
   * 
   * @example
   * ```typescript
   * // Basic rename (fails if target exists)
   * await fs.rename('/old/path/file.txt', '/new/path/renamed.txt');
   * 
   * // Rename with overwrite
   * await fs.rename('/old/path/file.txt', '/new/path/renamed.txt', { overwrite: true });
   * ```
   */
  async rename(t, e, a) {
    await this.mount();
    try {
      const i = a?.overwrite ?? !1, r = await this.stat(t);
      if (await this.exists(e) && !i)
        throw new C(e);
      await this.copy(t, e, { recursive: !0, overwrite: i }), await this.remove(t, { recursive: !0 }), await this.notifyChange({ path: t, type: h.Removed, isDirectory: r.isDirectory }), await this.notifyChange({ path: e, type: h.Added, isDirectory: r.isDirectory });
    } catch (i) {
      throw i instanceof f ? i : l(i, { path: t });
    }
  }
  /**
   * Copy files and directories
   * 
   * Copies files and directories. Similar to Node.js fs.cp().
   * 
   * @param source - The source path to copy from
   * @param destination - The destination path to copy to
   * @param options - Options for copying
   * @param options.recursive - Whether to copy directories recursively (default: false)
   * @param options.overwrite - Whether to overwrite existing files (default: true)
   * @returns Promise that resolves when the copy operation is complete
   * @throws {OPFSError} If the copy operation fails
   * 
   * @example
   * ```typescript
   * // Copy a file
   * await fs.copy('/source/file.txt', '/dest/file.txt');
   * 
   * // Copy a directory and all its contents
   * await fs.copy('/source/dir', '/dest/dir', { recursive: true });
   * 
   * // Copy without overwriting existing files
   * await fs.copy('/source', '/dest', { recursive: true, overwrite: false });
   * ```
   */
  async copy(t, e, a) {
    await this.mount();
    try {
      const i = a?.recursive ?? !1, r = a?.overwrite ?? !0;
      if (!await this.exists(t))
        throw new d("source", t);
      if (await this.exists(e) && !r)
        throw new C(e);
      if ((await this.stat(t)).isFile) {
        const c = await this.readFile(t);
        await this.writeFile(e, c);
      } else {
        if (!i)
          throw new b("directory", t);
        await this.mkdir(e, { recursive: !0 });
        const c = await this.readDir(t);
        for (const w of c) {
          const y = `${t}/${w.name}`, u = `${e}/${w.name}`;
          await this.copy(y, u, { recursive: !0, overwrite: r });
        }
      }
    } catch (i) {
      throw i instanceof f ? i : l(i, { path: t });
    }
  }
  /**
   * Start watching a file or directory for changes
   * 
   * @param path - The path to watch (minimatch syntax allowed)
   * @param options - Watch options
   * @param options.recursive - Whether to watch recursively (default: true)
   * @param options.exclude - Glob pattern(s) to exclude (minimatch).
   * @returns Promise that resolves when watching starts
   * 
   * @example
   * ```typescript
   * // Watch entire directory tree recursively (default)
   * await fs.watch('/data');
   * 
   * // Watch only immediate children (shallow)
   * await fs.watch('/data', { recursive: false });
   * 
   * // Watch a single file
   * await fs.watch('/config.json', { recursive: false });
   * 
   * // Watch all json files but not in dist directory
   * await fs.watch('/**\/*.json', { recursive: false, exclude: ['dist/**'] });
   *
   * ```
   */
  async watch(t, e) {
    if (!this.options.broadcastChannel)
      throw new R("This instance is not configured to send events. Please specify options.broadcastChannel to enable watching.");
    const a = {
      pattern: B(t, e?.recursive ?? !0),
      include: Array.isArray(e?.include) ? e.include : [e?.include ?? "**"],
      exclude: Array.isArray(e?.exclude) ? e.exclude : [e?.exclude ?? ""]
    };
    this.watchers.set(t, a);
  }
  /**
   * Stop watching a previously watched path
   */
  unwatch(t) {
    this.watchers.delete(t);
  }
  /**
   * Open a file and return a file descriptor
   * 
   * @param path - The path to the file to open
   * @param options - Options for opening the file
   * @param options.create - Whether to create the file if it doesn't exist (default: false)
   * @param options.exclusive - If true and create is true, fails if file already exists (default: false)
   *                            Note: This is best-effort in OPFS, not fully atomic due to browser limitations
   * @param options.truncate - Whether to truncate the file to zero length (default: false)
   * @returns Promise that resolves to a file descriptor number
   * @throws {OPFSError} If opening the file fails
   * 
   * @example
   * ```typescript
   * // Open existing file for reading
   * const fd = await fs.open('/data/config.json');
   * 
   * // Create new file for writing
   * const fd = await fs.open('/data/new.txt', { create: true });
   * 
   * // Create file exclusively (fails if exists)
   * const fd = await fs.open('/data/unique.txt', { create: true, exclusive: true });
   * 
   * // Open and truncate file
   * const fd = await fs.open('/data/log.txt', { create: true, truncate: true });
   * ```
   */
  async open(t, e) {
    await this.mount();
    const { create: a = !1, exclusive: i = !1, truncate: r = !1 } = e || {}, s = F(A(t));
    try {
      return a && i ? await m(s, "exclusive", async () => {
        if (await this.exists(s))
          throw new C(s);
        return this._openFile(s, a, r);
      }) : await this._openFile(s, a, r);
    } catch (n) {
      throw n instanceof f ? n : l(n, { path: s, isDirectory: !1 });
    }
  }
  /**
   * Internal method to open a file (without locking)
   * @private
   */
  async _openFile(t, e, a) {
    const i = await this.getFileHandle(t, e);
    try {
      await i.getFile();
    } catch (n) {
      throw l(n, { path: t, isDirectory: !0 });
    }
    const r = await U(i, t);
    a && (r.truncate(0), r.flush());
    const s = this.nextFd++;
    return this.openFiles.set(s, {
      path: t,
      fileHandle: i,
      syncHandle: r,
      position: 0
    }), s;
  }
  /**
   * Close a file descriptor
   * 
   * @param fd - The file descriptor to close
   * @returns Promise that resolves when the file descriptor is closed
   * @throws {OPFSError} If the file descriptor is invalid or closing fails
   * 
   * @example
   * ```typescript
   * const fd = await fs.open('/data/file.txt');
   * // ... use the file descriptor ...
   * await fs.close(fd);
   * ```
   */
  async close(t) {
    const e = this._getFileDescriptor(t);
    I(t, e.syncHandle, e.path), this.openFiles.delete(t);
  }
  /**
   * Read data from a file descriptor
   * 
   * @param fd - The file descriptor to read from
   * @param buffer - The buffer to read data into
   * @param offset - The offset in the buffer to start writing at
   * @param length - The number of bytes to read
   * @param position - The position in the file to read from (null for current position)
   * @returns Promise that resolves to the number of bytes read and the modified buffer
   * @throws {OPFSError} If the file descriptor is invalid or reading fails
   * 
   * @note This method uses Comlink.transfer() to efficiently pass the buffer as a Transferable Object,
   *       ensuring zero-copy performance across Web Worker boundaries.
   * 
   * @example
   * ```typescript
   * const fd = await fs.open('/data/file.txt');
   * const buffer = new Uint8Array(1024);
   * const { bytesRead, buffer: modifiedBuffer } = await fs.read(fd, buffer, 0, 1024, null);
   * console.log(`Read ${bytesRead} bytes`);
   * // Use modifiedBuffer which contains the actual data
   * await fs.close(fd);
   * ```
   */
  async read(t, e, a, i, r) {
    const s = this._getFileDescriptor(t);
    O(e.length, a, i, r);
    try {
      const n = r ?? s.position, o = s.syncHandle.getSize(), { isEOF: c, actualLength: w } = W(n, i, o);
      if (c)
        return p({ bytesRead: 0, buffer: e }, [e.buffer]);
      const y = e.subarray(a, a + w), u = s.syncHandle.read(y, { at: n });
      return r == null && (s.position = n + u), p({ bytesRead: u, buffer: e }, [e.buffer]);
    } catch (n) {
      throw g("read", t, s.path, n);
    }
  }
  /**
   * Write data to a file descriptor
   * 
   * @param fd - The file descriptor to write to
   * @param buffer - The buffer containing data to write
   * @param offset - The offset in the buffer to start reading from (default: 0)
   * @param length - The number of bytes to write (default: entire buffer)
   * @param position - The position in the file to write to (null/undefined for current position)
   * @param emitEvent - Whether to emit a change event (default: true)
   * @returns Promise that resolves to the number of bytes written
   * @throws {OPFSError} If the file descriptor is invalid or writing fails
   *
   * @example
   * ```typescript
   * const fd = await fs.open('/data/file.txt', { create: true });
   * const data = new TextEncoder().encode('Hello, World!');
   * const bytesWritten = await fs.write(fd, data, 0, data.length, null);
   * console.log(`Wrote ${bytesWritten} bytes`);
   * await fs.close(fd);
   * ```
   */
  async write(t, e, a = 0, i, r, s = !0) {
    const n = this._getFileDescriptor(t), o = i ?? e.length - a;
    O(e.length, a, o, r);
    try {
      const c = r ?? n.position, w = e.subarray(a, a + o), y = n.syncHandle.write(w, { at: c });
      return (r == null || r === n.position) && (n.position = c + y), s && await this.notifyChange({ path: n.path, type: h.Changed, isDirectory: !1 }), y;
    } catch (c) {
      throw g("write", t, n.path, c);
    }
  }
  /**
   * Get file status information by file descriptor
   * 
   * @param fd - The file descriptor
   * @returns Promise that resolves to FileStat object
   * @throws {OPFSError} If the file descriptor is invalid
   * 
   * @example
   * ```typescript
   * const fd = await fs.open('/data/file.txt');
   * const stats = await fs.fstat(fd);
   * console.log(`File size: ${stats.size} bytes`);
   * console.log(`Last modified: ${stats.mtime}`);
   * 
   * // If hashing is enabled, hash will be included
   * if (stats.hash) {
   *   console.log(`Hash: ${stats.hash}`);
   * }
   * ```
   */
  async fstat(t) {
    const e = this._getFileDescriptor(t);
    return this.stat(e.path);
  }
  /**
   * Truncate file to specified size
   * 
   * @param fd - The file descriptor
   * @param size - The new size of the file (default: 0)
   * @returns Promise that resolves when truncation is complete
   * @throws {OPFSError} If the file descriptor is invalid or truncation fails
   * 
   * @example
   * ```typescript
   * const fd = await fs.open('/data/file.txt', { create: true });
   * await fs.truncate(fd, 100); // Truncate to 100 bytes
   * ```
   */
  async ftruncate(t, e = 0) {
    const a = this._getFileDescriptor(t);
    if (e < 0 || !Number.isInteger(e))
      throw new E("argument", "Invalid size");
    try {
      a.syncHandle.truncate(e), a.syncHandle.flush(), a.position > e && (a.position = e), await this.notifyChange({ path: a.path, type: h.Changed, isDirectory: !1 });
    } catch (i) {
      throw g("truncate", t, a.path, i);
    }
  }
  /**
   * Synchronize file data to storage (fsync equivalent)
   * 
   * @param fd - The file descriptor
   * @returns Promise that resolves when synchronization is complete
   * @throws {OPFSError} If the file descriptor is invalid or sync fails
   * 
   * @example
   * ```typescript
   * const fd = await fs.open('/data/file.txt', { create: true });
   * await fs.write(fd, data);
   * await fs.fsync(fd); // Ensure data is written to storage
   * ```
   */
  async fsync(t) {
    const e = this._getFileDescriptor(t);
    try {
      e.syncHandle.flush();
    } catch (a) {
      throw g("sync", t, e.path, a);
    }
  }
  /**
   * Dispose of resources and clean up the file system instance
   * 
   * This method should be called when the file system instance is no longer needed
   * to properly clean up resources like the broadcast channel and watch timers.
   */
  dispose() {
    this.broadcastChannel && (this.broadcastChannel.close(), this.broadcastChannel = null), this.watchers.clear();
    for (const [t, e] of this.openFiles)
      I(t, e.syncHandle, e.path);
    this.openFiles.clear(), this.nextFd = 1;
  }
  /**
   * Synchronize the file system with external data
   * 
   * Syncs the file system with an array of entries containing paths and data.
   * This is useful for importing data from external sources or syncing with remote data.
   * 
   * @param entries - Array of [path, data] tuples to sync
   * @param options - Options for synchronization
   * @param options.cleanBefore - Whether to clear the file system before syncing (default: false)
   * @returns Promise that resolves when synchronization is complete
   * @throws {OPFSError} If the synchronization fails
   * 
   * @example
   * ```typescript
   * // Sync with external data
   * const entries: [string, string | Uint8Array | Blob][] = [
   *   ['/config.json', JSON.stringify({ theme: 'dark' })],
   *   ['/data/binary.dat', new Uint8Array([1, 2, 3, 4])],
   *   ['/upload.txt', new Blob(['file content'], { type: 'text/plain' })]
   * ];
   * 
   * // Sync without clearing existing files
   * await fs.sync(entries);
   * 
   * // Clean file system and then sync
   * await fs.sync(entries, { cleanBefore: true });
   * ```
   */
  async createIndex(t) {
    await this.mount();
    try {
      for (const [e, a] of t) {
        const i = F(e);
        let r;
        a instanceof Blob ? r = await L(a) : typeof a == "string" ? r = new TextEncoder().encode(a) : r = a, await this.writeFile(i, r);
      }
    } catch (e) {
      throw e instanceof f ? e : l(e);
    }
  }
}
typeof globalThis < "u" && globalThis.constructor.name === "DedicatedWorkerGlobalScope" && k(new j());
export {
  j as OPFSWorker
};
//# sourceMappingURL=raw.js.map
