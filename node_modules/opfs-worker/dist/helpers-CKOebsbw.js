const lt = {
  ENOENT: -2,
  // No such file or directory
  EISDIR: -21,
  // Is a directory
  ENOTDIR: -20,
  // Not a directory
  EACCES: -13,
  // Permission denied
  EEXIST: -17,
  // File exists
  ENOTEMPTY: -39,
  // Directory not empty
  EINVAL: -22,
  // Invalid argument
  EIO: -5,
  // I/O error
  ENOSPC: -28,
  // No space left on device
  EBUSY: -16,
  // Device or resource busy
  EINTR: -4,
  // Interrupted system call
  ENOTSUP: -95,
  // Operation not supported
  ERANGE: -34,
  // Result too large
  EBADF: -9,
  // Bad file descriptor
  EROOT: -1
  // Custom: Cannot remove root directory
};
class y extends Error {
  errno;
  syscall;
  path;
  constructor(t, e, n, r, i) {
    super(t, { cause: i }), this.name = e, this.errno = lt[e] || -1, this.path = n, this.syscall = r;
  }
}
class ht extends y {
  constructor(t) {
    super("OPFS is not supported in this browser", "ENOTSUP", void 0, void 0, t);
  }
}
class Te extends y {
  constructor(t, e, n) {
    super(t, "INVALID_PATH", e, "access", n);
  }
}
class Z extends y {
  constructor(t, e, n) {
    const r = {
      file: `File not found: ${e}`,
      directory: `Directory not found: ${e}`,
      source: `Source does not exist: ${e}`
    };
    super(r[t], "ENOENT", e, "access", n);
  }
}
class ut extends y {
  constructor(t, e, n) {
    super(`Permission denied for ${e} on: ${t}`, "EACCES", t, e, n);
  }
}
class ft extends y {
  constructor(t, e, n) {
    super(t, "ENOSPC", e, "write", n);
  }
}
class pt extends y {
  constructor(t, e) {
    super(`File is busy: ${t}`, "EBUSY", t, "open", e);
  }
}
class k extends y {
  constructor(t, e, n) {
    const r = t === "directory" ? `Is a directory: ${e}` : `Not a directory: ${e}`, i = t === "directory" ? "EISDIR" : "ENOTDIR";
    super(r, i, e, "access", n);
  }
}
class b extends y {
  constructor(t, e, n, r) {
    const i = {
      argument: "EINVAL",
      format: "INVALID_FORMAT",
      descriptor: "EBADF",
      overflow: "ERANGE"
    };
    super(e, i[t], n, "validate", r);
  }
}
class dt extends y {
  constructor(t, e) {
    super(`Operation aborted: ${t}`, "EINTR", t, "interrupt", e);
  }
}
class U extends y {
  constructor(t, e, n) {
    super(t, "EIO", e, "io", n);
  }
}
class gt extends y {
  constructor(t, e) {
    super(`Operation not supported: ${t}`, "ENOTSUP", t, "operation", e);
  }
}
class z extends y {
  constructor(t, e, n) {
    const r = {
      RM_FAILED: `Failed to remove entry: ${e}`,
      ENOTEMPTY: `Directory not empty: ${e}. Use recursive option to force removal.`,
      EROOT: "Cannot remove root directory"
    };
    super(r[t] || `Directory operation failed: ${e}`, t, e, "unlink", n);
  }
}
class Me extends y {
  constructor(t, e) {
    super("Failed to initialize OPFS", "INIT_FAILED", t, "init", e);
  }
}
class Re extends y {
  constructor(t, e, n) {
    super(`Failed to ${t}: ${e}`, `${t.toUpperCase()}_FAILED`, e, t, n);
  }
}
class Ce extends y {
  constructor(t, e) {
    super(`Destination already exists: ${t}`, "EEXIST", t, "open", e);
  }
}
function Pe(s, t, e, n) {
  const r = `${s.toUpperCase()}_FAILED`;
  return new y(`Failed to ${s} file descriptor: ${t}`, r, e, s, n);
}
function mt(s, t) {
  const e = t?.path, n = t?.isDirectory;
  switch (s.name) {
    case "InvalidStateError":
      return new pt(e || "unknown", s);
    case "QuotaExceededError":
      return new ft(`No space left on device: ${e || "unknown"}`, e, s);
    case "NotFoundError":
      return new Z("file", e, s);
    case "TypeMismatchError":
      return n !== void 0 ? n ? new k("directory", e || "unknown", s) : new k("file", e || "unknown", s) : new b("argument", `Type mismatch: ${e || "unknown"}`, e, s);
    case "NotAllowedError":
    case "SecurityError":
      return new ut(e, "unknown", s);
    case "InvalidModificationError":
      return new b("argument", `Invalid modification: ${e || "unknown"}`, e, s);
    case "AbortError":
      return new dt(e || "unknown", s);
    case "OperationError":
      return new U(`Operation failed: ${e || "unknown"}`, e, s);
    case "TypeError":
      return new gt(e || "unknown", s);
    default:
      return new U(`I/O error: ${e || "unknown"}`, e, s);
  }
}
const wt = [
  // Images
  ".jpg",
  ".jpeg",
  ".png",
  ".gif",
  ".bmp",
  ".webp",
  ".ico",
  ".tiff",
  ".tga",
  // Audio
  ".mp3",
  ".wav",
  ".ogg",
  ".flac",
  ".aac",
  ".wma",
  ".m4a",
  // Video
  ".mp4",
  ".avi",
  ".mov",
  ".wmv",
  ".flv",
  ".webm",
  ".mkv",
  ".m4v",
  // Documents
  ".pdf",
  ".doc",
  ".docx",
  ".xls",
  ".xlsx",
  ".ppt",
  ".pptx",
  // Archives
  ".zip",
  ".rar",
  ".7z",
  ".tar",
  ".gz",
  ".bz2",
  // Executables
  ".exe",
  ".dll",
  ".so",
  ".dylib",
  // Other binary formats
  ".dat",
  ".db",
  ".sqlite",
  ".bin",
  ".obj",
  ".fbx",
  ".3ds"
];
function Ie(s) {
  const t = s.lastIndexOf(".");
  if (t <= 0)
    return !0;
  const e = s.slice(t).toLowerCase();
  return wt.includes(e);
}
function yt(s, t = "utf-8") {
  switch (t) {
    case "utf8":
    case "utf-8":
      return new TextEncoder().encode(s);
    case "utf16le":
    case "utf-16le":
    case "ucs2":
    case "ucs-2":
      return Et(s);
    case "ascii":
      return Ot(s);
    case "latin1":
      return St(s);
    case "binary":
      return Uint8Array.from(s, (e) => e.charCodeAt(0));
    case "base64":
      return Uint8Array.from(atob(s), (e) => e.charCodeAt(0));
    case "hex":
      if (!/^[\da-f]+$/i.test(s) || s.length % 2 !== 0)
        throw new b("format", "Invalid hex string");
      return Uint8Array.from(s.match(/.{1,2}/g).map((e) => parseInt(e, 16)));
    default:
      return console.warn("Encoding not supported, falling back to UTF-8"), new TextEncoder().encode(s);
  }
}
function De(s, t = "utf-8") {
  switch (t) {
    case "utf8":
    case "utf-8":
      return new TextDecoder().decode(s);
    case "utf16le":
    case "utf-16le":
    case "ucs2":
    case "ucs-2":
      return xt(s);
    case "latin1":
      return String.fromCharCode(...s);
    case "ascii":
      return String.fromCharCode(...s.map((e) => e & 127));
    case "base64":
      return btoa(String.fromCharCode(...s));
    case "hex":
      return Array.from(s).map((e) => e.toString(16).padStart(2, "0")).join("");
    default:
      return console.warn("Unsupported encoding, falling back to UTF-8"), new TextDecoder().decode(s);
  }
}
function Et(s) {
  const t = new Uint8Array(s.length * 2);
  for (let e = 0; e < s.length; e++) {
    const n = s.charCodeAt(e);
    t[e * 2] = n & 255, t[e * 2 + 1] = n >> 8;
  }
  return t;
}
function xt(s) {
  s.length % 2 !== 0 && (console.warn("Invalid UTF-16LE buffer length, truncating last byte"), s = s.slice(0, s.length - 1));
  const t = new Uint16Array(s.buffer, s.byteOffset, s.byteLength / 2);
  return String.fromCharCode(...t);
}
function St(s) {
  const t = new Uint8Array(s.length);
  for (let e = 0; e < s.length; e++)
    t[e] = s.charCodeAt(e) & 255;
  return t;
}
function Ot(s) {
  const t = new Uint8Array(s.length);
  for (let e = 0; e < s.length; e++)
    t[e] = s.charCodeAt(e) & 127;
  return t;
}
var At = /* @__PURE__ */ ((s) => (s.Added = "added", s.Changed = "changed", s.Removed = "removed", s))(At || {});
const J = (s, t, e) => {
  const n = s instanceof RegExp ? B(s, e) : s, r = t instanceof RegExp ? B(t, e) : t, i = n !== null && r != null && Nt(n, r, e);
  return i && {
    start: i[0],
    end: i[1],
    pre: e.slice(0, i[0]),
    body: e.slice(i[0] + n.length, i[1]),
    post: e.slice(i[1] + r.length)
  };
}, B = (s, t) => {
  const e = t.match(s);
  return e ? e[0] : null;
}, Nt = (s, t, e) => {
  let n, r, i, o, a, l = e.indexOf(s), h = e.indexOf(t, l + 1), c = l;
  if (l >= 0 && h > 0) {
    if (s === t)
      return [l, h];
    for (n = [], i = e.length; c >= 0 && !a; ) {
      if (c === l)
        n.push(c), l = e.indexOf(s, c + 1);
      else if (n.length === 1) {
        const p = n.pop();
        p !== void 0 && (a = [p, h]);
      } else
        r = n.pop(), r !== void 0 && r < i && (i = r, o = h), h = e.indexOf(t, c + 1);
      c = l < h && l >= 0 ? l : h;
    }
    n.length && o !== void 0 && (a = [i, o]);
  }
  return a;
}, X = "\0SLASH" + Math.random() + "\0", K = "\0OPEN" + Math.random() + "\0", F = "\0CLOSE" + Math.random() + "\0", Q = "\0COMMA" + Math.random() + "\0", tt = "\0PERIOD" + Math.random() + "\0", bt = new RegExp(X, "g"), vt = new RegExp(K, "g"), $t = new RegExp(F, "g"), Tt = new RegExp(Q, "g"), Mt = new RegExp(tt, "g"), Rt = /\\\\/g, Ct = /\\{/g, Pt = /\\}/g, It = /\\,/g, Dt = /\\./g;
function L(s) {
  return isNaN(s) ? s.charCodeAt(0) : parseInt(s, 10);
}
function Lt(s) {
  return s.replace(Rt, X).replace(Ct, K).replace(Pt, F).replace(It, Q).replace(Dt, tt);
}
function kt(s) {
  return s.replace(bt, "\\").replace(vt, "{").replace($t, "}").replace(Tt, ",").replace(Mt, ".");
}
function et(s) {
  if (!s)
    return [""];
  const t = [], e = J("{", "}", s);
  if (!e)
    return s.split(",");
  const { pre: n, body: r, post: i } = e, o = n.split(",");
  o[o.length - 1] += "{" + r + "}";
  const a = et(i);
  return i.length && (o[o.length - 1] += a.shift(), o.push.apply(o, a)), t.push.apply(t, o), t;
}
function Ft(s) {
  return s ? (s.slice(0, 2) === "{}" && (s = "\\{\\}" + s.slice(2)), M(Lt(s), !0).map(kt)) : [];
}
function jt(s) {
  return "{" + s + "}";
}
function Wt(s) {
  return /^-?0\d/.test(s);
}
function Ut(s, t) {
  return s <= t;
}
function zt(s, t) {
  return s >= t;
}
function M(s, t) {
  const e = [], n = J("{", "}", s);
  if (!n)
    return [s];
  const r = n.pre, i = n.post.length ? M(n.post, !1) : [""];
  if (/\$$/.test(n.pre))
    for (let o = 0; o < i.length; o++) {
      const a = r + "{" + n.body + "}" + i[o];
      e.push(a);
    }
  else {
    const o = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(n.body), a = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(n.body), l = o || a, h = n.body.indexOf(",") >= 0;
    if (!l && !h)
      return n.post.match(/,(?!,).*\}/) ? (s = n.pre + "{" + n.body + F + n.post, M(s)) : [s];
    let c;
    if (l)
      c = n.body.split(/\.\./);
    else if (c = et(n.body), c.length === 1 && c[0] !== void 0 && (c = M(c[0], !1).map(jt), c.length === 1))
      return i.map((f) => n.pre + c[0] + f);
    let p;
    if (l && c[0] !== void 0 && c[1] !== void 0) {
      const f = L(c[0]), u = L(c[1]), g = Math.max(c[0].length, c[1].length);
      let d = c.length === 3 && c[2] !== void 0 ? Math.abs(L(c[2])) : 1, x = Ut;
      u < f && (d *= -1, x = zt);
      const v = c.some(Wt);
      p = [];
      for (let S = f; x(S, u); S += d) {
        let m;
        if (a)
          m = String.fromCharCode(S), m === "\\" && (m = "");
        else if (m = String(S), v) {
          const $ = g - m.length;
          if ($ > 0) {
            const C = new Array($ + 1).join("0");
            S < 0 ? m = "-" + C + m.slice(1) : m = C + m;
          }
        }
        p.push(m);
      }
    } else {
      p = [];
      for (let f = 0; f < c.length; f++)
        p.push.apply(p, M(c[f], !1));
    }
    for (let f = 0; f < p.length; f++)
      for (let u = 0; u < i.length; u++) {
        const g = r + p[f] + i[u];
        (!t || l || g) && e.push(g);
      }
  }
  return e;
}
const Bt = 1024 * 64, I = (s) => {
  if (typeof s != "string")
    throw new TypeError("invalid pattern");
  if (s.length > Bt)
    throw new TypeError("pattern is too long");
}, _t = {
  "[:alnum:]": ["\\p{L}\\p{Nl}\\p{Nd}", !0],
  "[:alpha:]": ["\\p{L}\\p{Nl}", !0],
  "[:ascii:]": ["\\x00-\\x7f", !1],
  "[:blank:]": ["\\p{Zs}\\t", !0],
  "[:cntrl:]": ["\\p{Cc}", !0],
  "[:digit:]": ["\\p{Nd}", !0],
  "[:graph:]": ["\\p{Z}\\p{C}", !0, !0],
  "[:lower:]": ["\\p{Ll}", !0],
  "[:print:]": ["\\p{C}", !0],
  "[:punct:]": ["\\p{P}", !0],
  "[:space:]": ["\\p{Z}\\t\\r\\n\\v\\f", !0],
  "[:upper:]": ["\\p{Lu}", !0],
  "[:word:]": ["\\p{L}\\p{Nl}\\p{Nd}\\p{Pc}", !0],
  "[:xdigit:]": ["A-Fa-f0-9", !1]
}, T = (s) => s.replace(/[[\]\\-]/g, "\\$&"), qt = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&"), _ = (s) => s.join(""), Gt = (s, t) => {
  const e = t;
  if (s.charAt(e) !== "[")
    throw new Error("not in a brace expression");
  const n = [], r = [];
  let i = e + 1, o = !1, a = !1, l = !1, h = !1, c = e, p = "";
  t: for (; i < s.length; ) {
    const d = s.charAt(i);
    if ((d === "!" || d === "^") && i === e + 1) {
      h = !0, i++;
      continue;
    }
    if (d === "]" && o && !l) {
      c = i + 1;
      break;
    }
    if (o = !0, d === "\\" && !l) {
      l = !0, i++;
      continue;
    }
    if (d === "[" && !l) {
      for (const [x, [N, v, S]] of Object.entries(_t))
        if (s.startsWith(x, i)) {
          if (p)
            return ["$.", !1, s.length - e, !0];
          i += x.length, S ? r.push(N) : n.push(N), a = a || v;
          continue t;
        }
    }
    if (l = !1, p) {
      d > p ? n.push(T(p) + "-" + T(d)) : d === p && n.push(T(d)), p = "", i++;
      continue;
    }
    if (s.startsWith("-]", i + 1)) {
      n.push(T(d + "-")), i += 2;
      continue;
    }
    if (s.startsWith("-", i + 1)) {
      p = d, i += 2;
      continue;
    }
    n.push(T(d)), i++;
  }
  if (c < i)
    return ["", !1, 0, !1];
  if (!n.length && !r.length)
    return ["$.", !1, s.length - e, !0];
  if (r.length === 0 && n.length === 1 && /^\\?.$/.test(n[0]) && !h) {
    const d = n[0].length === 2 ? n[0].slice(-1) : n[0];
    return [qt(d), !1, c - e, !1];
  }
  const f = "[" + (h ? "^" : "") + _(n) + "]", u = "[" + (h ? "" : "^") + _(r) + "]";
  return [n.length && r.length ? "(" + f + "|" + u + ")" : n.length ? f : u, a, c - e, !0];
}, R = (s, { windowsPathsNoEscape: t = !1 } = {}) => t ? s.replace(/\[([^\/\\])\]/g, "$1") : s.replace(/((?!\\).|^)\[([^\/\\])\]/g, "$1$2").replace(/\\([^\/])/g, "$1"), Ht = /* @__PURE__ */ new Set(["!", "?", "+", "*", "@"]), q = (s) => Ht.has(s), Vt = "(?!(?:^|/)\\.\\.?(?:$|/))", P = "(?!\\.)", Yt = /* @__PURE__ */ new Set(["[", "."]), Zt = /* @__PURE__ */ new Set(["..", "."]), Jt = new Set("().*{}+?[]^$\\!"), Xt = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&"), j = "[^/]", G = j + "*?", H = j + "+?";
class E {
  type;
  #s;
  #n;
  #i = !1;
  #t = [];
  #e;
  #o;
  #a;
  #c = !1;
  #r;
  #l;
  // set to true if it's an extglob with no children
  // (which really means one child of '')
  #u = !1;
  constructor(t, e, n = {}) {
    this.type = t, t && (this.#n = !0), this.#e = e, this.#s = this.#e ? this.#e.#s : this, this.#r = this.#s === this ? n : this.#s.#r, this.#a = this.#s === this ? [] : this.#s.#a, t === "!" && !this.#s.#c && this.#a.push(this), this.#o = this.#e ? this.#e.#t.length : 0;
  }
  get hasMagic() {
    if (this.#n !== void 0)
      return this.#n;
    for (const t of this.#t)
      if (typeof t != "string" && (t.type || t.hasMagic))
        return this.#n = !0;
    return this.#n;
  }
  // reconstructs the pattern
  toString() {
    return this.#l !== void 0 ? this.#l : this.type ? this.#l = this.type + "(" + this.#t.map((t) => String(t)).join("|") + ")" : this.#l = this.#t.map((t) => String(t)).join("");
  }
  #p() {
    if (this !== this.#s)
      throw new Error("should only call on root");
    if (this.#c)
      return this;
    this.toString(), this.#c = !0;
    let t;
    for (; t = this.#a.pop(); ) {
      if (t.type !== "!")
        continue;
      let e = t, n = e.#e;
      for (; n; ) {
        for (let r = e.#o + 1; !n.type && r < n.#t.length; r++)
          for (const i of t.#t) {
            if (typeof i == "string")
              throw new Error("string part in extglob AST??");
            i.copyIn(n.#t[r]);
          }
        e = n, n = e.#e;
      }
    }
    return this;
  }
  push(...t) {
    for (const e of t)
      if (e !== "") {
        if (typeof e != "string" && !(e instanceof E && e.#e === this))
          throw new Error("invalid part: " + e);
        this.#t.push(e);
      }
  }
  toJSON() {
    const t = this.type === null ? this.#t.slice().map((e) => typeof e == "string" ? e : e.toJSON()) : [this.type, ...this.#t.map((e) => e.toJSON())];
    return this.isStart() && !this.type && t.unshift([]), this.isEnd() && (this === this.#s || this.#s.#c && this.#e?.type === "!") && t.push({}), t;
  }
  isStart() {
    if (this.#s === this)
      return !0;
    if (!this.#e?.isStart())
      return !1;
    if (this.#o === 0)
      return !0;
    const t = this.#e;
    for (let e = 0; e < this.#o; e++) {
      const n = t.#t[e];
      if (!(n instanceof E && n.type === "!"))
        return !1;
    }
    return !0;
  }
  isEnd() {
    if (this.#s === this || this.#e?.type === "!")
      return !0;
    if (!this.#e?.isEnd())
      return !1;
    if (!this.type)
      return this.#e?.isEnd();
    const t = this.#e ? this.#e.#t.length : 0;
    return this.#o === t - 1;
  }
  copyIn(t) {
    typeof t == "string" ? this.push(t) : this.push(t.clone(this));
  }
  clone(t) {
    const e = new E(this.type, t);
    for (const n of this.#t)
      e.copyIn(n);
    return e;
  }
  static #h(t, e, n, r) {
    let i = !1, o = !1, a = -1, l = !1;
    if (e.type === null) {
      let u = n, g = "";
      for (; u < t.length; ) {
        const d = t.charAt(u++);
        if (i || d === "\\") {
          i = !i, g += d;
          continue;
        }
        if (o) {
          u === a + 1 ? (d === "^" || d === "!") && (l = !0) : d === "]" && !(u === a + 2 && l) && (o = !1), g += d;
          continue;
        } else if (d === "[") {
          o = !0, a = u, l = !1, g += d;
          continue;
        }
        if (!r.noext && q(d) && t.charAt(u) === "(") {
          e.push(g), g = "";
          const x = new E(d, e);
          u = E.#h(t, x, u, r), e.push(x);
          continue;
        }
        g += d;
      }
      return e.push(g), u;
    }
    let h = n + 1, c = new E(null, e);
    const p = [];
    let f = "";
    for (; h < t.length; ) {
      const u = t.charAt(h++);
      if (i || u === "\\") {
        i = !i, f += u;
        continue;
      }
      if (o) {
        h === a + 1 ? (u === "^" || u === "!") && (l = !0) : u === "]" && !(h === a + 2 && l) && (o = !1), f += u;
        continue;
      } else if (u === "[") {
        o = !0, a = h, l = !1, f += u;
        continue;
      }
      if (q(u) && t.charAt(h) === "(") {
        c.push(f), f = "";
        const g = new E(u, c);
        c.push(g), h = E.#h(t, g, h, r);
        continue;
      }
      if (u === "|") {
        c.push(f), f = "", p.push(c), c = new E(null, e);
        continue;
      }
      if (u === ")")
        return f === "" && e.#t.length === 0 && (e.#u = !0), c.push(f), f = "", e.push(...p, c), h;
      f += u;
    }
    return e.type = null, e.#n = void 0, e.#t = [t.substring(n - 1)], h;
  }
  static fromGlob(t, e = {}) {
    const n = new E(null, void 0, e);
    return E.#h(t, n, 0, e), n;
  }
  // returns the regular expression if there's magic, or the unescaped
  // string if not.
  toMMPattern() {
    if (this !== this.#s)
      return this.#s.toMMPattern();
    const t = this.toString(), [e, n, r, i] = this.toRegExpSource();
    if (!(r || this.#n || this.#r.nocase && !this.#r.nocaseMagicOnly && t.toUpperCase() !== t.toLowerCase()))
      return n;
    const a = (this.#r.nocase ? "i" : "") + (i ? "u" : "");
    return Object.assign(new RegExp(`^${e}$`, a), {
      _src: e,
      _glob: t
    });
  }
  get options() {
    return this.#r;
  }
  // returns the string match, the regexp source, whether there's magic
  // in the regexp (so a regular expression is required) and whether or
  // not the uflag is needed for the regular expression (for posix classes)
  // TODO: instead of injecting the start/end at this point, just return
  // the BODY of the regexp, along with the start/end portions suitable
  // for binding the start/end in either a joined full-path makeRe context
  // (where we bind to (^|/), or a standalone matchPart context (where
  // we bind to ^, and not /).  Otherwise slashes get duped!
  //
  // In part-matching mode, the start is:
  // - if not isStart: nothing
  // - if traversal possible, but not allowed: ^(?!\.\.?$)
  // - if dots allowed or not possible: ^
  // - if dots possible and not allowed: ^(?!\.)
  // end is:
  // - if not isEnd(): nothing
  // - else: $
  //
  // In full-path matching mode, we put the slash at the START of the
  // pattern, so start is:
  // - if first pattern: same as part-matching mode
  // - if not isStart(): nothing
  // - if traversal possible, but not allowed: /(?!\.\.?(?:$|/))
  // - if dots allowed or not possible: /
  // - if dots possible and not allowed: /(?!\.)
  // end is:
  // - if last pattern, same as part-matching mode
  // - else nothing
  //
  // Always put the (?:$|/) on negated tails, though, because that has to be
  // there to bind the end of the negated pattern portion, and it's easier to
  // just stick it in now rather than try to inject it later in the middle of
  // the pattern.
  //
  // We can just always return the same end, and leave it up to the caller
  // to know whether it's going to be used joined or in parts.
  // And, if the start is adjusted slightly, can do the same there:
  // - if not isStart: nothing
  // - if traversal possible, but not allowed: (?:/|^)(?!\.\.?$)
  // - if dots allowed or not possible: (?:/|^)
  // - if dots possible and not allowed: (?:/|^)(?!\.)
  //
  // But it's better to have a simpler binding without a conditional, for
  // performance, so probably better to return both start options.
  //
  // Then the caller just ignores the end if it's not the first pattern,
  // and the start always gets applied.
  //
  // But that's always going to be $ if it's the ending pattern, or nothing,
  // so the caller can just attach $ at the end of the pattern when building.
  //
  // So the todo is:
  // - better detect what kind of start is needed
  // - return both flavors of starting pattern
  // - attach $ at the end of the pattern when creating the actual RegExp
  //
  // Ah, but wait, no, that all only applies to the root when the first pattern
  // is not an extglob. If the first pattern IS an extglob, then we need all
  // that dot prevention biz to live in the extglob portions, because eg
  // +(*|.x*) can match .xy but not .yx.
  //
  // So, return the two flavors if it's #root and the first child is not an
  // AST, otherwise leave it to the child AST to handle it, and there,
  // use the (?:^|/) style of start binding.
  //
  // Even simplified further:
  // - Since the start for a join is eg /(?!\.) and the start for a part
  // is ^(?!\.), we can just prepend (?!\.) to the pattern (either root
  // or start or whatever) and prepend ^ or / at the Regexp construction.
  toRegExpSource(t) {
    const e = t ?? !!this.#r.dot;
    if (this.#s === this && this.#p(), !this.type) {
      const l = this.isStart() && this.isEnd(), h = this.#t.map((u) => {
        const [g, d, x, N] = typeof u == "string" ? E.#d(u, this.#n, l) : u.toRegExpSource(t);
        return this.#n = this.#n || x, this.#i = this.#i || N, g;
      }).join("");
      let c = "";
      if (this.isStart() && typeof this.#t[0] == "string" && !(this.#t.length === 1 && Zt.has(this.#t[0]))) {
        const g = Yt, d = (
          // dots are allowed, and the pattern starts with [ or .
          e && g.has(h.charAt(0)) || // the pattern starts with \., and then [ or .
          h.startsWith("\\.") && g.has(h.charAt(2)) || // the pattern starts with \.\., and then [ or .
          h.startsWith("\\.\\.") && g.has(h.charAt(4))
        ), x = !e && !t && g.has(h.charAt(0));
        c = d ? Vt : x ? P : "";
      }
      let p = "";
      return this.isEnd() && this.#s.#c && this.#e?.type === "!" && (p = "(?:$|\\/)"), [
        c + h + p,
        R(h),
        this.#n = !!this.#n,
        this.#i
      ];
    }
    const n = this.type === "*" || this.type === "+", r = this.type === "!" ? "(?:(?!(?:" : "(?:";
    let i = this.#f(e);
    if (this.isStart() && this.isEnd() && !i && this.type !== "!") {
      const l = this.toString();
      return this.#t = [l], this.type = null, this.#n = void 0, [l, R(this.toString()), !1, !1];
    }
    let o = !n || t || e || !P ? "" : this.#f(!0);
    o === i && (o = ""), o && (i = `(?:${i})(?:${o})*?`);
    let a = "";
    if (this.type === "!" && this.#u)
      a = (this.isStart() && !e ? P : "") + H;
    else {
      const l = this.type === "!" ? (
        // !() must match something,but !(x) can match ''
        "))" + (this.isStart() && !e && !t ? P : "") + G + ")"
      ) : this.type === "@" ? ")" : this.type === "?" ? ")?" : this.type === "+" && o ? ")" : this.type === "*" && o ? ")?" : `)${this.type}`;
      a = r + i + l;
    }
    return [
      a,
      R(i),
      this.#n = !!this.#n,
      this.#i
    ];
  }
  #f(t) {
    return this.#t.map((e) => {
      if (typeof e == "string")
        throw new Error("string type in extglob ast??");
      const [n, r, i, o] = e.toRegExpSource(t);
      return this.#i = this.#i || o, n;
    }).filter((e) => !(this.isStart() && this.isEnd()) || !!e).join("|");
  }
  static #d(t, e, n = !1) {
    let r = !1, i = "", o = !1;
    for (let a = 0; a < t.length; a++) {
      const l = t.charAt(a);
      if (r) {
        r = !1, i += (Jt.has(l) ? "\\" : "") + l;
        continue;
      }
      if (l === "\\") {
        a === t.length - 1 ? i += "\\\\" : r = !0;
        continue;
      }
      if (l === "[") {
        const [h, c, p, f] = Gt(t, a);
        if (p) {
          i += h, o = o || c, a += p - 1, e = e || f;
          continue;
        }
      }
      if (l === "*") {
        n && t === "*" ? i += H : i += G, e = !0;
        continue;
      }
      if (l === "?") {
        i += j, e = !0;
        continue;
      }
      i += Xt(l);
    }
    return [i, R(t), !!e, o];
  }
}
const Kt = (s, { windowsPathsNoEscape: t = !1 } = {}) => t ? s.replace(/[?*()[\]]/g, "[$&]") : s.replace(/[?*()[\]\\]/g, "\\$&"), w = (s, t, e = {}) => (I(t), !e.nocomment && t.charAt(0) === "#" ? !1 : new D(t, e).match(s)), Qt = /^\*+([^+@!?\*\[\(]*)$/, te = (s) => (t) => !t.startsWith(".") && t.endsWith(s), ee = (s) => (t) => t.endsWith(s), se = (s) => (s = s.toLowerCase(), (t) => !t.startsWith(".") && t.toLowerCase().endsWith(s)), ne = (s) => (s = s.toLowerCase(), (t) => t.toLowerCase().endsWith(s)), re = /^\*+\.\*+$/, ie = (s) => !s.startsWith(".") && s.includes("."), oe = (s) => s !== "." && s !== ".." && s.includes("."), ce = /^\.\*+$/, ae = (s) => s !== "." && s !== ".." && s.startsWith("."), le = /^\*+$/, he = (s) => s.length !== 0 && !s.startsWith("."), ue = (s) => s.length !== 0 && s !== "." && s !== "..", fe = /^\?+([^+@!?\*\[\(]*)?$/, pe = ([s, t = ""]) => {
  const e = st([s]);
  return t ? (t = t.toLowerCase(), (n) => e(n) && n.toLowerCase().endsWith(t)) : e;
}, de = ([s, t = ""]) => {
  const e = nt([s]);
  return t ? (t = t.toLowerCase(), (n) => e(n) && n.toLowerCase().endsWith(t)) : e;
}, ge = ([s, t = ""]) => {
  const e = nt([s]);
  return t ? (n) => e(n) && n.endsWith(t) : e;
}, me = ([s, t = ""]) => {
  const e = st([s]);
  return t ? (n) => e(n) && n.endsWith(t) : e;
}, st = ([s]) => {
  const t = s.length;
  return (e) => e.length === t && !e.startsWith(".");
}, nt = ([s]) => {
  const t = s.length;
  return (e) => e.length === t && e !== "." && e !== "..";
}, rt = typeof process == "object" && process ? typeof process.env == "object" && process.env && process.env.__MINIMATCH_TESTING_PLATFORM__ || process.platform : "posix", V = {
  win32: { sep: "\\" },
  posix: { sep: "/" }
}, we = rt === "win32" ? V.win32.sep : V.posix.sep;
w.sep = we;
const A = Symbol("globstar **");
w.GLOBSTAR = A;
const ye = "[^/]", Ee = ye + "*?", xe = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?", Se = "(?:(?!(?:\\/|^)\\.).)*?", Oe = (s, t = {}) => (e) => w(e, s, t);
w.filter = Oe;
const O = (s, t = {}) => Object.assign({}, s, t), Ae = (s) => {
  if (!s || typeof s != "object" || !Object.keys(s).length)
    return w;
  const t = w;
  return Object.assign((n, r, i = {}) => t(n, r, O(s, i)), {
    Minimatch: class extends t.Minimatch {
      constructor(r, i = {}) {
        super(r, O(s, i));
      }
      static defaults(r) {
        return t.defaults(O(s, r)).Minimatch;
      }
    },
    AST: class extends t.AST {
      /* c8 ignore start */
      constructor(r, i, o = {}) {
        super(r, i, O(s, o));
      }
      /* c8 ignore stop */
      static fromGlob(r, i = {}) {
        return t.AST.fromGlob(r, O(s, i));
      }
    },
    unescape: (n, r = {}) => t.unescape(n, O(s, r)),
    escape: (n, r = {}) => t.escape(n, O(s, r)),
    filter: (n, r = {}) => t.filter(n, O(s, r)),
    defaults: (n) => t.defaults(O(s, n)),
    makeRe: (n, r = {}) => t.makeRe(n, O(s, r)),
    braceExpand: (n, r = {}) => t.braceExpand(n, O(s, r)),
    match: (n, r, i = {}) => t.match(n, r, O(s, i)),
    sep: t.sep,
    GLOBSTAR: A
  });
};
w.defaults = Ae;
const it = (s, t = {}) => (I(s), t.nobrace || !/\{(?:(?!\{).)*\}/.test(s) ? [s] : Ft(s));
w.braceExpand = it;
const Ne = (s, t = {}) => new D(s, t).makeRe();
w.makeRe = Ne;
const be = (s, t, e = {}) => {
  const n = new D(t, e);
  return s = s.filter((r) => n.match(r)), n.options.nonull && !s.length && s.push(t), s;
};
w.match = be;
const Y = /[?*]|[+@!]\(.*?\)|\[|\]/, ve = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
class D {
  options;
  set;
  pattern;
  windowsPathsNoEscape;
  nonegate;
  negate;
  comment;
  empty;
  preserveMultipleSlashes;
  partial;
  globSet;
  globParts;
  nocase;
  isWindows;
  platform;
  windowsNoMagicRoot;
  regexp;
  constructor(t, e = {}) {
    I(t), e = e || {}, this.options = e, this.pattern = t, this.platform = e.platform || rt, this.isWindows = this.platform === "win32", this.windowsPathsNoEscape = !!e.windowsPathsNoEscape || e.allowWindowsEscape === !1, this.windowsPathsNoEscape && (this.pattern = this.pattern.replace(/\\/g, "/")), this.preserveMultipleSlashes = !!e.preserveMultipleSlashes, this.regexp = null, this.negate = !1, this.nonegate = !!e.nonegate, this.comment = !1, this.empty = !1, this.partial = !!e.partial, this.nocase = !!this.options.nocase, this.windowsNoMagicRoot = e.windowsNoMagicRoot !== void 0 ? e.windowsNoMagicRoot : !!(this.isWindows && this.nocase), this.globSet = [], this.globParts = [], this.set = [], this.make();
  }
  hasMagic() {
    if (this.options.magicalBraces && this.set.length > 1)
      return !0;
    for (const t of this.set)
      for (const e of t)
        if (typeof e != "string")
          return !0;
    return !1;
  }
  debug(...t) {
  }
  make() {
    const t = this.pattern, e = this.options;
    if (!e.nocomment && t.charAt(0) === "#") {
      this.comment = !0;
      return;
    }
    if (!t) {
      this.empty = !0;
      return;
    }
    this.parseNegate(), this.globSet = [...new Set(this.braceExpand())], e.debug && (this.debug = (...i) => console.error(...i)), this.debug(this.pattern, this.globSet);
    const n = this.globSet.map((i) => this.slashSplit(i));
    this.globParts = this.preprocess(n), this.debug(this.pattern, this.globParts);
    let r = this.globParts.map((i, o, a) => {
      if (this.isWindows && this.windowsNoMagicRoot) {
        const l = i[0] === "" && i[1] === "" && (i[2] === "?" || !Y.test(i[2])) && !Y.test(i[3]), h = /^[a-z]:/i.test(i[0]);
        if (l)
          return [...i.slice(0, 4), ...i.slice(4).map((c) => this.parse(c))];
        if (h)
          return [i[0], ...i.slice(1).map((c) => this.parse(c))];
      }
      return i.map((l) => this.parse(l));
    });
    if (this.debug(this.pattern, r), this.set = r.filter((i) => i.indexOf(!1) === -1), this.isWindows)
      for (let i = 0; i < this.set.length; i++) {
        const o = this.set[i];
        o[0] === "" && o[1] === "" && this.globParts[i][2] === "?" && typeof o[3] == "string" && /^[a-z]:$/i.test(o[3]) && (o[2] = "?");
      }
    this.debug(this.pattern, this.set);
  }
  // various transforms to equivalent pattern sets that are
  // faster to process in a filesystem walk.  The goal is to
  // eliminate what we can, and push all ** patterns as far
  // to the right as possible, even if it increases the number
  // of patterns that we have to process.
  preprocess(t) {
    if (this.options.noglobstar)
      for (let n = 0; n < t.length; n++)
        for (let r = 0; r < t[n].length; r++)
          t[n][r] === "**" && (t[n][r] = "*");
    const { optimizationLevel: e = 1 } = this.options;
    return e >= 2 ? (t = this.firstPhasePreProcess(t), t = this.secondPhasePreProcess(t)) : e >= 1 ? t = this.levelOneOptimize(t) : t = this.adjascentGlobstarOptimize(t), t;
  }
  // just get rid of adjascent ** portions
  adjascentGlobstarOptimize(t) {
    return t.map((e) => {
      let n = -1;
      for (; (n = e.indexOf("**", n + 1)) !== -1; ) {
        let r = n;
        for (; e[r + 1] === "**"; )
          r++;
        r !== n && e.splice(n, r - n);
      }
      return e;
    });
  }
  // get rid of adjascent ** and resolve .. portions
  levelOneOptimize(t) {
    return t.map((e) => (e = e.reduce((n, r) => {
      const i = n[n.length - 1];
      return r === "**" && i === "**" ? n : r === ".." && i && i !== ".." && i !== "." && i !== "**" ? (n.pop(), n) : (n.push(r), n);
    }, []), e.length === 0 ? [""] : e));
  }
  levelTwoFileOptimize(t) {
    Array.isArray(t) || (t = this.slashSplit(t));
    let e = !1;
    do {
      if (e = !1, !this.preserveMultipleSlashes) {
        for (let r = 1; r < t.length - 1; r++) {
          const i = t[r];
          r === 1 && i === "" && t[0] === "" || (i === "." || i === "") && (e = !0, t.splice(r, 1), r--);
        }
        t[0] === "." && t.length === 2 && (t[1] === "." || t[1] === "") && (e = !0, t.pop());
      }
      let n = 0;
      for (; (n = t.indexOf("..", n + 1)) !== -1; ) {
        const r = t[n - 1];
        r && r !== "." && r !== ".." && r !== "**" && (e = !0, t.splice(n - 1, 2), n -= 2);
      }
    } while (e);
    return t.length === 0 ? [""] : t;
  }
  // First phase: single-pattern processing
  // <pre> is 1 or more portions
  // <rest> is 1 or more portions
  // <p> is any portion other than ., .., '', or **
  // <e> is . or ''
  //
  // **/.. is *brutal* for filesystem walking performance, because
  // it effectively resets the recursive walk each time it occurs,
  // and ** cannot be reduced out by a .. pattern part like a regexp
  // or most strings (other than .., ., and '') can be.
  //
  // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}
  // <pre>/<e>/<rest> -> <pre>/<rest>
  // <pre>/<p>/../<rest> -> <pre>/<rest>
  // **/**/<rest> -> **/<rest>
  //
  // **/*/<rest> -> */**/<rest> <== not valid because ** doesn't follow
  // this WOULD be allowed if ** did follow symlinks, or * didn't
  firstPhasePreProcess(t) {
    let e = !1;
    do {
      e = !1;
      for (let n of t) {
        let r = -1;
        for (; (r = n.indexOf("**", r + 1)) !== -1; ) {
          let o = r;
          for (; n[o + 1] === "**"; )
            o++;
          o > r && n.splice(r + 1, o - r);
          let a = n[r + 1];
          const l = n[r + 2], h = n[r + 3];
          if (a !== ".." || !l || l === "." || l === ".." || !h || h === "." || h === "..")
            continue;
          e = !0, n.splice(r, 1);
          const c = n.slice(0);
          c[r] = "**", t.push(c), r--;
        }
        if (!this.preserveMultipleSlashes) {
          for (let o = 1; o < n.length - 1; o++) {
            const a = n[o];
            o === 1 && a === "" && n[0] === "" || (a === "." || a === "") && (e = !0, n.splice(o, 1), o--);
          }
          n[0] === "." && n.length === 2 && (n[1] === "." || n[1] === "") && (e = !0, n.pop());
        }
        let i = 0;
        for (; (i = n.indexOf("..", i + 1)) !== -1; ) {
          const o = n[i - 1];
          if (o && o !== "." && o !== ".." && o !== "**") {
            e = !0;
            const l = i === 1 && n[i + 1] === "**" ? ["."] : [];
            n.splice(i - 1, 2, ...l), n.length === 0 && n.push(""), i -= 2;
          }
        }
      }
    } while (e);
    return t;
  }
  // second phase: multi-pattern dedupes
  // {<pre>/*/<rest>,<pre>/<p>/<rest>} -> <pre>/*/<rest>
  // {<pre>/<rest>,<pre>/<rest>} -> <pre>/<rest>
  // {<pre>/**/<rest>,<pre>/<rest>} -> <pre>/**/<rest>
  //
  // {<pre>/**/<rest>,<pre>/**/<p>/<rest>} -> <pre>/**/<rest>
  // ^-- not valid because ** doens't follow symlinks
  secondPhasePreProcess(t) {
    for (let e = 0; e < t.length - 1; e++)
      for (let n = e + 1; n < t.length; n++) {
        const r = this.partsMatch(t[e], t[n], !this.preserveMultipleSlashes);
        if (r) {
          t[e] = [], t[n] = r;
          break;
        }
      }
    return t.filter((e) => e.length);
  }
  partsMatch(t, e, n = !1) {
    let r = 0, i = 0, o = [], a = "";
    for (; r < t.length && i < e.length; )
      if (t[r] === e[i])
        o.push(a === "b" ? e[i] : t[r]), r++, i++;
      else if (n && t[r] === "**" && e[i] === t[r + 1])
        o.push(t[r]), r++;
      else if (n && e[i] === "**" && t[r] === e[i + 1])
        o.push(e[i]), i++;
      else if (t[r] === "*" && e[i] && (this.options.dot || !e[i].startsWith(".")) && e[i] !== "**") {
        if (a === "b")
          return !1;
        a = "a", o.push(t[r]), r++, i++;
      } else if (e[i] === "*" && t[r] && (this.options.dot || !t[r].startsWith(".")) && t[r] !== "**") {
        if (a === "a")
          return !1;
        a = "b", o.push(e[i]), r++, i++;
      } else
        return !1;
    return t.length === e.length && o;
  }
  parseNegate() {
    if (this.nonegate)
      return;
    const t = this.pattern;
    let e = !1, n = 0;
    for (let r = 0; r < t.length && t.charAt(r) === "!"; r++)
      e = !e, n++;
    n && (this.pattern = t.slice(n)), this.negate = e;
  }
  // set partial to true to test if, for example,
  // "/a/b" matches the start of "/*/b/*/d"
  // Partial means, if you run out of file before you run
  // out of pattern, then that's fine, as long as all
  // the parts match.
  matchOne(t, e, n = !1) {
    const r = this.options;
    if (this.isWindows) {
      const d = typeof t[0] == "string" && /^[a-z]:$/i.test(t[0]), x = !d && t[0] === "" && t[1] === "" && t[2] === "?" && /^[a-z]:$/i.test(t[3]), N = typeof e[0] == "string" && /^[a-z]:$/i.test(e[0]), v = !N && e[0] === "" && e[1] === "" && e[2] === "?" && typeof e[3] == "string" && /^[a-z]:$/i.test(e[3]), S = x ? 3 : d ? 0 : void 0, m = v ? 3 : N ? 0 : void 0;
      if (typeof S == "number" && typeof m == "number") {
        const [$, C] = [t[S], e[m]];
        $.toLowerCase() === C.toLowerCase() && (e[m] = $, m > S ? e = e.slice(m) : S > m && (t = t.slice(S)));
      }
    }
    const { optimizationLevel: i = 1 } = this.options;
    i >= 2 && (t = this.levelTwoFileOptimize(t)), this.debug("matchOne", this, { file: t, pattern: e }), this.debug("matchOne", t.length, e.length);
    for (var o = 0, a = 0, l = t.length, h = e.length; o < l && a < h; o++, a++) {
      this.debug("matchOne loop");
      var c = e[a], p = t[o];
      if (this.debug(e, c, p), c === !1)
        return !1;
      if (c === A) {
        this.debug("GLOBSTAR", [e, c, p]);
        var f = o, u = a + 1;
        if (u === h) {
          for (this.debug("** at the end"); o < l; o++)
            if (t[o] === "." || t[o] === ".." || !r.dot && t[o].charAt(0) === ".")
              return !1;
          return !0;
        }
        for (; f < l; ) {
          var g = t[f];
          if (this.debug(`
globstar while`, t, f, e, u, g), this.matchOne(t.slice(f), e.slice(u), n))
            return this.debug("globstar found match!", f, l, g), !0;
          if (g === "." || g === ".." || !r.dot && g.charAt(0) === ".") {
            this.debug("dot detected!", t, f, e, u);
            break;
          }
          this.debug("globstar swallow a segment, and continue"), f++;
        }
        return !!(n && (this.debug(`
>>> no match, partial?`, t, f, e, u), f === l));
      }
      let d;
      if (typeof c == "string" ? (d = p === c, this.debug("string match", c, p, d)) : (d = c.test(p), this.debug("pattern match", c, p, d)), !d)
        return !1;
    }
    if (o === l && a === h)
      return !0;
    if (o === l)
      return n;
    if (a === h)
      return o === l - 1 && t[o] === "";
    throw new Error("wtf?");
  }
  braceExpand() {
    return it(this.pattern, this.options);
  }
  parse(t) {
    I(t);
    const e = this.options;
    if (t === "**")
      return A;
    if (t === "")
      return "";
    let n, r = null;
    (n = t.match(le)) ? r = e.dot ? ue : he : (n = t.match(Qt)) ? r = (e.nocase ? e.dot ? ne : se : e.dot ? ee : te)(n[1]) : (n = t.match(fe)) ? r = (e.nocase ? e.dot ? de : pe : e.dot ? ge : me)(n) : (n = t.match(re)) ? r = e.dot ? oe : ie : (n = t.match(ce)) && (r = ae);
    const i = E.fromGlob(t, this.options).toMMPattern();
    return r && typeof i == "object" && Reflect.defineProperty(i, "test", { value: r }), i;
  }
  makeRe() {
    if (this.regexp || this.regexp === !1)
      return this.regexp;
    const t = this.set;
    if (!t.length)
      return this.regexp = !1, this.regexp;
    const e = this.options, n = e.noglobstar ? Ee : e.dot ? xe : Se, r = new Set(e.nocase ? ["i"] : []);
    let i = t.map((l) => {
      const h = l.map((c) => {
        if (c instanceof RegExp)
          for (const p of c.flags.split(""))
            r.add(p);
        return typeof c == "string" ? ve(c) : c === A ? A : c._src;
      });
      return h.forEach((c, p) => {
        const f = h[p + 1], u = h[p - 1];
        c !== A || u === A || (u === void 0 ? f !== void 0 && f !== A ? h[p + 1] = "(?:\\/|" + n + "\\/)?" + f : h[p] = n : f === void 0 ? h[p - 1] = u + "(?:\\/|" + n + ")?" : f !== A && (h[p - 1] = u + "(?:\\/|\\/" + n + "\\/)" + f, h[p + 1] = A));
      }), h.filter((c) => c !== A).join("/");
    }).join("|");
    const [o, a] = t.length > 1 ? ["(?:", ")"] : ["", ""];
    i = "^" + o + i + a + "$", this.negate && (i = "^(?!" + i + ").+$");
    try {
      this.regexp = new RegExp(i, [...r].join(""));
    } catch {
      this.regexp = !1;
    }
    return this.regexp;
  }
  slashSplit(t) {
    return this.preserveMultipleSlashes ? t.split("/") : this.isWindows && /^\/\/[^\/]+/.test(t) ? ["", ...t.split(/\/+/)] : t.split(/\/+/);
  }
  match(t, e = this.partial) {
    if (this.debug("match", t, this.pattern), this.comment)
      return !1;
    if (this.empty)
      return t === "";
    if (t === "/" && e)
      return !0;
    const n = this.options;
    this.isWindows && (t = t.split("\\").join("/"));
    const r = this.slashSplit(t);
    this.debug(this.pattern, "split", r);
    const i = this.set;
    this.debug(this.pattern, "set", i);
    let o = r[r.length - 1];
    if (!o)
      for (let a = r.length - 2; !o && a >= 0; a--)
        o = r[a];
    for (let a = 0; a < i.length; a++) {
      const l = i[a];
      let h = r;
      if (n.matchBase && l.length === 1 && (h = [o]), this.matchOne(h, l, e))
        return n.flipNegate ? !0 : !this.negate;
    }
    return n.flipNegate ? !1 : this.negate;
  }
  static defaults(t) {
    return w.defaults(t).Minimatch;
  }
}
w.AST = E;
w.Minimatch = D;
w.escape = Kt;
w.unescape = R;
function Fe() {
  if (!("storage" in navigator) || !("getDirectory" in navigator.storage))
    throw new ht();
}
async function $e(s, t, e) {
  return typeof navigator < "u" && navigator.locks?.request ? navigator.locks.request(`opfs:${s.replace(/\/+/g, "/")}`, { mode: t }, e) : e();
}
function W(s) {
  return Array.isArray(s) ? s : (s.startsWith("~/") ? s.slice(2) : s).split("/").filter(Boolean);
}
function ot(s) {
  return typeof s == "string" ? s ?? "/" : `/${s.join("/")}`;
}
function ct(s) {
  const t = W(s);
  return t[t.length - 1] || "";
}
function je(s) {
  const t = W(s);
  return t.pop(), ot(t);
}
function at(s) {
  return !s || s === "/" ? "/" : s.startsWith("~/") ? `/${s.slice(2)}` : s.startsWith("/") ? s : `/${s}`;
}
function We(s, t = !1) {
  return s = s.replace(/\/$/, ""), t && !s.includes("*") ? `${s}/**` : s;
}
function Ue(s, t) {
  return w(s, t, {
    dot: !0,
    matchBase: !0
  });
}
function ze(s, t) {
  if (!t || Array.isArray(t) && t.length === 0)
    return !1;
  const e = at(s);
  return (Array.isArray(t) ? t : [t]).some((r) => w(e, r, { dot: !0 }));
}
function Be(s) {
  const t = at(s), e = W(t), n = [];
  for (const r of e)
    if (!(r === "." || r === ""))
      if (r === "..") {
        if (n.length === 0)
          continue;
        n.pop();
      } else
        n.push(r);
  return ot(n);
}
function _e(s) {
  const t = ct(s), e = t.lastIndexOf(".");
  return e <= 0 || e === t.length - 1 ? "" : t.slice(e);
}
function qe(s, t = "utf-8") {
  return typeof s == "string" ? yt(s, t) : s instanceof Uint8Array ? s : new Uint8Array(s);
}
async function Ge(s, t = "SHA-1", e = 50 * 1024 * 1024) {
  if (s instanceof File && (s = await s.arrayBuffer()), s.byteLength > e)
    throw new Error(`File size ${s.byteLength} bytes exceeds maximum allowed size ${e} bytes`);
  const n = new Uint8Array(s), r = await crypto.subtle.digest(t, n);
  return Array.from(new Uint8Array(r)).map((o) => o.toString(16).padStart(2, "0")).join("");
}
function He(s, t) {
  if (s.length !== t.length)
    return !1;
  for (let e = 0; e < s.length; e++)
    if (s[e] !== t[e])
      return !1;
  return !0;
}
async function Ve(s) {
  const t = await s.arrayBuffer();
  return new Uint8Array(t);
}
async function Ye(s, t, e = {}) {
  const n = ct(t);
  return $e(t, "exclusive", async () => {
    const r = e.recursive ?? !1, i = e.force ?? !1;
    try {
      await s.removeEntry(n, { recursive: r });
    } catch (o) {
      if (o.name === "NotFoundError") {
        if (!i)
          throw new Z("file", t, o);
      } else throw o.name === "InvalidModificationError" ? new z("ENOTEMPTY", t, o) : o.name === "TypeMismatchError" && !r ? new k("directory", t, o) : new z("RM_FAILED", t, o);
    }
  });
}
function Ze(s, t, e, n) {
  if (!Number.isInteger(t) || !Number.isInteger(e))
    throw new b("argument", "Invalid offset or length");
  if (t < 0 || e < 0)
    throw new b("argument", "Negative offset or length not allowed");
  if (t + e > s)
    throw new b("overflow", "Operation would overflow buffer");
  if (n != null && (!Number.isInteger(n) || n < 0))
    throw new b("argument", "Invalid position");
}
function Je(s, t, e) {
  try {
    t.flush(), t.close();
  } catch (n) {
    console.warn(`Warning: Failed to properly close file descriptor ${s} (${e}):`, n);
  }
}
function Xe(s, t, e) {
  if (s >= e)
    return { isEOF: !0, actualLength: 0 };
  const n = Math.min(t, e - s);
  return n <= 0 ? { isEOF: !0, actualLength: 0 } : { isEOF: !1, actualLength: n };
}
async function Ke(s, t) {
  try {
    return await s.createSyncAccessHandle();
  } catch (e) {
    throw mt(e, { path: t, isDirectory: !1 });
  }
}
export {
  Ce as A,
  He as B,
  Ve as C,
  z as D,
  Z as E,
  pt as F,
  Ye as G,
  Ze as H,
  U as I,
  Je as J,
  Xe as K,
  Ke as L,
  wt as M,
  y as O,
  Te as P,
  ft as S,
  b as V,
  At as W,
  ht as a,
  ut as b,
  k as c,
  De as d,
  yt as e,
  dt as f,
  gt as g,
  Me as h,
  Ie as i,
  Re as j,
  Pe as k,
  Fe as l,
  mt as m,
  ot as n,
  ct as o,
  je as p,
  at as q,
  We as r,
  W as s,
  Ue as t,
  ze as u,
  Be as v,
  $e as w,
  _e as x,
  qe as y,
  Ge as z
};
//# sourceMappingURL=helpers-CKOebsbw.js.map
