{"version":3,"file":"raw.js","sources":["../src/worker.ts"],"sourcesContent":["import { expose, transfer } from 'comlink';\n\nimport { WatchEventType } from './types';\nimport {\n    AlreadyExistsError,\n    DirectoryOperationError,\n    ExistenceError,\n    FileSystemOperationError,\n    FileTypeError,\n    InitializationFailedError,\n    OPFSError,\n    OperationNotSupportedError,\n    PathError,\n    ValidationError,\n    createFDError,\n    mapDomError\n} from './utils/errors';\n\nimport {\n    basename,\n    calculateFileHash,\n    calculateReadLength,\n    checkOPFSSupport,\n    convertBlobToUint8Array,\n    createSyncHandleSafe,\n    dirname,\n    joinPath,\n    matchMinimatch,\n    normalizeMinimatch,\n    normalizePath,\n    removeEntry,\n    resolvePath,\n    safeCloseSyncHandle,\n    splitPath,\n    validateReadWriteArgs,\n    withLock\n} from './utils/helpers';\n\nimport type { DirentData, FileOpenOptions, FileStat, OPFSOptions, RenameOptions, WatchEvent, WatchOptions, WatchSnapshot } from './types';\n\n\n/**\n * OPFS (Origin Private File System) File System implementation\n * \n * This class provides a high-level interface for working with the browser's\n * Origin Private File System API, offering file and directory operations\n * similar to Node.js fs module.\n * \n * @example\n * ```typescript\n * const fs = new OPFSFileSystem();\n * await fs.init('/my-app');\n * await fs.writeFile('/data/config.json', JSON.stringify({ theme: 'dark' }));\n * const config = await fs.readFile('/data/config.json');\n * ```\n */\nexport class OPFSWorker {\n    /** Root directory handle for the file system */\n    private root!: FileSystemDirectoryHandle;\n\n    /** Map of watched paths and options */\n    private watchers = new Map<string, WatchSnapshot>();\n\n    /** Promise to prevent concurrent mount operations */\n    private mountingPromise: Promise<boolean> | null = null;\n\n    /** BroadcastChannel instance for sending events */\n    private broadcastChannel: BroadcastChannel | null = null;\n\n    /** Configuration options */\n    private options: Required<OPFSOptions> = {\n        root: '/',\n        namespace: '',\n        maxFileSize: 50 * 1024 * 1024,\n        hashAlgorithm: 'etag',\n        broadcastChannel: 'opfs-worker',\n    };\n\n    /** Map of open file descriptors to their metadata */\n    private openFiles = new Map<number, {\n        path: string;\n        fileHandle: FileSystemFileHandle;\n        syncHandle: FileSystemSyncAccessHandle;\n        position: number;\n    }>();\n\n    /** Next available file descriptor number */\n    private nextFd = 1;\n\n    /**\n     * Get file info by descriptor with validation\n     * @private\n     */\n    private _getFileDescriptor(fd: number): { path: string; fileHandle: FileSystemFileHandle; syncHandle: FileSystemSyncAccessHandle; position: number } {\n        const fileInfo = this.openFiles.get(fd);\n\n        if (!fileInfo) {\n            throw new ValidationError('descriptor', `Invalid file descriptor: ${ fd }`);\n        }\n\n        return fileInfo;\n    }\n\n\n    /**\n     * Notify about internal changes to the file system\n     * \n     * This method is called by internal operations to notify clients about\n     * changes, even when no specific paths are being watched.\n     * \n     * @param path - The path that was changed\n     * @param type - The type of change (create, change, delete)\n     */\n    private async notifyChange(event: Omit<WatchEvent, 'timestamp' | 'hash' | 'namespace'>): Promise<void> {\n        // This instance not configured to send events\n        if (!this.options.broadcastChannel) {\n            return;\n        }\n\n        const path = event.path;\n\n        const match = [...this.watchers.values()].some((snapshot) => {\n            return (\n                matchMinimatch(path, snapshot.pattern)\n                && snapshot.include.some(include => include && matchMinimatch(path, include))\n                && !snapshot.exclude.some(exclude => exclude && matchMinimatch(path, exclude))\n            );\n        });\n\n        if (!match) {\n            return;\n        }\n\n        let hash: string | undefined;\n\n        if (this.options.hashAlgorithm) {\n            try {\n                const stat = await this.stat(path);\n\n                hash = stat.hash;\n            }\n            catch {}\n        }\n\n        // Send event via BroadcastChannel\n        try {\n            if (!this.broadcastChannel) {\n                this.broadcastChannel = new BroadcastChannel(this.options.broadcastChannel as string);\n            }\n\n            const watchEvent: WatchEvent = {\n                namespace: this.options.namespace,\n                timestamp: new Date().toISOString(),\n                ...event,\n                ...(hash && { hash }),\n            };\n\n            this.broadcastChannel.postMessage(watchEvent);\n        }\n        catch (error) {\n            console.warn('Failed to send event via BroadcastChannel:', error);\n        }\n    }\n\n    /**\n     * Creates a new OPFSFileSystem instance\n     * \n     * @param options - Optional configuration options\n     * @param options.root - Root path for the file system (default: '/')\n     * @param options.watchInterval - Polling interval in milliseconds for file watching\n     * @param options.hashAlgorithm - Hash algorithm for file hashing\n     * @param options.maxFileSize - Maximum file size for hashing in bytes (default: 50MB)\n     * @throws {OPFSError} If OPFS is not supported in the current browser\n     */\n    constructor(options?: OPFSOptions) {\n        checkOPFSSupport();\n\n        if (options) {\n            void this.setOptions(options);\n        }\n    }\n\n    /**\n     * Initialize the file system within a given directory\n     * \n     * This method sets up the root directory for all subsequent operations.\n     * If no root is specified, it will use the OPFS root directory.\n     * \n     * @param root - The root path for the file system (default: '/')\n     * @returns Promise that resolves to true if initialization was successful\n     * @throws {OPFSError} If initialization fails\n     * \n     * @example\n     * ```typescript\n     * const fs = new OPFSFileSystem();\n     * \n     * // Use OPFS root (default)\n     * await fs.mount();\n     * \n     * // Use custom directory\n     * await fs.mount('/my-app');\n     * ```\n     */\n    private async mount(): Promise<boolean> {\n        const root = this.options.root;\n\n        // If already mounting, wait for previous operation to complete first\n        if (this.mountingPromise) {\n            await this.mountingPromise;\n        }\n\n        // eslint-disable-next-line no-async-promise-executor\n        this.mountingPromise = new Promise<boolean>(async(resolve, reject) => {\n            try {\n                const rootDir = await navigator.storage.getDirectory();\n\n                this.root = (root === '/') ? rootDir : await this.getDirectoryHandle(root, true, rootDir);\n\n                resolve(true);\n            }\n            catch (error) {\n                reject(new InitializationFailedError(root, error));\n            }\n            finally {\n                this.mountingPromise = null;\n            }\n        });\n\n        return this.mountingPromise;\n    }\n\n\n    /**\n     * Update configuration options\n     * \n     * @param options - Configuration options to update\n     * @param options.root - Root path for the file system\n     * @param options.watchInterval - Polling interval in milliseconds for file watching\n     * @param options.hashAlgorithm - Hash algorithm for file hashing\n     * @param options.maxFileSize - Maximum file size for hashing in bytes\n     * @param options.broadcastChannel - Custom name for the broadcast channel\n     */\n    async setOptions(options: OPFSOptions): Promise<void> {\n        if (options.hashAlgorithm !== undefined) {\n            this.options.hashAlgorithm = options.hashAlgorithm;\n        }\n\n        if (options.maxFileSize !== undefined) {\n            this.options.maxFileSize = options.maxFileSize;\n        }\n\n        if (options.broadcastChannel !== undefined) {\n            // Close existing channel if name changed\n            if (this.broadcastChannel && this.options.broadcastChannel !== options.broadcastChannel) {\n                this.broadcastChannel.close();\n                this.broadcastChannel = null;\n            }\n\n            this.options.broadcastChannel = options.broadcastChannel;\n        }\n\n        if (options.namespace) {\n            this.options.namespace = options.namespace;\n        }\n\n        if (options.root !== undefined) {\n            this.options.root = normalizePath(options.root);\n\n            if (!this.options.namespace) {\n                this.options.namespace = `opfs-worker:${ this.options.root }`;\n            }\n\n            await this.mount();\n        }\n    }\n\n    /**\n     * Get a directory handle from a path\n     * \n     * Navigates through the directory structure to find or create a directory\n     * at the specified path.\n     * \n     * @param path - The path to the directory (string or array of segments)\n     * @param create - Whether to create the directory if it doesn't exist (default: false)\n     * @param from - The directory to start from (default: root directory)\n     * @returns Promise that resolves to the directory handle\n     * @throws {OPFSError} If the directory cannot be accessed or created\n     * \n     * @example\n     * ```typescript\n     * const docsDir = await fs.getDirectoryHandle('/users/john/documents', true);\n     * const docsDir2 = await fs.getDirectoryHandle(['users', 'john', 'documents'], true);\n     * ```\n     */\n    private async getDirectoryHandle(path: string | string[], create: boolean = false, from: FileSystemDirectoryHandle | null = this.root): Promise<FileSystemDirectoryHandle> {\n        const segments = Array.isArray(path) ? path : splitPath(path);\n        let current = from;\n\n        for (const segment of segments) {\n            current = await current!.getDirectoryHandle(segment, { create });\n        }\n\n        return current!;\n    }\n\n    /**\n     * Get a file handle from a path\n     * \n     * Navigates to the parent directory and retrieves or creates a file handle\n     * for the specified file path.\n     * \n     * @param path - The path to the file (string or array of segments)\n     * @param create - Whether to create the file if it doesn't exist (default: false)\n     * @param _from - The directory to start from (default: root directory)\n     * @returns Promise that resolves to the file handle\n     * @throws {PathError} If the path is empty\n     * @throws {OPFSError} If the file cannot be accessed or created\n     * \n     * @example\n     * ```typescript\n     * const fileHandle = await fs.getFileHandle('/config/settings.json', true);\n     * const fileHandle2 = await fs.getFileHandle(['config', 'settings.json'], true);\n     * ```\n     */\n    private async getFileHandle(path: string | string[], create = false, _from: FileSystemDirectoryHandle | null = this.root): Promise<FileSystemFileHandle> {\n        const segments = splitPath(path);\n\n        if (segments.length === 0) {\n            throw new PathError('Path must not be empty', Array.isArray(path) ? path.join('/') : path);\n        }\n\n        const fileName = segments.pop()!;\n        const dir = await this.getDirectoryHandle(segments, create, _from);\n\n        return dir.getFileHandle(fileName, { create });\n    }\n\n    /**\n     * Get a complete index of all files and directories in the file system\n     * \n     * This method recursively traverses the entire file system and returns\n     * a Map containing FileStat objects for every file and directory.\n     * \n     * @returns Promise that resolves to a Map of paths to FileStat objects\n     * @throws {OPFSError} If the file system is not mounted\n     * \n     * @example\n     * ```typescript\n     * const index = await fs.index();\n     * const fileStats = index.get('/data/config.json');\n     * if (fileStats) {\n     *   console.log(`File size: ${fileStats.size} bytes`);\n     *   if (fileStats.hash) console.log(`Hash: ${fileStats.hash}`);\n     * }\n     * ```\n     */\n    async index(): Promise<Map<string, FileStat>> {\n        const result = new Map<string, FileStat>();\n\n        const walk = async(dirPath: string) => {\n            const items = await this.readDir(dirPath);\n\n            for (const item of items) {\n                const fullPath = `${ dirPath === '/' ? '' : dirPath }/${ item.name }`;\n\n                try {\n                    const stat = await this.stat(fullPath);\n\n                    result.set(fullPath, stat);\n\n                    if (stat.isDirectory) {\n                        await walk(fullPath);\n                    }\n                }\n                catch (err) {\n                    console.warn(`Skipping broken entry: ${ fullPath }`, err);\n                }\n            }\n        };\n\n        result.set('/', {\n            kind: 'directory',\n            size: 0,\n            mtime: new Date(0).toISOString(),\n            ctime: new Date(0).toISOString(),\n            isFile: false,\n            isDirectory: true,\n        });\n\n        await walk('/');\n\n        return result;\n    }\n\n    /**\n     * Read a file from the file system\n     * \n     * Reads the contents of a file and returns it as binary data.\n     * \n     * @param path - The path to the file to read\n     * @returns Promise that resolves to the file contents as Uint8Array\n     * @throws {FileNotFoundError} If the file does not exist\n     * @throws {OPFSError} If reading the file fails\n     * \n     * @example\n     * ```typescript\n     * // Read as binary data\n     * const content = await fs.readFile('/config/settings.json');\n     * \n     * // Read binary file\n     * const binaryData = await fs.readFile('/images/logo.png');\n     * ```\n     */\n    async readFile(path: string): Promise<Uint8Array> {\n        await this.mount();\n\n        try {\n            return await withLock(path, 'shared', async() => {\n                const fd = await this.open(path);\n\n                try {\n                    const { size } = await this.fstat(fd);\n                    const buffer = new Uint8Array(size);\n\n                    if (size > 0) {\n                        await this.read(fd, buffer, 0, size, 0);\n                    }\n\n                    return transfer(buffer, [buffer.buffer]);\n                }\n                finally {\n                    await this.close(fd);\n                }\n            });\n        }\n        catch (err) {\n            throw new ExistenceError('file', path, err);\n        }\n    }\n\n    /**\n     * Write data to a file\n     * \n     * Creates or overwrites a file with the specified binary data. If the file already\n     * exists, it will be truncated before writing.\n     * \n     * @param path - The path to the file to write\n     * @param data - The binary data to write to the file (Uint8Array or ArrayBuffer)\n     * @returns Promise that resolves when the write operation is complete\n     * @throws {OPFSError} If writing the file fails\n     * \n     * @example\n     * ```typescript\n     * // Write binary data\n     * const binaryData = new Uint8Array([1, 2, 3, 4, 5]);\n     * await fs.writeFile('/data/binary.dat', binaryData);\n     * \n     * // Write from ArrayBuffer\n     * const arrayBuffer = new ArrayBuffer(10);\n     * await fs.writeFile('/data/buffer.dat', arrayBuffer);\n     * ```\n     */\n    async writeFile(\n        path: string,\n        data: Uint8Array | ArrayBuffer\n    ): Promise<void> {\n        await this.mount();\n\n        const buffer = data instanceof Uint8Array ? data : new Uint8Array(data);\n\n        await withLock(path, 'exclusive', async() => {\n            const existed = await this.exists(path);\n            const fd = await this.open(path, { create: true, truncate: true });\n\n            try {\n                await this.write(fd, buffer, 0, buffer.length, null, false);\n                await this.fsync(fd);\n            }\n            finally {\n                await this.close(fd);\n            }\n\n            await this.notifyChange({ path, type: existed ? WatchEventType.Changed : WatchEventType.Added, isDirectory: false });\n        });\n    }\n\n    /**\n     * Append data to a file\n     * \n     * Adds binary data to the end of an existing file. If the file doesn't exist,\n     * it will be created.\n     * \n     * @param path - The path to the file to append to\n     * @param data - The binary data to append to the file (Uint8Array or ArrayBuffer)\n     * @returns Promise that resolves when the append operation is complete\n     * @throws {OPFSError} If appending to the file fails\n     * \n     * @example\n     * ```typescript\n     * // Append binary data\n     * const additionalData = new Uint8Array([6, 7, 8]);\n     * await fs.appendFile('/data/binary.dat', additionalData);\n     * \n     * // Append from ArrayBuffer\n     * const arrayBuffer = new ArrayBuffer(5);\n     * await fs.appendFile('/data/buffer.dat', arrayBuffer);\n     * ```\n     */\n    async appendFile(\n        path: string,\n        data: Uint8Array | ArrayBuffer\n    ): Promise<void> {\n        await this.mount();\n\n        const buffer = data instanceof Uint8Array ? data : new Uint8Array(data);\n\n        await withLock(path, 'exclusive', async() => {\n            const fd = await this.open(path, { create: true });\n\n            try {\n                const { size } = await this.fstat(fd);\n\n                await this.write(fd, buffer, 0, buffer.length, size, false);\n                await this.fsync(fd);\n            }\n            finally {\n                await this.close(fd);\n            }\n\n            await this.notifyChange({ path, type: WatchEventType.Changed, isDirectory: false });\n        });\n    }\n\n    /**\n     * Create a directory\n     * \n     * Creates a new directory at the specified path. If the recursive option\n     * is enabled, parent directories will be created as needed.\n     * \n     * @param path - The path where the directory should be created\n     * @param options - Options for directory creation\n     * @param options.recursive - Whether to create parent directories if they don't exist (default: false)\n     * @returns Promise that resolves when the directory is created\n     * @throws {OPFSError} If the directory cannot be created\n     * \n     * @example\n     * ```typescript\n     * // Create a single directory\n     * await fs.mkdir('/users/john');\n     * \n     * // Create nested directories\n     * await fs.mkdir('/users/john/documents/projects', { recursive: true });\n     * ```\n     */\n    async mkdir(path: string, options?: { recursive?: boolean }): Promise<void> {\n        await this.mount();\n\n        const recursive = options?.recursive ?? false;\n        const segments = splitPath(path);\n\n        let current: FileSystemDirectoryHandle | null = this.root;\n\n        for (let i = 0; i < segments.length; i++) {\n            const segment = segments[i];\n\n            try {\n                current = await current.getDirectoryHandle(segment!, { create: recursive || i === segments.length - 1 });\n            }\n            catch (err: any) {\n                if (err.name === 'NotFoundError') {\n                    throw new ExistenceError('directory', joinPath(segments.slice(0, i + 1)), err);\n                }\n\n                if (err.name === 'TypeMismatchError') {\n                    throw new FileTypeError('file', segment!, err);\n                }\n\n                throw new FileSystemOperationError('create directory', segment!, err);\n            }\n        }\n\n        await this.notifyChange({ path, type: WatchEventType.Added, isDirectory: true });\n    }\n\n    /**\n     * Get file or directory statistics\n     * \n     * Returns detailed information about a file or directory, including\n     * size, modification time, and optionally a hash of the file content.\n     * \n     * @param path - The path to the file or directory\n     * @returns Promise that resolves to FileStat object\n     * @throws {OPFSError} If the path does not exist or cannot be accessed\n     * \n     * @example\n     * ```typescript\n     * const stats = await fs.stat('/data/config.json');\n     * console.log(`File size: ${stats.size} bytes`);\n     * console.log(`Last modified: ${stats.mtime}`);\n     * \n     * // If hashing is enabled, hash will be included\n     * if (stats.hash) {\n     *   console.log(`Hash: ${stats.hash}`);\n     * }\n     * ```\n     */\n    async stat(path: string): Promise<FileStat> {\n        await this.mount();\n\n        // Special handling for root directory\n        if (path === '/') {\n            return {\n                kind: 'directory',\n                size: 0,\n                mtime: new Date(0).toISOString(),\n                ctime: new Date(0).toISOString(),\n                isFile: false,\n                isDirectory: true,\n            };\n        }\n\n        const name = basename(path);\n        let parentDir: FileSystemDirectoryHandle;\n\n        try {\n            parentDir = await this.getDirectoryHandle(dirname(path), false);\n            const hashAlgorithm = this.options.hashAlgorithm;\n\n            const fileHandle = await parentDir.getFileHandle(name, { create: false });\n            const file = await fileHandle.getFile();\n\n            const baseStat: FileStat = {\n                kind: 'file',\n                size: file.size,\n                mtime: new Date(file.lastModified).toISOString(),\n                ctime: new Date(file.lastModified).toISOString(),\n                isFile: true,\n                isDirectory: false,\n            };\n\n            if (hashAlgorithm === 'etag') {\n                baseStat.hash = `${ file.lastModified.toString(36) }-${ file.size.toString(36) }`;\n            }\n            // Crypto hash\n            else if (typeof hashAlgorithm === 'string') {\n                try {\n                    const hash = await calculateFileHash(file, hashAlgorithm, this.options.maxFileSize);\n\n                    baseStat.hash = hash;\n                }\n                catch (error) {\n                    console.warn(`Failed to calculate hash for ${ path }:`, error);\n                }\n            }\n\n            return baseStat;\n        }\n        catch (e: any) {\n            if (e.name === 'NotFoundError') {\n                throw new ExistenceError('file', path, e);\n            }\n\n            if (e.name !== 'TypeMismatchError') {\n                throw new FileSystemOperationError('stat', path, e);\n            }\n        }\n\n        try {\n            await parentDir!.getDirectoryHandle(name, { create: false });\n\n            return {\n                kind: 'directory',\n                size: 0,\n                mtime: new Date(0).toISOString(),\n                ctime: new Date(0).toISOString(),\n                isFile: false,\n                isDirectory: true,\n            };\n        }\n        catch (e: any) {\n            throw new FileSystemOperationError('stat', path, e);\n        }\n    }\n\n    /**\n     * Read a directory's contents\n     * \n     * Lists all files and subdirectories within the specified directory.\n     * \n     * @param path - The path to the directory to read\n     * @returns Promise that resolves to an array of detailed file/directory information\n     * @throws {OPFSError} If the directory does not exist or cannot be accessed\n     * \n     * @example\n     * ```typescript\n     * // Get detailed information about files and directories\n     * const detailed = await fs.readDir('/users/john/documents');\n     * detailed.forEach(item => {\n     *   console.log(`${item.name} - ${item.isFile ? 'file' : 'directory'}`);\n     * });\n     * ```\n     */\n    async readDir(path: string): Promise<DirentData[]> {\n        await this.mount();\n\n        const dir = await this.getDirectoryHandle(path, false);\n\n        const results: DirentData[] = [];\n\n        for await (const [name, handle] of (dir as any).entries()) {\n            const isFile = handle.kind === 'file';\n\n            results.push({\n                name,\n                kind: handle.kind,\n                isFile,\n                isDirectory: !isFile,\n            });\n        }\n\n        return results;\n    }\n\n    /**\n     * Check if a file or directory exists\n     * \n     * Verifies if a file or directory exists at the specified path.\n     * \n     * @param path - The path to check\n     * @returns Promise that resolves to true if the file or directory exists, false otherwise  \n     * \n     * @example\n     * ```typescript\n     * const exists = await fs.exists('/config/settings.json');\n     * console.log(`File exists: ${exists}`);\n     * ```\n     */\n    async exists(path: string): Promise<boolean> {\n        await this.mount();\n\n        if (path === '/') {\n            return true;\n        }\n\n        const name = basename(path);\n        let dir: FileSystemDirectoryHandle | null = null;\n\n        try {\n            dir = await this.getDirectoryHandle(dirname(path), false);\n        }\n        catch (e: any) {\n            dir = null;\n\n            if (e.name !== 'NotFoundError' && e.name !== 'TypeMismatchError') {\n                throw e;\n            }\n        }\n\n        if (!dir || !name) {\n            return false;\n        }\n\n        try {\n            await dir.getFileHandle(name, { create: false });\n\n            return true;\n        }\n        catch (err: any) {\n            if (err.name !== 'NotFoundError' && err.name !== 'TypeMismatchError') {\n                throw err;\n            }\n\n            try {\n                await dir.getDirectoryHandle(name, { create: false });\n\n                return true;\n            }\n            catch (err: any) {\n                if (err.name !== 'NotFoundError' && err.name !== 'TypeMismatchError') {\n                    throw err;\n                }\n\n                return false;\n            }\n        }\n    }\n\n    /**\n     * Clear all contents of a directory without removing the directory itself\n     * \n     * Removes all files and subdirectories within the specified directory,\n     * but keeps the directory itself.\n     * \n     * @param path - The path to the directory to clear (default: '/')\n     * @returns Promise that resolves when all contents are removed\n     * @throws {OPFSError} If the operation fails\n     * \n     * @example\n     * ```typescript\n     * // Clear root directory contents\n     * await fs.clear('/');\n     * \n     * // Clear specific directory contents\n     * await fs.clear('/data');\n     * ```\n     */\n    async clear(path: string = '/'): Promise<void> {\n        await this.mount();\n\n        try {\n            const items = await this.readDir(path);\n\n            for (const item of items) {\n                const itemPath = `${ path === '/' ? '' : path }/${ item.name }`;\n\n                await this.remove(itemPath, { recursive: true });\n            }\n\n            await this.notifyChange({ path, type: WatchEventType.Changed, isDirectory: true });\n        }\n        catch (error: any) {\n            if (error instanceof OPFSError) {\n                throw error;\n            }\n\n            throw mapDomError(error, { path, isDirectory: true });\n        }\n    }\n\n    /**\n     * Remove files and directories\n     * \n     * Removes files and directories. Similar to Node.js fs.rm().\n     * \n     * @param path - The path to remove\n     * @param options - Options for removal\n     * @param options.recursive - Whether to remove directories and their contents recursively (default: false)\n     * @param options.force - Whether to ignore errors if the path doesn't exist (default: false)\n     * @returns Promise that resolves when the removal is complete\n     * @throws {OPFSError} If the removal fails\n     * \n     * @example\n     * ```typescript\n     * // Remove a file\n     * await fs.rm('/path/to/file.txt');\n     * \n     * // Remove a directory and all its contents\n     * await fs.rm('/path/to/directory', { recursive: true });\n     * \n     * // Remove with force (ignore if doesn't exist)\n     * await fs.rm('/maybe/exists', { force: true });\n     * ```\n     */\n    async remove(path: string, options?: { recursive?: boolean; force?: boolean }): Promise<void> {\n        await this.mount();\n\n        // Special handling for root directory\n        if (path === '/') {\n            throw new DirectoryOperationError('EROOT', path);\n        }\n\n        const { recursive = false, force = false } = options || {};\n\n        const parent = await this.getDirectoryHandle(dirname(path), false);\n        const stat = await this.stat(path);\n\n        await removeEntry(parent, path, { recursive, force });\n\n        await this.notifyChange({ path, type: WatchEventType.Removed, isDirectory: stat.isDirectory });\n    }\n\n    /**\n     * Resolve a path to an absolute path\n     * \n     * Resolves relative paths and normalizes path segments (like '..' and '.').\n     * Similar to Node.js fs.realpath() but without symlink resolution since OPFS doesn't support symlinks.\n     * \n     * @param path - The path to resolve\n     * @returns Promise that resolves to the absolute normalized path\n     * @throws {FileNotFoundError} If the path does not exist\n     * @throws {OPFSError} If path resolution fails\n     * \n     * @example\n     * ```typescript\n     * // Resolve relative path\n     * const absolute = await fs.realpath('./config/../data/file.txt');\n     * console.log(absolute); // '/data/file.txt'\n     * ```\n     */\n    async realpath(path: string): Promise<string> {\n        await this.mount();\n\n        try {\n            const normalizedPath = resolvePath(path);\n            const exists = await this.exists(normalizedPath);\n\n            if (!exists) {\n                throw new ExistenceError('file', normalizedPath);\n            }\n\n            return normalizedPath;\n        }\n        catch (error) {\n            if (error instanceof OPFSError) {\n                throw error;\n            }\n\n            throw mapDomError(error, { path });\n        }\n    }\n\n    /**\n     * Rename a file or directory\n     * \n     * Changes the name of a file or directory. If the target path already exists,\n     * it will be replaced only if overwrite option is enabled.\n     * \n     * @param oldPath - The current path of the file or directory\n     * @param newPath - The new path for the file or directory\n     * @param options - Options for renaming\n     * @param options.overwrite - Whether to overwrite existing files (default: false)\n     * @returns Promise that resolves when the rename operation is complete\n     * @throws {OPFSError} If the rename operation fails\n     * \n     * @example\n     * ```typescript\n     * // Basic rename (fails if target exists)\n     * await fs.rename('/old/path/file.txt', '/new/path/renamed.txt');\n     * \n     * // Rename with overwrite\n     * await fs.rename('/old/path/file.txt', '/new/path/renamed.txt', { overwrite: true });\n     * ```\n     */\n    async rename(oldPath: string, newPath: string, options?: RenameOptions): Promise<void> {\n        await this.mount();\n\n        try {\n            const overwrite = options?.overwrite ?? false;\n\n            const sourceStat = await this.stat(oldPath);\n            const destExists = await this.exists(newPath);\n\n            if (destExists && !overwrite) {\n                throw new AlreadyExistsError(newPath);\n            }\n\n            await this.copy(oldPath, newPath, { recursive: true, overwrite });\n            await this.remove(oldPath, { recursive: true });\n\n            // Notify about the rename operation\n            await this.notifyChange({ path: oldPath, type: WatchEventType.Removed, isDirectory: sourceStat.isDirectory });\n            await this.notifyChange({ path: newPath, type: WatchEventType.Added, isDirectory: sourceStat.isDirectory });\n        }\n        catch (error) {\n            if (error instanceof OPFSError) {\n                throw error;\n            }\n\n            throw mapDomError(error, { path: oldPath });\n        }\n    }\n\n    /**\n     * Copy files and directories\n     * \n     * Copies files and directories. Similar to Node.js fs.cp().\n     * \n     * @param source - The source path to copy from\n     * @param destination - The destination path to copy to\n     * @param options - Options for copying\n     * @param options.recursive - Whether to copy directories recursively (default: false)\n     * @param options.overwrite - Whether to overwrite existing files (default: true)\n     * @returns Promise that resolves when the copy operation is complete\n     * @throws {OPFSError} If the copy operation fails\n     * \n     * @example\n     * ```typescript\n     * // Copy a file\n     * await fs.copy('/source/file.txt', '/dest/file.txt');\n     * \n     * // Copy a directory and all its contents\n     * await fs.copy('/source/dir', '/dest/dir', { recursive: true });\n     * \n     * // Copy without overwriting existing files\n     * await fs.copy('/source', '/dest', { recursive: true, overwrite: false });\n     * ```\n     */\n    async copy(source: string, destination: string, options?: { recursive?: boolean; overwrite?: boolean }): Promise<void> {\n        await this.mount();\n\n        try {\n            const recursive = options?.recursive ?? false;\n            const overwrite = options?.overwrite ?? true;\n\n            const sourceExists = await this.exists(source);\n\n            if (!sourceExists) {\n                throw new ExistenceError('source', source);\n            }\n\n            const destExists = await this.exists(destination);\n\n            if (destExists && !overwrite) {\n                throw new AlreadyExistsError(destination);\n            }\n\n            const sourceStats = await this.stat(source);\n\n            if (sourceStats.isFile) {\n                const content = await this.readFile(source);\n\n                await this.writeFile(destination, content);\n            }\n            else {\n                if (!recursive) {\n                    throw new FileTypeError('directory', source);\n                }\n\n                await this.mkdir(destination, { recursive: true });\n\n                const items = await this.readDir(source);\n\n                for (const item of items) {\n                    const sourceItemPath = `${ source }/${ item.name }`;\n                    const destItemPath = `${ destination }/${ item.name }`;\n\n                    await this.copy(sourceItemPath, destItemPath, { recursive: true, overwrite });\n                }\n            }\n        }\n        catch (error) {\n            if (error instanceof OPFSError) {\n                throw error;\n            }\n\n            throw mapDomError(error, { path: source });\n        }\n    }\n\n    /**\n     * Start watching a file or directory for changes\n     * \n     * @param path - The path to watch (minimatch syntax allowed)\n     * @param options - Watch options\n     * @param options.recursive - Whether to watch recursively (default: true)\n     * @param options.exclude - Glob pattern(s) to exclude (minimatch).\n     * @returns Promise that resolves when watching starts\n     * \n     * @example\n     * ```typescript\n     * // Watch entire directory tree recursively (default)\n     * await fs.watch('/data');\n     * \n     * // Watch only immediate children (shallow)\n     * await fs.watch('/data', { recursive: false });\n     * \n     * // Watch a single file\n     * await fs.watch('/config.json', { recursive: false });\n     * \n     * // Watch all json files but not in dist directory\n     * await fs.watch('/**\\/*.json', { recursive: false, exclude: ['dist/**'] });\n     *\n     * ```\n     */\n    async watch(path: string, options?: WatchOptions): Promise<void> {\n        if (!this.options.broadcastChannel) {\n            throw new OperationNotSupportedError('This instance is not configured to send events. Please specify options.broadcastChannel to enable watching.');\n        }\n\n        const snapshot: WatchSnapshot = {\n            pattern: normalizeMinimatch(path, options?.recursive ?? true),\n            include: Array.isArray(options?.include) ? options.include : [options?.include ?? '**'],\n            exclude: Array.isArray(options?.exclude) ? options.exclude : [options?.exclude ?? ''],\n        };\n\n        this.watchers.set(path, snapshot);\n    }\n\n    /**\n     * Stop watching a previously watched path\n     */\n    unwatch(path: string): void {\n        this.watchers.delete(path);\n    }\n\n    /**\n     * Open a file and return a file descriptor\n     * \n     * @param path - The path to the file to open\n     * @param options - Options for opening the file\n     * @param options.create - Whether to create the file if it doesn't exist (default: false)\n     * @param options.exclusive - If true and create is true, fails if file already exists (default: false)\n     *                            Note: This is best-effort in OPFS, not fully atomic due to browser limitations\n     * @param options.truncate - Whether to truncate the file to zero length (default: false)\n     * @returns Promise that resolves to a file descriptor number\n     * @throws {OPFSError} If opening the file fails\n     * \n     * @example\n     * ```typescript\n     * // Open existing file for reading\n     * const fd = await fs.open('/data/config.json');\n     * \n     * // Create new file for writing\n     * const fd = await fs.open('/data/new.txt', { create: true });\n     * \n     * // Create file exclusively (fails if exists)\n     * const fd = await fs.open('/data/unique.txt', { create: true, exclusive: true });\n     * \n     * // Open and truncate file\n     * const fd = await fs.open('/data/log.txt', { create: true, truncate: true });\n     * ```\n     */\n    async open(path: string, options?: FileOpenOptions): Promise<number> {\n        await this.mount();\n\n        const { create = false, exclusive = false, truncate = false } = options || {};\n\n        // Normalize path to prevent path-related issues\n        const normalizedPath = normalizePath(resolvePath(path));\n\n        try {\n            // Use lock for atomic operations when creating files\n            if (create && exclusive) {\n                return await withLock(normalizedPath, 'exclusive', async() => {\n                    const exists = await this.exists(normalizedPath);\n\n                    if (exists) {\n                        throw new AlreadyExistsError(normalizedPath);\n                    }\n\n                    return this._openFile(normalizedPath, create, truncate);\n                });\n            }\n\n            return await this._openFile(normalizedPath, create, truncate);\n        }\n        catch (error) {\n            if (error instanceof OPFSError) {\n                throw error;\n            }\n\n            throw mapDomError(error, { path: normalizedPath, isDirectory: false });\n        }\n    }\n\n    /**\n     * Internal method to open a file (without locking)\n     * @private\n     */\n    private async _openFile(path: string, create: boolean, truncate: boolean): Promise<number> {\n        const fileHandle = await this.getFileHandle(path, create);\n\n        // Verify that we got a file handle, not a directory\n        try {\n            // If getFile() succeeds, it's a file\n            await fileHandle.getFile();\n        }\n        catch (error: any) {\n            throw mapDomError(error, { path, isDirectory: true });\n        }\n\n        // Create sync access handle safely with proper error mapping\n        const syncHandle = await createSyncHandleSafe(fileHandle, path);\n\n        // If truncate is requested, use efficient truncate() method\n        if (truncate) {\n            syncHandle.truncate(0);\n            syncHandle.flush();\n        }\n\n        const fd = this.nextFd++;\n\n        this.openFiles.set(fd, {\n            path,\n            fileHandle,\n            syncHandle,\n            position: 0,\n        });\n\n        return fd;\n    }\n\n    /**\n     * Close a file descriptor\n     * \n     * @param fd - The file descriptor to close\n     * @returns Promise that resolves when the file descriptor is closed\n     * @throws {OPFSError} If the file descriptor is invalid or closing fails\n     * \n     * @example\n     * ```typescript\n     * const fd = await fs.open('/data/file.txt');\n     * // ... use the file descriptor ...\n     * await fs.close(fd);\n     * ```\n     */\n    async close(fd: number): Promise<void> {\n        const fileInfo = this._getFileDescriptor(fd);\n\n        safeCloseSyncHandle(fd, fileInfo.syncHandle, fileInfo.path);\n\n        this.openFiles.delete(fd);\n    }\n\n    /**\n     * Read data from a file descriptor\n     * \n     * @param fd - The file descriptor to read from\n     * @param buffer - The buffer to read data into\n     * @param offset - The offset in the buffer to start writing at\n     * @param length - The number of bytes to read\n     * @param position - The position in the file to read from (null for current position)\n     * @returns Promise that resolves to the number of bytes read and the modified buffer\n     * @throws {OPFSError} If the file descriptor is invalid or reading fails\n     * \n     * @note This method uses Comlink.transfer() to efficiently pass the buffer as a Transferable Object,\n     *       ensuring zero-copy performance across Web Worker boundaries.\n     * \n     * @example\n     * ```typescript\n     * const fd = await fs.open('/data/file.txt');\n     * const buffer = new Uint8Array(1024);\n     * const { bytesRead, buffer: modifiedBuffer } = await fs.read(fd, buffer, 0, 1024, null);\n     * console.log(`Read ${bytesRead} bytes`);\n     * // Use modifiedBuffer which contains the actual data\n     * await fs.close(fd);\n     * ```\n     */\n    async read(\n        fd: number,\n        buffer: Uint8Array,\n        offset: number,\n        length: number,\n        position: number | null | undefined\n    ): Promise<{ bytesRead: number; buffer: Uint8Array }> {\n        const fileInfo = this._getFileDescriptor(fd);\n\n        // Validate arguments\n        validateReadWriteArgs(buffer.length, offset, length, position);\n\n        try {\n            const readPosition = position ?? fileInfo.position;\n\n            // Get file size and calculate read length\n            const fileSize = fileInfo.syncHandle.getSize();\n            const { isEOF, actualLength } = calculateReadLength(readPosition, length, fileSize);\n\n            if (isEOF) {\n                return transfer({ bytesRead: 0, buffer }, [buffer.buffer]); // End of file\n            }\n\n            // Create a subarray view for the read operation\n            const targetBuffer = buffer.subarray(offset, offset + actualLength);\n\n            // Perform efficient positioned read\n            const bytesRead = fileInfo.syncHandle.read(targetBuffer, { at: readPosition });\n\n            // Update position if position was not explicitly specified (null means use current position)\n            if (position == null) {\n                fileInfo.position = readPosition + bytesRead;\n            }\n\n            return transfer({ bytesRead, buffer }, [buffer.buffer]);\n        }\n        catch (error) {\n            throw createFDError('read', fd, fileInfo.path, error);\n        }\n    }\n\n    /**\n     * Write data to a file descriptor\n     * \n     * @param fd - The file descriptor to write to\n     * @param buffer - The buffer containing data to write\n     * @param offset - The offset in the buffer to start reading from (default: 0)\n     * @param length - The number of bytes to write (default: entire buffer)\n     * @param position - The position in the file to write to (null/undefined for current position)\n     * @param emitEvent - Whether to emit a change event (default: true)\n     * @returns Promise that resolves to the number of bytes written\n     * @throws {OPFSError} If the file descriptor is invalid or writing fails\n     *\n     * @example\n     * ```typescript\n     * const fd = await fs.open('/data/file.txt', { create: true });\n     * const data = new TextEncoder().encode('Hello, World!');\n     * const bytesWritten = await fs.write(fd, data, 0, data.length, null);\n     * console.log(`Wrote ${bytesWritten} bytes`);\n     * await fs.close(fd);\n     * ```\n     */\n    async write(\n        fd: number,\n        buffer: Uint8Array,\n        offset: number = 0,\n        length?: number,\n        position?: number | null | undefined,\n        emitEvent: boolean = true\n    ): Promise<number> {\n        const fileInfo = this._getFileDescriptor(fd);\n\n        // Calculate actual length to write\n        const actualLength = length ?? (buffer.length - offset);\n\n        // Validate arguments using helper\n        validateReadWriteArgs(buffer.length, offset, actualLength, position);\n\n        try {\n            // Determine write position: use specified position, or current position if null/undefined\n            const writePosition = position ?? fileInfo.position;\n\n            // Create a subarray view for the write operation\n            const sourceBuffer = buffer.subarray(offset, offset + actualLength);\n\n            // Perform efficient positioned write\n            const bytesWritten = fileInfo.syncHandle.write(sourceBuffer, { at: writePosition });\n\n            // Update position if position was null or undefined (i.e., use current position)\n            // Also update position when writing at current position (position === fileInfo.position)\n            if (position == null || position === fileInfo.position) {\n                fileInfo.position = writePosition + bytesWritten;\n            }\n\n            if (emitEvent) {\n                await this.notifyChange({ path: fileInfo.path, type: WatchEventType.Changed, isDirectory: false });\n            }\n\n            return bytesWritten;\n        }\n        catch (error) {\n            throw createFDError('write', fd, fileInfo.path, error);\n        }\n    }\n\n    /**\n     * Get file status information by file descriptor\n     * \n     * @param fd - The file descriptor\n     * @returns Promise that resolves to FileStat object\n     * @throws {OPFSError} If the file descriptor is invalid\n     * \n     * @example\n     * ```typescript\n     * const fd = await fs.open('/data/file.txt');\n     * const stats = await fs.fstat(fd);\n     * console.log(`File size: ${stats.size} bytes`);\n     * console.log(`Last modified: ${stats.mtime}`);\n     * \n     * // If hashing is enabled, hash will be included\n     * if (stats.hash) {\n     *   console.log(`Hash: ${stats.hash}`);\n     * }\n     * ```\n     */\n    async fstat(fd: number): Promise<FileStat> {\n        const fileInfo = this._getFileDescriptor(fd);\n\n        // Simply reuse existing stat() method with the file path\n        return this.stat(fileInfo.path);\n    }\n\n    /**\n     * Truncate file to specified size\n     * \n     * @param fd - The file descriptor\n     * @param size - The new size of the file (default: 0)\n     * @returns Promise that resolves when truncation is complete\n     * @throws {OPFSError} If the file descriptor is invalid or truncation fails\n     * \n     * @example\n     * ```typescript\n     * const fd = await fs.open('/data/file.txt', { create: true });\n     * await fs.truncate(fd, 100); // Truncate to 100 bytes\n     * ```\n     */\n    async ftruncate(fd: number, size: number = 0): Promise<void> {\n        const fileInfo = this._getFileDescriptor(fd);\n\n        // Validate size parameter\n        if (size < 0 || !Number.isInteger(size)) {\n            throw new ValidationError('argument', 'Invalid size');\n        }\n\n        try {\n            fileInfo.syncHandle.truncate(size);\n            fileInfo.syncHandle.flush();\n\n            // Adjust position if it's beyond the new file size\n            if (fileInfo.position > size) {\n                fileInfo.position = size;\n            }\n\n            await this.notifyChange({ path: fileInfo.path, type: WatchEventType.Changed, isDirectory: false });\n        }\n        catch (error) {\n            throw createFDError('truncate', fd, fileInfo.path, error);\n        }\n    }\n\n    /**\n     * Synchronize file data to storage (fsync equivalent)\n     * \n     * @param fd - The file descriptor\n     * @returns Promise that resolves when synchronization is complete\n     * @throws {OPFSError} If the file descriptor is invalid or sync fails\n     * \n     * @example\n     * ```typescript\n     * const fd = await fs.open('/data/file.txt', { create: true });\n     * await fs.write(fd, data);\n     * await fs.fsync(fd); // Ensure data is written to storage\n     * ```\n     */\n    async fsync(fd: number): Promise<void> {\n        const fileInfo = this._getFileDescriptor(fd);\n\n        try {\n            fileInfo.syncHandle.flush();\n        }\n        catch (error) {\n            throw createFDError('sync', fd, fileInfo.path, error);\n        }\n    }\n\n    /**\n     * Dispose of resources and clean up the file system instance\n     * \n     * This method should be called when the file system instance is no longer needed\n     * to properly clean up resources like the broadcast channel and watch timers.\n     */\n    dispose(): void {\n        if (this.broadcastChannel) {\n            this.broadcastChannel.close();\n            this.broadcastChannel = null;\n        }\n\n        this.watchers.clear();\n\n        // Close all open file descriptors\n        for (const [fd, fileInfo] of this.openFiles) {\n            safeCloseSyncHandle(fd, fileInfo.syncHandle, fileInfo.path);\n        }\n\n        this.openFiles.clear();\n        this.nextFd = 1;\n    }\n\n    /**\n     * Synchronize the file system with external data\n     * \n     * Syncs the file system with an array of entries containing paths and data.\n     * This is useful for importing data from external sources or syncing with remote data.\n     * \n     * @param entries - Array of [path, data] tuples to sync\n     * @param options - Options for synchronization\n     * @param options.cleanBefore - Whether to clear the file system before syncing (default: false)\n     * @returns Promise that resolves when synchronization is complete\n     * @throws {OPFSError} If the synchronization fails\n     * \n     * @example\n     * ```typescript\n     * // Sync with external data\n     * const entries: [string, string | Uint8Array | Blob][] = [\n     *   ['/config.json', JSON.stringify({ theme: 'dark' })],\n     *   ['/data/binary.dat', new Uint8Array([1, 2, 3, 4])],\n     *   ['/upload.txt', new Blob(['file content'], { type: 'text/plain' })]\n     * ];\n     * \n     * // Sync without clearing existing files\n     * await fs.sync(entries);\n     * \n     * // Clean file system and then sync\n     * await fs.sync(entries, { cleanBefore: true });\n     * ```\n     */\n    async createIndex(entries: [string, string | Uint8Array | Blob][]): Promise<void> {\n        await this.mount();\n\n        try {\n            for (const [path, data] of entries) {\n                const normalizedPath = normalizePath(path);\n\n                let fileData: Uint8Array;\n\n                if (data instanceof Blob) {\n                    fileData = await convertBlobToUint8Array(data);\n                }\n                else if (typeof data === 'string') {\n                    // Convert string to Uint8Array using UTF-8 encoding\n                    fileData = new TextEncoder().encode(data);\n                }\n                else {\n                    fileData = data;\n                }\n\n                await this.writeFile(normalizedPath, fileData);\n            }\n        }\n        catch (error) {\n            if (error instanceof OPFSError) {\n                throw error;\n            }\n\n            throw mapDomError(error);\n        }\n    }\n}\n\n// Only expose the worker when running in a Web Worker environment\nif (typeof globalThis !== 'undefined' && globalThis.constructor.name === 'DedicatedWorkerGlobalScope') {\n    expose(new OPFSWorker());\n}\n"],"names":["OPFSWorker","fd","fileInfo","ValidationError","event","path","snapshot","matchMinimatch","include","exclude","hash","watchEvent","error","options","checkOPFSSupport","root","resolve","reject","rootDir","InitializationFailedError","normalizePath","create","from","segments","splitPath","current","segment","_from","PathError","fileName","result","walk","dirPath","items","item","fullPath","stat","err","withLock","size","buffer","transfer","ExistenceError","data","existed","WatchEventType","recursive","i","joinPath","FileTypeError","FileSystemOperationError","name","basename","parentDir","dirname","hashAlgorithm","file","baseStat","calculateFileHash","e","dir","results","handle","isFile","itemPath","OPFSError","mapDomError","DirectoryOperationError","force","parent","removeEntry","normalizedPath","resolvePath","oldPath","newPath","overwrite","sourceStat","AlreadyExistsError","source","destination","content","sourceItemPath","destItemPath","OperationNotSupportedError","normalizeMinimatch","exclusive","truncate","fileHandle","syncHandle","createSyncHandleSafe","safeCloseSyncHandle","offset","length","position","validateReadWriteArgs","readPosition","fileSize","isEOF","actualLength","calculateReadLength","targetBuffer","bytesRead","createFDError","emitEvent","writePosition","sourceBuffer","bytesWritten","entries","fileData","convertBlobToUint8Array","expose"],"mappings":"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"}