import type { BinaryEncoding, DirentData, Encoding, FileOpenOptions, FileStat, OPFSOptions, PathLike, RenameOptions, StringEncoding, WatchOptions } from './types';
/**
 * Facade class that provides a clean interface for communicating with the OPFS worker
 * while hiding Comlink implementation details.
 */
export declare class OPFSFileSystem {
    #private;
    promises: OPFSFileSystem;
    constructor(options?: OPFSOptions);
    /**
     * Start watching a file or directory for changes
     */
    watch(path: PathLike, options?: WatchOptions): () => void;
    /**
     * Stop watching a previously watched path
     */
    unwatch(path: PathLike): void;
    /**
     * Update configuration options
     */
    setOptions(options: OPFSOptions): Promise<void>;
    /**
     * Get a complete index of all files and directories in the file system
     */
    index(): Promise<Map<string, FileStat>>;
    /**
     * Read a file from the file system
     */
    readFile(path: PathLike, encoding: StringEncoding): Promise<string>;
    readFile(path: PathLike, encoding: BinaryEncoding): Promise<Uint8Array>;
    readFile(path: PathLike, options: {
        encoding: StringEncoding;
    }): Promise<string>;
    readFile(path: PathLike, options: {
        encoding: BinaryEncoding;
    }): Promise<Uint8Array>;
    readFile(path: PathLike): Promise<string | Uint8Array>;
    /**
     * Write data to a file
     */
    writeFile(path: PathLike, data: string | Uint8Array | ArrayBuffer, options?: {
        encoding?: Encoding;
    } | Encoding): Promise<void>;
    /**
     * Append data to a file
     */
    appendFile(path: PathLike, data: string | Uint8Array | ArrayBuffer, encoding?: Encoding): Promise<void>;
    /**
     * Create a directory
     */
    mkdir(path: PathLike, mode?: number | {
        recursive?: boolean;
    }): Promise<void>;
    /**
     * Get file or directory statistics
     */
    stat(path: PathLike): Promise<FileStat>;
    /**
     * Read a directory's contents
     */
    readDir(path: PathLike): Promise<DirentData[]>;
    /**
     * Check if a file or directory exists
     */
    exists(path: PathLike): Promise<boolean>;
    /**
     * Clear all contents of a directory without removing the directory itself
     */
    clear(path?: PathLike): Promise<void>;
    /**
     * Remove files and directories
     */
    remove(path: PathLike, options?: {
        recursive?: boolean;
        force?: boolean;
    }): Promise<void>;
    /**
     * Alias for remove() for NodeJS like API compatibility
     */
    unlink(path: PathLike): Promise<void>;
    /**
     * Alias for remove() for NodeJS like API compatibility
     */
    rm(path: PathLike, options?: {
        recursive?: boolean;
        force?: boolean;
    }): Promise<void>;
    /**
     * Alias for remove() for NodeJS like API compatibility
     */
    rmdir(path: PathLike): Promise<void>;
    /**
     * Alias for readDir() for NodeJS like API compatibility
     */
    readdir(path: PathLike, _options?: unknown): Promise<DirentData[]>;
    /**
     * Alias for stat() for NodeJS like API compatibility
     */
    lstat(path: PathLike): Promise<FileStat>;
    /**
     * Note: OPFS doesn't support file modes, so this is a no-op and exists only for compatibility with tools like isomorphic-git
     */
    chmod(_path: PathLike, _mode: number): Promise<void>;
    /**
     * Resolve a path to an absolute path
     */
    realpath(path: PathLike): Promise<string>;
    /**
     * Rename a file or directory
     */
    rename(oldPath: PathLike, newPath: PathLike, options?: RenameOptions): Promise<void>;
    /**
     * Copy files and directories
     */
    copy(source: PathLike, destination: PathLike, options?: {
        recursive?: boolean;
        overwrite?: boolean;
    }): Promise<void>;
    /**
     * Open a file and return a file descriptor
     */
    open(path: PathLike, options?: FileOpenOptions): Promise<number>;
    /**
     * Close a file descriptor
     */
    close(fd: number): Promise<void>;
    /**
     * Read data from a file descriptor
     *
     * This method requires special handling due to Comlink transfer requirements.
     * The buffer is transferred to the worker and back, so the original buffer
     * becomes unusable after the call.
     */
    read(fd: number, buffer: Uint8Array, offset: number, length: number, position?: number | null | undefined): Promise<{
        bytesRead: number;
        buffer: Uint8Array;
    }>;
    /**
     * Write data to a file descriptor
     */
    write(fd: number, buffer: Uint8Array, offset?: number, length?: number, position?: number | null | undefined, emitEvent?: boolean): Promise<number>;
    /**
     * Get file status information by file descriptor
     */
    fstat(fd: number): Promise<FileStat>;
    /**
     * Truncate file to specified size
     */
    ftruncate(fd: number, size?: number): Promise<void>;
    /**
     * Synchronize file data to storage (fsync equivalent)
     */
    fsync(fd: number): Promise<void>;
    /**
     * Dispose of resources and clean up the file system instance
     */
    dispose(): void;
    /**
     * Synchronize the file system with external data
     */
    createIndex(entries: [PathLike, string | Uint8Array | Blob][]): Promise<void>;
    /**
     * Read a file as text with automatic encoding detection
     */
    readText(path: PathLike, encoding?: Encoding): Promise<string>;
    /**
     * Write text to a file with specified encoding
     */
    writeText(path: PathLike, text: string, encoding?: Encoding): Promise<void>;
    /**
     * Append text to a file with specified encoding
     */
    appendText(path: PathLike, text: string, encoding?: Encoding): Promise<void>;
}
//# sourceMappingURL=facade.d.ts.map