"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const f=require("comlink"),i=require("./helpers-CIiblZ8d.cjs");class d{root;watchers=new Map;mountingPromise=null;broadcastChannel=null;options={root:"/",namespace:"",maxFileSize:50*1024*1024,hashAlgorithm:"etag",broadcastChannel:"opfs-worker"};openFiles=new Map;nextFd=1;_getFileDescriptor(t){const e=this.openFiles.get(t);if(!e)throw new i.ValidationError("descriptor",`Invalid file descriptor: ${t}`);return e}async notifyChange(t){if(!this.options.broadcastChannel)return;const e=t.path;if(![...this.watchers.values()].some(s=>i.matchMinimatch(e,s.pattern)&&s.include.some(n=>n&&i.matchMinimatch(e,n))&&!s.exclude.some(n=>n&&i.matchMinimatch(e,n))))return;let r;if(this.options.hashAlgorithm)try{r=(await this.stat(e)).hash}catch{}try{this.broadcastChannel||(this.broadcastChannel=new BroadcastChannel(this.options.broadcastChannel));const s={namespace:this.options.namespace,timestamp:new Date().toISOString(),...t,...r&&{hash:r}};this.broadcastChannel.postMessage(s)}catch(s){console.warn("Failed to send event via BroadcastChannel:",s)}}constructor(t){i.checkOPFSSupport(),t&&this.setOptions(t)}async mount(){const t=this.options.root;return this.mountingPromise&&await this.mountingPromise,this.mountingPromise=new Promise(async(e,a)=>{try{const r=await navigator.storage.getDirectory();this.root=t==="/"?r:await this.getDirectoryHandle(t,!0,r),e(!0)}catch(r){a(new i.InitializationFailedError(t,r))}finally{this.mountingPromise=null}}),this.mountingPromise}async setOptions(t){t.hashAlgorithm!==void 0&&(this.options.hashAlgorithm=t.hashAlgorithm),t.maxFileSize!==void 0&&(this.options.maxFileSize=t.maxFileSize),t.broadcastChannel!==void 0&&(this.broadcastChannel&&this.options.broadcastChannel!==t.broadcastChannel&&(this.broadcastChannel.close(),this.broadcastChannel=null),this.options.broadcastChannel=t.broadcastChannel),t.namespace&&(this.options.namespace=t.namespace),t.root!==void 0&&(this.options.root=i.normalizePath(t.root),this.options.namespace||(this.options.namespace=`opfs-worker:${this.options.root}`),await this.mount())}async getDirectoryHandle(t,e=!1,a=this.root){const r=Array.isArray(t)?t:i.splitPath(t);let s=a;for(const n of r)s=await s.getDirectoryHandle(n,{create:e});return s}async getFileHandle(t,e=!1,a=this.root){const r=i.splitPath(t);if(r.length===0)throw new i.PathError("Path must not be empty",Array.isArray(t)?t.join("/"):t);const s=r.pop();return(await this.getDirectoryHandle(r,e,a)).getFileHandle(s,{create:e})}async index(){const t=new Map,e=async a=>{const r=await this.readDir(a);for(const s of r){const n=`${a==="/"?"":a}/${s.name}`;try{const o=await this.stat(n);t.set(n,o),o.isDirectory&&await e(n)}catch(o){console.warn(`Skipping broken entry: ${n}`,o)}}};return t.set("/",{kind:"directory",size:0,mtime:new Date(0).toISOString(),ctime:new Date(0).toISOString(),isFile:!1,isDirectory:!0}),await e("/"),t}async readFile(t){await this.mount();try{return await i.withLock(t,"shared",async()=>{const e=await this.open(t);try{const{size:a}=await this.fstat(e),r=new Uint8Array(a);return a>0&&await this.read(e,r,0,a,0),f.transfer(r,[r.buffer])}finally{await this.close(e)}})}catch(e){throw new i.ExistenceError("file",t,e)}}async writeFile(t,e){await this.mount();const a=e instanceof Uint8Array?e:new Uint8Array(e);await i.withLock(t,"exclusive",async()=>{const r=await this.exists(t),s=await this.open(t,{create:!0,truncate:!0});try{await this.write(s,a,0,a.length,null,!1),await this.fsync(s)}finally{await this.close(s)}await this.notifyChange({path:t,type:r?i.WatchEventType.Changed:i.WatchEventType.Added,isDirectory:!1})})}async appendFile(t,e){await this.mount();const a=e instanceof Uint8Array?e:new Uint8Array(e);await i.withLock(t,"exclusive",async()=>{const r=await this.open(t,{create:!0});try{const{size:s}=await this.fstat(r);await this.write(r,a,0,a.length,s,!1),await this.fsync(r)}finally{await this.close(r)}await this.notifyChange({path:t,type:i.WatchEventType.Changed,isDirectory:!1})})}async mkdir(t,e){await this.mount();const a=e?.recursive??!1,r=i.splitPath(t);let s=this.root;for(let n=0;n<r.length;n++){const o=r[n];try{s=await s.getDirectoryHandle(o,{create:a||n===r.length-1})}catch(c){throw c.name==="NotFoundError"?new i.ExistenceError("directory",i.joinPath(r.slice(0,n+1)),c):c.name==="TypeMismatchError"?new i.FileTypeError("file",o,c):new i.FileSystemOperationError("create directory",o,c)}}await this.notifyChange({path:t,type:i.WatchEventType.Added,isDirectory:!0})}async stat(t){if(await this.mount(),t==="/")return{kind:"directory",size:0,mtime:new Date(0).toISOString(),ctime:new Date(0).toISOString(),isFile:!1,isDirectory:!0};const e=i.basename(t);let a;try{a=await this.getDirectoryHandle(i.dirname(t),!1);const r=this.options.hashAlgorithm,n=await(await a.getFileHandle(e,{create:!1})).getFile(),o={kind:"file",size:n.size,mtime:new Date(n.lastModified).toISOString(),ctime:new Date(n.lastModified).toISOString(),isFile:!0,isDirectory:!1};if(r==="etag")o.hash=`${n.lastModified.toString(36)}-${n.size.toString(36)}`;else if(typeof r=="string")try{const c=await i.calculateFileHash(n,r,this.options.maxFileSize);o.hash=c}catch(c){console.warn(`Failed to calculate hash for ${t}:`,c)}return o}catch(r){if(r.name==="NotFoundError")throw new i.ExistenceError("file",t,r);if(r.name!=="TypeMismatchError")throw new i.FileSystemOperationError("stat",t,r)}try{return await a.getDirectoryHandle(e,{create:!1}),{kind:"directory",size:0,mtime:new Date(0).toISOString(),ctime:new Date(0).toISOString(),isFile:!1,isDirectory:!0}}catch(r){throw new i.FileSystemOperationError("stat",t,r)}}async readDir(t){await this.mount();const e=await this.getDirectoryHandle(t,!1),a=[];for await(const[r,s]of e.entries()){const n=s.kind==="file";a.push({name:r,kind:s.kind,isFile:n,isDirectory:!n})}return a}async exists(t){if(await this.mount(),t==="/")return!0;const e=i.basename(t);let a=null;try{a=await this.getDirectoryHandle(i.dirname(t),!1)}catch(r){if(a=null,r.name!=="NotFoundError"&&r.name!=="TypeMismatchError")throw r}if(!a||!e)return!1;try{return await a.getFileHandle(e,{create:!1}),!0}catch(r){if(r.name!=="NotFoundError"&&r.name!=="TypeMismatchError")throw r;try{return await a.getDirectoryHandle(e,{create:!1}),!0}catch(s){if(s.name!=="NotFoundError"&&s.name!=="TypeMismatchError")throw s;return!1}}}async clear(t="/"){await this.mount();try{const e=await this.readDir(t);for(const a of e){const r=`${t==="/"?"":t}/${a.name}`;await this.remove(r,{recursive:!0})}await this.notifyChange({path:t,type:i.WatchEventType.Changed,isDirectory:!0})}catch(e){throw e instanceof i.OPFSError?e:i.mapDomError(e,{path:t,isDirectory:!0})}}async remove(t,e){if(await this.mount(),t==="/")throw new i.DirectoryOperationError("EROOT",t);const{recursive:a=!1,force:r=!1}=e||{},s=await this.getDirectoryHandle(i.dirname(t),!1),n=await this.stat(t);await i.removeEntry(s,t,{recursive:a,force:r}),await this.notifyChange({path:t,type:i.WatchEventType.Removed,isDirectory:n.isDirectory})}async realpath(t){await this.mount();try{const e=i.resolvePath(t);if(!await this.exists(e))throw new i.ExistenceError("file",e);return e}catch(e){throw e instanceof i.OPFSError?e:i.mapDomError(e,{path:t})}}async rename(t,e,a){await this.mount();try{const r=a?.overwrite??!1,s=await this.stat(t);if(await this.exists(e)&&!r)throw new i.AlreadyExistsError(e);await this.copy(t,e,{recursive:!0,overwrite:r}),await this.remove(t,{recursive:!0}),await this.notifyChange({path:t,type:i.WatchEventType.Removed,isDirectory:s.isDirectory}),await this.notifyChange({path:e,type:i.WatchEventType.Added,isDirectory:s.isDirectory})}catch(r){throw r instanceof i.OPFSError?r:i.mapDomError(r,{path:t})}}async copy(t,e,a){await this.mount();try{const r=a?.recursive??!1,s=a?.overwrite??!0;if(!await this.exists(t))throw new i.ExistenceError("source",t);if(await this.exists(e)&&!s)throw new i.AlreadyExistsError(e);if((await this.stat(t)).isFile){const h=await this.readFile(t);await this.writeFile(e,h)}else{if(!r)throw new i.FileTypeError("directory",t);await this.mkdir(e,{recursive:!0});const h=await this.readDir(t);for(const l of h){const w=`${t}/${l.name}`,y=`${e}/${l.name}`;await this.copy(w,y,{recursive:!0,overwrite:s})}}}catch(r){throw r instanceof i.OPFSError?r:i.mapDomError(r,{path:t})}}async watch(t,e){if(!this.options.broadcastChannel)throw new i.OperationNotSupportedError("This instance is not configured to send events. Please specify options.broadcastChannel to enable watching.");const a={pattern:i.normalizeMinimatch(t,e?.recursive??!0),include:Array.isArray(e?.include)?e.include:[e?.include??"**"],exclude:Array.isArray(e?.exclude)?e.exclude:[e?.exclude??""]};this.watchers.set(t,a)}unwatch(t){this.watchers.delete(t)}async open(t,e){await this.mount();const{create:a=!1,exclusive:r=!1,truncate:s=!1}=e||{},n=i.normalizePath(i.resolvePath(t));try{return a&&r?await i.withLock(n,"exclusive",async()=>{if(await this.exists(n))throw new i.AlreadyExistsError(n);return this._openFile(n,a,s)}):await this._openFile(n,a,s)}catch(o){throw o instanceof i.OPFSError?o:i.mapDomError(o,{path:n,isDirectory:!1})}}async _openFile(t,e,a){const r=await this.getFileHandle(t,e);try{await r.getFile()}catch(o){throw i.mapDomError(o,{path:t,isDirectory:!0})}const s=await i.createSyncHandleSafe(r,t);a&&(s.truncate(0),s.flush());const n=this.nextFd++;return this.openFiles.set(n,{path:t,fileHandle:r,syncHandle:s,position:0}),n}async close(t){const e=this._getFileDescriptor(t);i.safeCloseSyncHandle(t,e.syncHandle,e.path),this.openFiles.delete(t)}async read(t,e,a,r,s){const n=this._getFileDescriptor(t);i.validateReadWriteArgs(e.length,a,r,s);try{const o=s??n.position,c=n.syncHandle.getSize(),{isEOF:h,actualLength:l}=i.calculateReadLength(o,r,c);if(h)return f.transfer({bytesRead:0,buffer:e},[e.buffer]);const w=e.subarray(a,a+l),y=n.syncHandle.read(w,{at:o});return s==null&&(n.position=o+y),f.transfer({bytesRead:y,buffer:e},[e.buffer])}catch(o){throw i.createFDError("read",t,n.path,o)}}async write(t,e,a=0,r,s,n=!0){const o=this._getFileDescriptor(t),c=r??e.length-a;i.validateReadWriteArgs(e.length,a,c,s);try{const h=s??o.position,l=e.subarray(a,a+c),w=o.syncHandle.write(l,{at:h});return(s==null||s===o.position)&&(o.position=h+w),n&&await this.notifyChange({path:o.path,type:i.WatchEventType.Changed,isDirectory:!1}),w}catch(h){throw i.createFDError("write",t,o.path,h)}}async fstat(t){const e=this._getFileDescriptor(t);return this.stat(e.path)}async ftruncate(t,e=0){const a=this._getFileDescriptor(t);if(e<0||!Number.isInteger(e))throw new i.ValidationError("argument","Invalid size");try{a.syncHandle.truncate(e),a.syncHandle.flush(),a.position>e&&(a.position=e),await this.notifyChange({path:a.path,type:i.WatchEventType.Changed,isDirectory:!1})}catch(r){throw i.createFDError("truncate",t,a.path,r)}}async fsync(t){const e=this._getFileDescriptor(t);try{e.syncHandle.flush()}catch(a){throw i.createFDError("sync",t,e.path,a)}}dispose(){this.broadcastChannel&&(this.broadcastChannel.close(),this.broadcastChannel=null),this.watchers.clear();for(const[t,e]of this.openFiles)i.safeCloseSyncHandle(t,e.syncHandle,e.path);this.openFiles.clear(),this.nextFd=1}async createIndex(t){await this.mount();try{for(const[e,a]of t){const r=i.normalizePath(e);let s;a instanceof Blob?s=await i.convertBlobToUint8Array(a):typeof a=="string"?s=new TextEncoder().encode(a):s=a,await this.writeFile(r,s)}}catch(e){throw e instanceof i.OPFSError?e:i.mapDomError(e)}}}typeof globalThis<"u"&&globalThis.constructor.name==="DedicatedWorkerGlobalScope"&&f.expose(new d);exports.OPFSWorker=d;
//# sourceMappingURL=raw.cjs.map
