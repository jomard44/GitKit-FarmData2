{"version":3,"file":"helpers-CIiblZ8d.cjs","sources":["../src/utils/errors.ts","../src/utils/encoder.ts","../src/types.ts","../node_modules/@isaacs/balanced-match/dist/esm/index.js","../node_modules/@isaacs/brace-expansion/dist/esm/index.js","../node_modules/minimatch/dist/esm/assert-valid-pattern.js","../node_modules/minimatch/dist/esm/brace-expressions.js","../node_modules/minimatch/dist/esm/unescape.js","../node_modules/minimatch/dist/esm/ast.js","../node_modules/minimatch/dist/esm/escape.js","../node_modules/minimatch/dist/esm/index.js","../src/utils/helpers.ts"],"sourcesContent":["/**\n * Error code to numeric errno mapping (Node.js compatible)\n */\nconst ERROR_CODE_TO_ERRNO: Record<string, number> = {\n    ENOENT: -2, // No such file or directory\n    EISDIR: -21, // Is a directory\n    ENOTDIR: -20, // Not a directory\n    EACCES: -13, // Permission denied\n    EEXIST: -17, // File exists\n    ENOTEMPTY: -39, // Directory not empty\n    EINVAL: -22, // Invalid argument\n    EIO: -5, // I/O error\n    ENOSPC: -28, // No space left on device\n    EBUSY: -16, // Device or resource busy\n    EINTR: -4, // Interrupted system call\n    ENOTSUP: -95, // Operation not supported\n    ERANGE: -34, // Result too large\n    EBADF: -9, // Bad file descriptor\n    EROOT: -1, // Custom: Cannot remove root directory\n};\n\n/**\n * Base error class for all OPFS-related errors (Node.js SystemError compatible)\n */\nexport class OPFSError extends Error {\n    public readonly errno: number;\n    public readonly syscall?: string;\n    public readonly path?: string;\n\n    constructor(\n        message: string,\n        code: string,\n        path?: string,\n        syscall?: string,\n        cause?: any\n    ) {\n        super(message, { cause });\n        this.name = code;\n        this.errno = ERROR_CODE_TO_ERRNO[code] || -1;\n        this.path = path;\n        this.syscall = syscall;\n    }\n}\n\n/**\n * Error thrown when OPFS is not supported in the current browser\n */\nexport class OPFSNotSupportedError extends OPFSError {\n    constructor(cause?: unknown) {\n        super('OPFS is not supported in this browser', 'ENOTSUP', undefined, undefined, cause);\n    }\n}\n\n/**\n * Error thrown for invalid paths or path traversal attempts\n */\nexport class PathError extends OPFSError {\n    constructor(message: string, path: string, cause?: unknown) {\n        super(message, 'INVALID_PATH', path, 'access', cause);\n    }\n}\n\n/**\n * Error thrown when files or directories don't exist\n */\nexport class ExistenceError extends OPFSError {\n    constructor(type: 'file' | 'directory' | 'source', path: string, cause?: unknown) {\n        const messages = {\n            file: `File not found: ${ path }`,\n            directory: `Directory not found: ${ path }`,\n            source: `Source does not exist: ${ path }`,\n        };\n\n        super(messages[type], 'ENOENT', path, 'access', cause);\n    }\n}\n\n/**\n * Error thrown when permission is denied for an operation\n */\nexport class PermissionError extends OPFSError {\n    constructor(path: string, operation: string, cause?: unknown) {\n        super(`Permission denied for ${ operation } on: ${ path }`, 'EACCES', path, operation, cause);\n    }\n}\n\n/**\n * Error thrown when an operation fails due to insufficient storage\n */\nexport class StorageError extends OPFSError {\n    constructor(message: string, path?: string, cause?: unknown) {\n        super(message, 'ENOSPC', path, 'write', cause);\n    }\n}\n\n/**\n * Error thrown when a file is busy (locked by another operation)\n */\nexport class FileBusyError extends OPFSError {\n    constructor(path: string, cause?: unknown) {\n        super(`File is busy: ${ path }`, 'EBUSY', path, 'open', cause);\n    }\n}\n\n/**\n * Error thrown when file/directory type expectations don't match\n */\nexport class FileTypeError extends OPFSError {\n    constructor(actualType: 'file' | 'directory', path: string, cause?: unknown) {\n        const message = actualType === 'directory'\n            ? `Is a directory: ${ path }`\n            : `Not a directory: ${ path }`;\n        const code = actualType === 'directory' ? 'EISDIR' : 'ENOTDIR';\n\n        super(message, code, path, 'access', cause);\n    }\n}\n\n/**\n * Error thrown for validation failures (invalid arguments, formats, etc.)\n */\nexport class ValidationError extends OPFSError {\n    constructor(type: 'argument' | 'format' | 'descriptor' | 'overflow', message: string, path?: string, cause?: unknown) {\n        const codes = {\n            argument: 'EINVAL',\n            format: 'INVALID_FORMAT',\n            descriptor: 'EBADF',\n            overflow: 'ERANGE',\n        };\n\n        super(message, codes[type], path, 'validate', cause);\n    }\n}\n\n/**\n * Error thrown when an operation is aborted\n */\nexport class OperationAbortedError extends OPFSError {\n    constructor(path: string, cause?: unknown) {\n        super(`Operation aborted: ${ path }`, 'EINTR', path, 'interrupt', cause);\n    }\n}\n\n/**\n * Error thrown for I/O operation failures\n */\nexport class IOError extends OPFSError {\n    constructor(message: string, path?: string, cause?: unknown) {\n        super(message, 'EIO', path, 'io', cause);\n    }\n}\n\n/**\n * Error thrown when an operation is not supported\n */\nexport class OperationNotSupportedError extends OPFSError {\n    constructor(path: string, cause?: unknown) {\n        super(`Operation not supported: ${ path }`, 'ENOTSUP', path, 'operation', cause);\n    }\n}\n\n/**\n * Error thrown when directory operations fail\n */\nexport class DirectoryOperationError extends OPFSError {\n    constructor(code: string, path: string, cause?: unknown) {\n        const messages = {\n            RM_FAILED: `Failed to remove entry: ${ path }`,\n            ENOTEMPTY: `Directory not empty: ${ path }. Use recursive option to force removal.`,\n            EROOT: 'Cannot remove root directory',\n        };\n\n        super(messages[code as keyof typeof messages] || `Directory operation failed: ${ path }`, code, path, 'unlink', cause);\n    }\n}\n\n\n/**\n * Error thrown when OPFS initialization fails\n */\nexport class InitializationFailedError extends OPFSError {\n    constructor(path: string, cause?: unknown) {\n        super('Failed to initialize OPFS', 'INIT_FAILED', path, 'init', cause);\n    }\n}\n\n/**\n * Error thrown when file system operations fail\n */\nexport class FileSystemOperationError extends OPFSError {\n    constructor(operation: string, path: string, cause?: unknown) {\n        super(`Failed to ${ operation }: ${ path }`, `${ operation.toUpperCase() }_FAILED`, path, operation, cause);\n    }\n}\n\n/**\n * Error thrown when a file or directory already exists\n */\nexport class AlreadyExistsError extends OPFSError {\n    constructor(path: string, cause?: unknown) {\n        super(`Destination already exists: ${ path }`, 'EEXIST', path, 'open', cause);\n    }\n}\n\n/**\n * Create an OPFSError with file descriptor context\n * \n * @param operation - The operation that failed (e.g., 'read', 'write', 'close')\n * @param fd - The file descriptor number\n * @param path - The file path\n * @param error - The underlying error (optional)\n * @returns OPFSError with appropriate context\n */\nexport function createFDError(operation: string, fd: number, path: string, error?: any): OPFSError {\n    const errorCode = `${ operation.toUpperCase() }_FAILED` as 'READ_FAILED' | 'WRITE_FAILED' | 'CLOSE_FAILED';\n\n    return new OPFSError(`Failed to ${ operation } file descriptor: ${ fd }`, errorCode, path, operation, error);\n}\n\n/**\n * Map DOM exceptions to OPFS error codes\n * \n * @param error - The DOM exception to map\n * @param context - Context information for better error mapping\n * @param context.path - File path for context-specific errors\n * @param context.isDirectory - Whether the operation involves a directory\n * @returns OPFSError with appropriate error code\n */\nexport function mapDomError(error: any, context?: { path?: string; isDirectory?: boolean }): OPFSError {\n    const path = context?.path;\n    const isDirectory = context?.isDirectory;\n\n    switch (error.name) {\n        case 'InvalidStateError':\n            return new FileBusyError(path || 'unknown', error);\n\n        case 'QuotaExceededError':\n            return new StorageError(`No space left on device: ${ path || 'unknown' }`, path, error);\n\n        case 'NotFoundError':\n            return new ExistenceError('file', path!, error);\n\n        case 'TypeMismatchError':\n            if (isDirectory !== undefined) {\n                if (isDirectory) {\n                    return new FileTypeError('directory', path || 'unknown', error);\n                }\n                else {\n                    return new FileTypeError('file', path || 'unknown', error);\n                }\n            }\n\n            // Fall through to default for ambiguous cases\n            return new ValidationError('argument', `Type mismatch: ${ path || 'unknown' }`, path, error);\n\n        case 'NotAllowedError':\n        case 'SecurityError':\n            return new PermissionError(path!, 'unknown', error);\n\n        case 'InvalidModificationError':\n            return new ValidationError('argument', `Invalid modification: ${ path || 'unknown' }`, path, error);\n\n        case 'AbortError':\n            return new OperationAbortedError(path || 'unknown', error);\n\n        case 'OperationError':\n            return new IOError(`Operation failed: ${ path || 'unknown' }`, path, error);\n\n        case 'TypeError':\n            return new OperationNotSupportedError(path || 'unknown', error);\n\n        default:\n            return new IOError(`I/O error: ${ path || 'unknown' }`, path, error);\n    }\n}\n","import { ValidationError } from './errors';\n\nimport type { Encoding } from '../types';\n\n\n/**\n * Common binary file extensions\n */\nexport const BINARY_FILE_EXTENSIONS = [\n    // Images\n    '.jpg',\n    '.jpeg',\n    '.png',\n    '.gif',\n    '.bmp',\n    '.webp',\n    '.ico',\n    '.tiff',\n    '.tga',\n    // Audio\n    '.mp3',\n    '.wav',\n    '.ogg',\n    '.flac',\n    '.aac',\n    '.wma',\n    '.m4a',\n    // Video\n    '.mp4',\n    '.avi',\n    '.mov',\n    '.wmv',\n    '.flv',\n    '.webm',\n    '.mkv',\n    '.m4v',\n    // Documents\n    '.pdf',\n    '.doc',\n    '.docx',\n    '.xls',\n    '.xlsx',\n    '.ppt',\n    '.pptx',\n    // Archives\n    '.zip',\n    '.rar',\n    '.7z',\n    '.tar',\n    '.gz',\n    '.bz2',\n    // Executables\n    '.exe',\n    '.dll',\n    '.so',\n    '.dylib',\n    // Other binary formats\n    '.dat',\n    '.db',\n    '.sqlite',\n    '.bin',\n    '.obj',\n    '.fbx',\n    '.3ds',\n] as const;\n\n/**\n * Check if a file extension indicates a binary file\n * \n * @param path - The file path or filename\n * @returns True if the file extension suggests binary content\n * \n * @example\n * ```typescript\n * isBinaryFileExtension('/path/to/image.jpg'); // true\n * isBinaryFileExtension('/path/to/document.txt'); // false\n * isBinaryFileExtension('data.bin'); // true\n * isBinaryFileExtension('data'); // true\n * ```\n */\nexport function isBinaryFileExtension(path: string): boolean {\n    const i = path.lastIndexOf('.');\n\n    if (i <= 0) {\n        return true;\n    }\n\n    const ext = path.slice(i).toLowerCase();\n\n    return BINARY_FILE_EXTENSIONS.includes(ext as any);\n}\n\nexport function encodeString(data: string, encoding: Encoding = 'utf-8'): Uint8Array {\n    switch (encoding) {\n        case 'utf8':\n        case 'utf-8':\n            return new TextEncoder().encode(data);\n\n        case 'utf16le':\n        case 'utf-16le':\n        case 'ucs2':\n        case 'ucs-2':\n            return encodeUtf16LE(data);\n\n        case 'ascii':\n            return encodeAscii(data);\n\n        case 'latin1':\n            return encodeLatin1(data);\n\n        case 'binary':\n            return Uint8Array.from(data, char => char.charCodeAt(0));\n\n        case 'base64':\n            return Uint8Array.from(atob(data), c => c.charCodeAt(0));\n\n        case 'hex':\n            if (!/^[\\da-f]+$/i.test(data) || data.length % 2 !== 0) {\n                throw new ValidationError('format', 'Invalid hex string');\n            }\n\n            return Uint8Array.from(data.match(/.{1,2}/g)!.map(b => parseInt(b, 16)));\n\n        default:\n            console.warn('Encoding not supported, falling back to UTF-8');\n\n            return new TextEncoder().encode(data);\n    }\n}\n\nexport function decodeBuffer(buffer: Uint8Array, encoding: Encoding = 'utf-8'): string {\n    // eslint-disable-next-line ts/switch-exhaustiveness-check\n    switch (encoding) {\n        case 'utf8':\n        case 'utf-8':\n            return new TextDecoder().decode(buffer);\n\n        case 'utf16le':\n        case 'utf-16le':\n        case 'ucs2':\n        case 'ucs-2':\n            return decodeUtf16LE(buffer);\n\n        case 'latin1':\n            return String.fromCharCode(...buffer);\n\n        case 'ascii':\n            return String.fromCharCode(...buffer.map(b => b & 0x7F));\n\n        case 'base64':\n            return btoa(String.fromCharCode(...buffer));\n\n        case 'hex':\n            return Array.from(buffer).map(b => b.toString(16).padStart(2, '0')).join('');\n\n        default:\n            console.warn('Unsupported encoding, falling back to UTF-8');\n\n            return new TextDecoder().decode(buffer);\n    }\n}\n\nfunction encodeUtf16LE(str: string): Uint8Array {\n    const buf = new Uint8Array(str.length * 2);\n\n    for (let i = 0; i < str.length; i++) {\n        const code = str.charCodeAt(i);\n\n        buf[(i * 2)] = code & 0xFF;\n        buf[(i * 2) + 1] = code >> 8;\n    }\n\n    return buf;\n}\n\nfunction decodeUtf16LE(buf: Uint8Array): string {\n    if (buf.length % 2 !== 0) {\n        console.warn('Invalid UTF-16LE buffer length, truncating last byte');\n        buf = buf.slice(0, buf.length - 1);\n    }\n\n    const codeUnits = new Uint16Array(buf.buffer, buf.byteOffset, buf.byteLength / 2);\n\n    return String.fromCharCode(...codeUnits);\n}\n\nfunction encodeLatin1(str: string): Uint8Array {\n    const buf = new Uint8Array(str.length);\n\n    for (let i = 0; i < str.length; i++) {\n        buf[i] = str.charCodeAt(i) & 0xFF;\n    }\n\n    return buf;\n}\n\nfunction encodeAscii(str: string): Uint8Array {\n    const buf = new Uint8Array(str.length);\n\n    for (let i = 0; i < str.length; i++) {\n        buf[i] = str.charCodeAt(i) & 0x7F;\n    }\n\n    return buf;\n}\n","import type { OPFSWorker } from './worker';\nimport type { Remote } from 'comlink';\n\n/**\n * Type for paths that can be either a string or URI\n */\nexport type PathLike = string | URL;\n\nexport type Kind = 'file' | 'directory';\n\nexport type StringEncoding = 'ascii'\n  | 'utf8'\n  | 'utf-8'\n  | 'utf16le'\n  | 'utf-16le'\n  | 'ucs2'\n  | 'ucs-2'\n  | 'base64'\n  | 'latin1'\n  | 'hex';\n\nexport type BinaryEncoding = 'binary';\n\nexport type Encoding = StringEncoding | BinaryEncoding;\n\nexport interface FileStat {\n    kind: Kind;\n    size: number;\n    mtime: string; // ISO string\n    ctime: string; // ISO string\n    isFile: boolean;\n    isDirectory: boolean;\n    /** Hash of file content (only for files, undefined for directories) */\n    hash?: string;\n}\n\nexport interface DirentData {\n    name: string;\n    kind: 'file' | 'directory';\n    isFile: boolean;\n    isDirectory: boolean;\n}\n\nexport enum WatchEventType {\n    Added = 'added',\n    Changed = 'changed',\n    Removed = 'removed'\n}\n\nexport interface WatchEvent {\n    namespace: string;\n    path: string;\n    type: WatchEventType;\n    isDirectory: boolean;\n    timestamp: string;\n    hash?: string;\n}\n\nexport type { OPFSWorker };\nexport type RemoteOPFSWorker = Remote<OPFSWorker>;\n\nexport interface OPFSOptions {\n    /** Root path for the file system (default: '/') */\n    root?: string;\n    /** Namespace for the events (default: 'opfs-worker:${root}') */\n    namespace?: string;\n    /** Hash algorithm for file hashing, or false/null to disable (default: 'etag') */\n    hashAlgorithm?: null | false | 'etag' | 'SHA-1' | 'SHA-256' | 'SHA-384' | 'SHA-512';\n    /** Maximum file size in bytes for hashing (default: 50MB) */\n    maxFileSize?: number;\n    /** Custom name for the broadcast channel (default: 'opfs-worker') */\n    broadcastChannel?: string | BroadcastChannel | null;\n}\n\nexport interface RenameOptions {\n    /** Whether to overwrite existing files (default: false) */\n    overwrite?: boolean;\n}\n\nexport interface WatchOptions {\n    /** Whether to watch recursively (default: true) */\n    recursive?: boolean;\n    /** Glob patterns to include in watching (minimatch syntax, default: ['**']) */\n    include?: string | string[];\n    /** Glob patterns to exclude from watching (minimatch syntax, default: []) */\n    exclude?: string | string[];\n}\n\nexport interface FileOpenOptions {\n    create?: boolean;\n    exclusive?: boolean;\n    truncate?: boolean;\n}\n\nexport interface WatchSnapshot {\n    pattern: string;\n    include: string[];\n    exclude: string[];\n}\n","export const balanced = (a, b, str) => {\n    const ma = a instanceof RegExp ? maybeMatch(a, str) : a;\n    const mb = b instanceof RegExp ? maybeMatch(b, str) : b;\n    const r = ma !== null && mb != null && range(ma, mb, str);\n    return (r && {\n        start: r[0],\n        end: r[1],\n        pre: str.slice(0, r[0]),\n        body: str.slice(r[0] + ma.length, r[1]),\n        post: str.slice(r[1] + mb.length),\n    });\n};\nconst maybeMatch = (reg, str) => {\n    const m = str.match(reg);\n    return m ? m[0] : null;\n};\nexport const range = (a, b, str) => {\n    let begs, beg, left, right = undefined, result;\n    let ai = str.indexOf(a);\n    let bi = str.indexOf(b, ai + 1);\n    let i = ai;\n    if (ai >= 0 && bi > 0) {\n        if (a === b) {\n            return [ai, bi];\n        }\n        begs = [];\n        left = str.length;\n        while (i >= 0 && !result) {\n            if (i === ai) {\n                begs.push(i);\n                ai = str.indexOf(a, i + 1);\n            }\n            else if (begs.length === 1) {\n                const r = begs.pop();\n                if (r !== undefined)\n                    result = [r, bi];\n            }\n            else {\n                beg = begs.pop();\n                if (beg !== undefined && beg < left) {\n                    left = beg;\n                    right = bi;\n                }\n                bi = str.indexOf(b, i + 1);\n            }\n            i = ai < bi && ai >= 0 ? ai : bi;\n        }\n        if (begs.length && right !== undefined) {\n            result = [left, right];\n        }\n    }\n    return result;\n};\n//# sourceMappingURL=index.js.map","import { balanced } from '@isaacs/balanced-match';\nconst escSlash = '\\0SLASH' + Math.random() + '\\0';\nconst escOpen = '\\0OPEN' + Math.random() + '\\0';\nconst escClose = '\\0CLOSE' + Math.random() + '\\0';\nconst escComma = '\\0COMMA' + Math.random() + '\\0';\nconst escPeriod = '\\0PERIOD' + Math.random() + '\\0';\nconst escSlashPattern = new RegExp(escSlash, 'g');\nconst escOpenPattern = new RegExp(escOpen, 'g');\nconst escClosePattern = new RegExp(escClose, 'g');\nconst escCommaPattern = new RegExp(escComma, 'g');\nconst escPeriodPattern = new RegExp(escPeriod, 'g');\nconst slashPattern = /\\\\\\\\/g;\nconst openPattern = /\\\\{/g;\nconst closePattern = /\\\\}/g;\nconst commaPattern = /\\\\,/g;\nconst periodPattern = /\\\\./g;\nfunction numeric(str) {\n    return !isNaN(str) ? parseInt(str, 10) : str.charCodeAt(0);\n}\nfunction escapeBraces(str) {\n    return str\n        .replace(slashPattern, escSlash)\n        .replace(openPattern, escOpen)\n        .replace(closePattern, escClose)\n        .replace(commaPattern, escComma)\n        .replace(periodPattern, escPeriod);\n}\nfunction unescapeBraces(str) {\n    return str\n        .replace(escSlashPattern, '\\\\')\n        .replace(escOpenPattern, '{')\n        .replace(escClosePattern, '}')\n        .replace(escCommaPattern, ',')\n        .replace(escPeriodPattern, '.');\n}\n/**\n * Basically just str.split(\",\"), but handling cases\n * where we have nested braced sections, which should be\n * treated as individual members, like {a,{b,c},d}\n */\nfunction parseCommaParts(str) {\n    if (!str) {\n        return [''];\n    }\n    const parts = [];\n    const m = balanced('{', '}', str);\n    if (!m) {\n        return str.split(',');\n    }\n    const { pre, body, post } = m;\n    const p = pre.split(',');\n    p[p.length - 1] += '{' + body + '}';\n    const postParts = parseCommaParts(post);\n    if (post.length) {\n        ;\n        p[p.length - 1] += postParts.shift();\n        p.push.apply(p, postParts);\n    }\n    parts.push.apply(parts, p);\n    return parts;\n}\nexport function expand(str) {\n    if (!str) {\n        return [];\n    }\n    // I don't know why Bash 4.3 does this, but it does.\n    // Anything starting with {} will have the first two bytes preserved\n    // but *only* at the top level, so {},a}b will not expand to anything,\n    // but a{},b}c will be expanded to [a}c,abc].\n    // One could argue that this is a bug in Bash, but since the goal of\n    // this module is to match Bash's rules, we escape a leading {}\n    if (str.slice(0, 2) === '{}') {\n        str = '\\\\{\\\\}' + str.slice(2);\n    }\n    return expand_(escapeBraces(str), true).map(unescapeBraces);\n}\nfunction embrace(str) {\n    return '{' + str + '}';\n}\nfunction isPadded(el) {\n    return /^-?0\\d/.test(el);\n}\nfunction lte(i, y) {\n    return i <= y;\n}\nfunction gte(i, y) {\n    return i >= y;\n}\nfunction expand_(str, isTop) {\n    /** @type {string[]} */\n    const expansions = [];\n    const m = balanced('{', '}', str);\n    if (!m)\n        return [str];\n    // no need to expand pre, since it is guaranteed to be free of brace-sets\n    const pre = m.pre;\n    const post = m.post.length ? expand_(m.post, false) : [''];\n    if (/\\$$/.test(m.pre)) {\n        for (let k = 0; k < post.length; k++) {\n            const expansion = pre + '{' + m.body + '}' + post[k];\n            expansions.push(expansion);\n        }\n    }\n    else {\n        const isNumericSequence = /^-?\\d+\\.\\.-?\\d+(?:\\.\\.-?\\d+)?$/.test(m.body);\n        const isAlphaSequence = /^[a-zA-Z]\\.\\.[a-zA-Z](?:\\.\\.-?\\d+)?$/.test(m.body);\n        const isSequence = isNumericSequence || isAlphaSequence;\n        const isOptions = m.body.indexOf(',') >= 0;\n        if (!isSequence && !isOptions) {\n            // {a},b}\n            if (m.post.match(/,(?!,).*\\}/)) {\n                str = m.pre + '{' + m.body + escClose + m.post;\n                return expand_(str);\n            }\n            return [str];\n        }\n        let n;\n        if (isSequence) {\n            n = m.body.split(/\\.\\./);\n        }\n        else {\n            n = parseCommaParts(m.body);\n            if (n.length === 1 && n[0] !== undefined) {\n                // x{{a,b}}y ==> x{a}y x{b}y\n                n = expand_(n[0], false).map(embrace);\n                //XXX is this necessary? Can't seem to hit it in tests.\n                /* c8 ignore start */\n                if (n.length === 1) {\n                    return post.map(p => m.pre + n[0] + p);\n                }\n                /* c8 ignore stop */\n            }\n        }\n        // at this point, n is the parts, and we know it's not a comma set\n        // with a single entry.\n        let N;\n        if (isSequence && n[0] !== undefined && n[1] !== undefined) {\n            const x = numeric(n[0]);\n            const y = numeric(n[1]);\n            const width = Math.max(n[0].length, n[1].length);\n            let incr = n.length === 3 && n[2] !== undefined ? Math.abs(numeric(n[2])) : 1;\n            let test = lte;\n            const reverse = y < x;\n            if (reverse) {\n                incr *= -1;\n                test = gte;\n            }\n            const pad = n.some(isPadded);\n            N = [];\n            for (let i = x; test(i, y); i += incr) {\n                let c;\n                if (isAlphaSequence) {\n                    c = String.fromCharCode(i);\n                    if (c === '\\\\') {\n                        c = '';\n                    }\n                }\n                else {\n                    c = String(i);\n                    if (pad) {\n                        const need = width - c.length;\n                        if (need > 0) {\n                            const z = new Array(need + 1).join('0');\n                            if (i < 0) {\n                                c = '-' + z + c.slice(1);\n                            }\n                            else {\n                                c = z + c;\n                            }\n                        }\n                    }\n                }\n                N.push(c);\n            }\n        }\n        else {\n            N = [];\n            for (let j = 0; j < n.length; j++) {\n                N.push.apply(N, expand_(n[j], false));\n            }\n        }\n        for (let j = 0; j < N.length; j++) {\n            for (let k = 0; k < post.length; k++) {\n                const expansion = pre + N[j] + post[k];\n                if (!isTop || isSequence || expansion) {\n                    expansions.push(expansion);\n                }\n            }\n        }\n    }\n    return expansions;\n}\n//# sourceMappingURL=index.js.map","const MAX_PATTERN_LENGTH = 1024 * 64;\nexport const assertValidPattern = (pattern) => {\n    if (typeof pattern !== 'string') {\n        throw new TypeError('invalid pattern');\n    }\n    if (pattern.length > MAX_PATTERN_LENGTH) {\n        throw new TypeError('pattern is too long');\n    }\n};\n//# sourceMappingURL=assert-valid-pattern.js.map","// translate the various posix character classes into unicode properties\n// this works across all unicode locales\n// { <posix class>: [<translation>, /u flag required, negated]\nconst posixClasses = {\n    '[:alnum:]': ['\\\\p{L}\\\\p{Nl}\\\\p{Nd}', true],\n    '[:alpha:]': ['\\\\p{L}\\\\p{Nl}', true],\n    '[:ascii:]': ['\\\\x' + '00-\\\\x' + '7f', false],\n    '[:blank:]': ['\\\\p{Zs}\\\\t', true],\n    '[:cntrl:]': ['\\\\p{Cc}', true],\n    '[:digit:]': ['\\\\p{Nd}', true],\n    '[:graph:]': ['\\\\p{Z}\\\\p{C}', true, true],\n    '[:lower:]': ['\\\\p{Ll}', true],\n    '[:print:]': ['\\\\p{C}', true],\n    '[:punct:]': ['\\\\p{P}', true],\n    '[:space:]': ['\\\\p{Z}\\\\t\\\\r\\\\n\\\\v\\\\f', true],\n    '[:upper:]': ['\\\\p{Lu}', true],\n    '[:word:]': ['\\\\p{L}\\\\p{Nl}\\\\p{Nd}\\\\p{Pc}', true],\n    '[:xdigit:]': ['A-Fa-f0-9', false],\n};\n// only need to escape a few things inside of brace expressions\n// escapes: [ \\ ] -\nconst braceEscape = (s) => s.replace(/[[\\]\\\\-]/g, '\\\\$&');\n// escape all regexp magic characters\nconst regexpEscape = (s) => s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n// everything has already been escaped, we just have to join\nconst rangesToString = (ranges) => ranges.join('');\n// takes a glob string at a posix brace expression, and returns\n// an equivalent regular expression source, and boolean indicating\n// whether the /u flag needs to be applied, and the number of chars\n// consumed to parse the character class.\n// This also removes out of order ranges, and returns ($.) if the\n// entire class just no good.\nexport const parseClass = (glob, position) => {\n    const pos = position;\n    /* c8 ignore start */\n    if (glob.charAt(pos) !== '[') {\n        throw new Error('not in a brace expression');\n    }\n    /* c8 ignore stop */\n    const ranges = [];\n    const negs = [];\n    let i = pos + 1;\n    let sawStart = false;\n    let uflag = false;\n    let escaping = false;\n    let negate = false;\n    let endPos = pos;\n    let rangeStart = '';\n    WHILE: while (i < glob.length) {\n        const c = glob.charAt(i);\n        if ((c === '!' || c === '^') && i === pos + 1) {\n            negate = true;\n            i++;\n            continue;\n        }\n        if (c === ']' && sawStart && !escaping) {\n            endPos = i + 1;\n            break;\n        }\n        sawStart = true;\n        if (c === '\\\\') {\n            if (!escaping) {\n                escaping = true;\n                i++;\n                continue;\n            }\n            // escaped \\ char, fall through and treat like normal char\n        }\n        if (c === '[' && !escaping) {\n            // either a posix class, a collation equivalent, or just a [\n            for (const [cls, [unip, u, neg]] of Object.entries(posixClasses)) {\n                if (glob.startsWith(cls, i)) {\n                    // invalid, [a-[] is fine, but not [a-[:alpha]]\n                    if (rangeStart) {\n                        return ['$.', false, glob.length - pos, true];\n                    }\n                    i += cls.length;\n                    if (neg)\n                        negs.push(unip);\n                    else\n                        ranges.push(unip);\n                    uflag = uflag || u;\n                    continue WHILE;\n                }\n            }\n        }\n        // now it's just a normal character, effectively\n        escaping = false;\n        if (rangeStart) {\n            // throw this range away if it's not valid, but others\n            // can still match.\n            if (c > rangeStart) {\n                ranges.push(braceEscape(rangeStart) + '-' + braceEscape(c));\n            }\n            else if (c === rangeStart) {\n                ranges.push(braceEscape(c));\n            }\n            rangeStart = '';\n            i++;\n            continue;\n        }\n        // now might be the start of a range.\n        // can be either c-d or c-] or c<more...>] or c] at this point\n        if (glob.startsWith('-]', i + 1)) {\n            ranges.push(braceEscape(c + '-'));\n            i += 2;\n            continue;\n        }\n        if (glob.startsWith('-', i + 1)) {\n            rangeStart = c;\n            i += 2;\n            continue;\n        }\n        // not the start of a range, just a single character\n        ranges.push(braceEscape(c));\n        i++;\n    }\n    if (endPos < i) {\n        // didn't see the end of the class, not a valid class,\n        // but might still be valid as a literal match.\n        return ['', false, 0, false];\n    }\n    // if we got no ranges and no negates, then we have a range that\n    // cannot possibly match anything, and that poisons the whole glob\n    if (!ranges.length && !negs.length) {\n        return ['$.', false, glob.length - pos, true];\n    }\n    // if we got one positive range, and it's a single character, then that's\n    // not actually a magic pattern, it's just that one literal character.\n    // we should not treat that as \"magic\", we should just return the literal\n    // character. [_] is a perfectly valid way to escape glob magic chars.\n    if (negs.length === 0 &&\n        ranges.length === 1 &&\n        /^\\\\?.$/.test(ranges[0]) &&\n        !negate) {\n        const r = ranges[0].length === 2 ? ranges[0].slice(-1) : ranges[0];\n        return [regexpEscape(r), false, endPos - pos, false];\n    }\n    const sranges = '[' + (negate ? '^' : '') + rangesToString(ranges) + ']';\n    const snegs = '[' + (negate ? '' : '^') + rangesToString(negs) + ']';\n    const comb = ranges.length && negs.length\n        ? '(' + sranges + '|' + snegs + ')'\n        : ranges.length\n            ? sranges\n            : snegs;\n    return [comb, uflag, endPos - pos, true];\n};\n//# sourceMappingURL=brace-expressions.js.map","/**\n * Un-escape a string that has been escaped with {@link escape}.\n *\n * If the {@link windowsPathsNoEscape} option is used, then square-brace\n * escapes are removed, but not backslash escapes.  For example, it will turn\n * the string `'[*]'` into `*`, but it will not turn `'\\\\*'` into `'*'`,\n * becuase `\\` is a path separator in `windowsPathsNoEscape` mode.\n *\n * When `windowsPathsNoEscape` is not set, then both brace escapes and\n * backslash escapes are removed.\n *\n * Slashes (and backslashes in `windowsPathsNoEscape` mode) cannot be escaped\n * or unescaped.\n */\nexport const unescape = (s, { windowsPathsNoEscape = false, } = {}) => {\n    return windowsPathsNoEscape\n        ? s.replace(/\\[([^\\/\\\\])\\]/g, '$1')\n        : s.replace(/((?!\\\\).|^)\\[([^\\/\\\\])\\]/g, '$1$2').replace(/\\\\([^\\/])/g, '$1');\n};\n//# sourceMappingURL=unescape.js.map","// parse a single path portion\nimport { parseClass } from './brace-expressions.js';\nimport { unescape } from './unescape.js';\nconst types = new Set(['!', '?', '+', '*', '@']);\nconst isExtglobType = (c) => types.has(c);\n// Patterns that get prepended to bind to the start of either the\n// entire string, or just a single path portion, to prevent dots\n// and/or traversal patterns, when needed.\n// Exts don't need the ^ or / bit, because the root binds that already.\nconst startNoTraversal = '(?!(?:^|/)\\\\.\\\\.?(?:$|/))';\nconst startNoDot = '(?!\\\\.)';\n// characters that indicate a start of pattern needs the \"no dots\" bit,\n// because a dot *might* be matched. ( is not in the list, because in\n// the case of a child extglob, it will handle the prevention itself.\nconst addPatternStart = new Set(['[', '.']);\n// cases where traversal is A-OK, no dot prevention needed\nconst justDots = new Set(['..', '.']);\nconst reSpecials = new Set('().*{}+?[]^$\\\\!');\nconst regExpEscape = (s) => s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n// any single thing other than /\nconst qmark = '[^/]';\n// * => any number of characters\nconst star = qmark + '*?';\n// use + when we need to ensure that *something* matches, because the * is\n// the only thing in the path portion.\nconst starNoEmpty = qmark + '+?';\n// remove the \\ chars that we added if we end up doing a nonmagic compare\n// const deslash = (s: string) => s.replace(/\\\\(.)/g, '$1')\nexport class AST {\n    type;\n    #root;\n    #hasMagic;\n    #uflag = false;\n    #parts = [];\n    #parent;\n    #parentIndex;\n    #negs;\n    #filledNegs = false;\n    #options;\n    #toString;\n    // set to true if it's an extglob with no children\n    // (which really means one child of '')\n    #emptyExt = false;\n    constructor(type, parent, options = {}) {\n        this.type = type;\n        // extglobs are inherently magical\n        if (type)\n            this.#hasMagic = true;\n        this.#parent = parent;\n        this.#root = this.#parent ? this.#parent.#root : this;\n        this.#options = this.#root === this ? options : this.#root.#options;\n        this.#negs = this.#root === this ? [] : this.#root.#negs;\n        if (type === '!' && !this.#root.#filledNegs)\n            this.#negs.push(this);\n        this.#parentIndex = this.#parent ? this.#parent.#parts.length : 0;\n    }\n    get hasMagic() {\n        /* c8 ignore start */\n        if (this.#hasMagic !== undefined)\n            return this.#hasMagic;\n        /* c8 ignore stop */\n        for (const p of this.#parts) {\n            if (typeof p === 'string')\n                continue;\n            if (p.type || p.hasMagic)\n                return (this.#hasMagic = true);\n        }\n        // note: will be undefined until we generate the regexp src and find out\n        return this.#hasMagic;\n    }\n    // reconstructs the pattern\n    toString() {\n        if (this.#toString !== undefined)\n            return this.#toString;\n        if (!this.type) {\n            return (this.#toString = this.#parts.map(p => String(p)).join(''));\n        }\n        else {\n            return (this.#toString =\n                this.type + '(' + this.#parts.map(p => String(p)).join('|') + ')');\n        }\n    }\n    #fillNegs() {\n        /* c8 ignore start */\n        if (this !== this.#root)\n            throw new Error('should only call on root');\n        if (this.#filledNegs)\n            return this;\n        /* c8 ignore stop */\n        // call toString() once to fill this out\n        this.toString();\n        this.#filledNegs = true;\n        let n;\n        while ((n = this.#negs.pop())) {\n            if (n.type !== '!')\n                continue;\n            // walk up the tree, appending everthing that comes AFTER parentIndex\n            let p = n;\n            let pp = p.#parent;\n            while (pp) {\n                for (let i = p.#parentIndex + 1; !pp.type && i < pp.#parts.length; i++) {\n                    for (const part of n.#parts) {\n                        /* c8 ignore start */\n                        if (typeof part === 'string') {\n                            throw new Error('string part in extglob AST??');\n                        }\n                        /* c8 ignore stop */\n                        part.copyIn(pp.#parts[i]);\n                    }\n                }\n                p = pp;\n                pp = p.#parent;\n            }\n        }\n        return this;\n    }\n    push(...parts) {\n        for (const p of parts) {\n            if (p === '')\n                continue;\n            /* c8 ignore start */\n            if (typeof p !== 'string' && !(p instanceof AST && p.#parent === this)) {\n                throw new Error('invalid part: ' + p);\n            }\n            /* c8 ignore stop */\n            this.#parts.push(p);\n        }\n    }\n    toJSON() {\n        const ret = this.type === null\n            ? this.#parts.slice().map(p => (typeof p === 'string' ? p : p.toJSON()))\n            : [this.type, ...this.#parts.map(p => p.toJSON())];\n        if (this.isStart() && !this.type)\n            ret.unshift([]);\n        if (this.isEnd() &&\n            (this === this.#root ||\n                (this.#root.#filledNegs && this.#parent?.type === '!'))) {\n            ret.push({});\n        }\n        return ret;\n    }\n    isStart() {\n        if (this.#root === this)\n            return true;\n        // if (this.type) return !!this.#parent?.isStart()\n        if (!this.#parent?.isStart())\n            return false;\n        if (this.#parentIndex === 0)\n            return true;\n        // if everything AHEAD of this is a negation, then it's still the \"start\"\n        const p = this.#parent;\n        for (let i = 0; i < this.#parentIndex; i++) {\n            const pp = p.#parts[i];\n            if (!(pp instanceof AST && pp.type === '!')) {\n                return false;\n            }\n        }\n        return true;\n    }\n    isEnd() {\n        if (this.#root === this)\n            return true;\n        if (this.#parent?.type === '!')\n            return true;\n        if (!this.#parent?.isEnd())\n            return false;\n        if (!this.type)\n            return this.#parent?.isEnd();\n        // if not root, it'll always have a parent\n        /* c8 ignore start */\n        const pl = this.#parent ? this.#parent.#parts.length : 0;\n        /* c8 ignore stop */\n        return this.#parentIndex === pl - 1;\n    }\n    copyIn(part) {\n        if (typeof part === 'string')\n            this.push(part);\n        else\n            this.push(part.clone(this));\n    }\n    clone(parent) {\n        const c = new AST(this.type, parent);\n        for (const p of this.#parts) {\n            c.copyIn(p);\n        }\n        return c;\n    }\n    static #parseAST(str, ast, pos, opt) {\n        let escaping = false;\n        let inBrace = false;\n        let braceStart = -1;\n        let braceNeg = false;\n        if (ast.type === null) {\n            // outside of a extglob, append until we find a start\n            let i = pos;\n            let acc = '';\n            while (i < str.length) {\n                const c = str.charAt(i++);\n                // still accumulate escapes at this point, but we do ignore\n                // starts that are escaped\n                if (escaping || c === '\\\\') {\n                    escaping = !escaping;\n                    acc += c;\n                    continue;\n                }\n                if (inBrace) {\n                    if (i === braceStart + 1) {\n                        if (c === '^' || c === '!') {\n                            braceNeg = true;\n                        }\n                    }\n                    else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {\n                        inBrace = false;\n                    }\n                    acc += c;\n                    continue;\n                }\n                else if (c === '[') {\n                    inBrace = true;\n                    braceStart = i;\n                    braceNeg = false;\n                    acc += c;\n                    continue;\n                }\n                if (!opt.noext && isExtglobType(c) && str.charAt(i) === '(') {\n                    ast.push(acc);\n                    acc = '';\n                    const ext = new AST(c, ast);\n                    i = AST.#parseAST(str, ext, i, opt);\n                    ast.push(ext);\n                    continue;\n                }\n                acc += c;\n            }\n            ast.push(acc);\n            return i;\n        }\n        // some kind of extglob, pos is at the (\n        // find the next | or )\n        let i = pos + 1;\n        let part = new AST(null, ast);\n        const parts = [];\n        let acc = '';\n        while (i < str.length) {\n            const c = str.charAt(i++);\n            // still accumulate escapes at this point, but we do ignore\n            // starts that are escaped\n            if (escaping || c === '\\\\') {\n                escaping = !escaping;\n                acc += c;\n                continue;\n            }\n            if (inBrace) {\n                if (i === braceStart + 1) {\n                    if (c === '^' || c === '!') {\n                        braceNeg = true;\n                    }\n                }\n                else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {\n                    inBrace = false;\n                }\n                acc += c;\n                continue;\n            }\n            else if (c === '[') {\n                inBrace = true;\n                braceStart = i;\n                braceNeg = false;\n                acc += c;\n                continue;\n            }\n            if (isExtglobType(c) && str.charAt(i) === '(') {\n                part.push(acc);\n                acc = '';\n                const ext = new AST(c, part);\n                part.push(ext);\n                i = AST.#parseAST(str, ext, i, opt);\n                continue;\n            }\n            if (c === '|') {\n                part.push(acc);\n                acc = '';\n                parts.push(part);\n                part = new AST(null, ast);\n                continue;\n            }\n            if (c === ')') {\n                if (acc === '' && ast.#parts.length === 0) {\n                    ast.#emptyExt = true;\n                }\n                part.push(acc);\n                acc = '';\n                ast.push(...parts, part);\n                return i;\n            }\n            acc += c;\n        }\n        // unfinished extglob\n        // if we got here, it was a malformed extglob! not an extglob, but\n        // maybe something else in there.\n        ast.type = null;\n        ast.#hasMagic = undefined;\n        ast.#parts = [str.substring(pos - 1)];\n        return i;\n    }\n    static fromGlob(pattern, options = {}) {\n        const ast = new AST(null, undefined, options);\n        AST.#parseAST(pattern, ast, 0, options);\n        return ast;\n    }\n    // returns the regular expression if there's magic, or the unescaped\n    // string if not.\n    toMMPattern() {\n        // should only be called on root\n        /* c8 ignore start */\n        if (this !== this.#root)\n            return this.#root.toMMPattern();\n        /* c8 ignore stop */\n        const glob = this.toString();\n        const [re, body, hasMagic, uflag] = this.toRegExpSource();\n        // if we're in nocase mode, and not nocaseMagicOnly, then we do\n        // still need a regular expression if we have to case-insensitively\n        // match capital/lowercase characters.\n        const anyMagic = hasMagic ||\n            this.#hasMagic ||\n            (this.#options.nocase &&\n                !this.#options.nocaseMagicOnly &&\n                glob.toUpperCase() !== glob.toLowerCase());\n        if (!anyMagic) {\n            return body;\n        }\n        const flags = (this.#options.nocase ? 'i' : '') + (uflag ? 'u' : '');\n        return Object.assign(new RegExp(`^${re}$`, flags), {\n            _src: re,\n            _glob: glob,\n        });\n    }\n    get options() {\n        return this.#options;\n    }\n    // returns the string match, the regexp source, whether there's magic\n    // in the regexp (so a regular expression is required) and whether or\n    // not the uflag is needed for the regular expression (for posix classes)\n    // TODO: instead of injecting the start/end at this point, just return\n    // the BODY of the regexp, along with the start/end portions suitable\n    // for binding the start/end in either a joined full-path makeRe context\n    // (where we bind to (^|/), or a standalone matchPart context (where\n    // we bind to ^, and not /).  Otherwise slashes get duped!\n    //\n    // In part-matching mode, the start is:\n    // - if not isStart: nothing\n    // - if traversal possible, but not allowed: ^(?!\\.\\.?$)\n    // - if dots allowed or not possible: ^\n    // - if dots possible and not allowed: ^(?!\\.)\n    // end is:\n    // - if not isEnd(): nothing\n    // - else: $\n    //\n    // In full-path matching mode, we put the slash at the START of the\n    // pattern, so start is:\n    // - if first pattern: same as part-matching mode\n    // - if not isStart(): nothing\n    // - if traversal possible, but not allowed: /(?!\\.\\.?(?:$|/))\n    // - if dots allowed or not possible: /\n    // - if dots possible and not allowed: /(?!\\.)\n    // end is:\n    // - if last pattern, same as part-matching mode\n    // - else nothing\n    //\n    // Always put the (?:$|/) on negated tails, though, because that has to be\n    // there to bind the end of the negated pattern portion, and it's easier to\n    // just stick it in now rather than try to inject it later in the middle of\n    // the pattern.\n    //\n    // We can just always return the same end, and leave it up to the caller\n    // to know whether it's going to be used joined or in parts.\n    // And, if the start is adjusted slightly, can do the same there:\n    // - if not isStart: nothing\n    // - if traversal possible, but not allowed: (?:/|^)(?!\\.\\.?$)\n    // - if dots allowed or not possible: (?:/|^)\n    // - if dots possible and not allowed: (?:/|^)(?!\\.)\n    //\n    // But it's better to have a simpler binding without a conditional, for\n    // performance, so probably better to return both start options.\n    //\n    // Then the caller just ignores the end if it's not the first pattern,\n    // and the start always gets applied.\n    //\n    // But that's always going to be $ if it's the ending pattern, or nothing,\n    // so the caller can just attach $ at the end of the pattern when building.\n    //\n    // So the todo is:\n    // - better detect what kind of start is needed\n    // - return both flavors of starting pattern\n    // - attach $ at the end of the pattern when creating the actual RegExp\n    //\n    // Ah, but wait, no, that all only applies to the root when the first pattern\n    // is not an extglob. If the first pattern IS an extglob, then we need all\n    // that dot prevention biz to live in the extglob portions, because eg\n    // +(*|.x*) can match .xy but not .yx.\n    //\n    // So, return the two flavors if it's #root and the first child is not an\n    // AST, otherwise leave it to the child AST to handle it, and there,\n    // use the (?:^|/) style of start binding.\n    //\n    // Even simplified further:\n    // - Since the start for a join is eg /(?!\\.) and the start for a part\n    // is ^(?!\\.), we can just prepend (?!\\.) to the pattern (either root\n    // or start or whatever) and prepend ^ or / at the Regexp construction.\n    toRegExpSource(allowDot) {\n        const dot = allowDot ?? !!this.#options.dot;\n        if (this.#root === this)\n            this.#fillNegs();\n        if (!this.type) {\n            const noEmpty = this.isStart() && this.isEnd();\n            const src = this.#parts\n                .map(p => {\n                const [re, _, hasMagic, uflag] = typeof p === 'string'\n                    ? AST.#parseGlob(p, this.#hasMagic, noEmpty)\n                    : p.toRegExpSource(allowDot);\n                this.#hasMagic = this.#hasMagic || hasMagic;\n                this.#uflag = this.#uflag || uflag;\n                return re;\n            })\n                .join('');\n            let start = '';\n            if (this.isStart()) {\n                if (typeof this.#parts[0] === 'string') {\n                    // this is the string that will match the start of the pattern,\n                    // so we need to protect against dots and such.\n                    // '.' and '..' cannot match unless the pattern is that exactly,\n                    // even if it starts with . or dot:true is set.\n                    const dotTravAllowed = this.#parts.length === 1 && justDots.has(this.#parts[0]);\n                    if (!dotTravAllowed) {\n                        const aps = addPatternStart;\n                        // check if we have a possibility of matching . or ..,\n                        // and prevent that.\n                        const needNoTrav = \n                        // dots are allowed, and the pattern starts with [ or .\n                        (dot && aps.has(src.charAt(0))) ||\n                            // the pattern starts with \\., and then [ or .\n                            (src.startsWith('\\\\.') && aps.has(src.charAt(2))) ||\n                            // the pattern starts with \\.\\., and then [ or .\n                            (src.startsWith('\\\\.\\\\.') && aps.has(src.charAt(4)));\n                        // no need to prevent dots if it can't match a dot, or if a\n                        // sub-pattern will be preventing it anyway.\n                        const needNoDot = !dot && !allowDot && aps.has(src.charAt(0));\n                        start = needNoTrav ? startNoTraversal : needNoDot ? startNoDot : '';\n                    }\n                }\n            }\n            // append the \"end of path portion\" pattern to negation tails\n            let end = '';\n            if (this.isEnd() &&\n                this.#root.#filledNegs &&\n                this.#parent?.type === '!') {\n                end = '(?:$|\\\\/)';\n            }\n            const final = start + src + end;\n            return [\n                final,\n                unescape(src),\n                (this.#hasMagic = !!this.#hasMagic),\n                this.#uflag,\n            ];\n        }\n        // We need to calculate the body *twice* if it's a repeat pattern\n        // at the start, once in nodot mode, then again in dot mode, so a\n        // pattern like *(?) can match 'x.y'\n        const repeated = this.type === '*' || this.type === '+';\n        // some kind of extglob\n        const start = this.type === '!' ? '(?:(?!(?:' : '(?:';\n        let body = this.#partsToRegExp(dot);\n        if (this.isStart() && this.isEnd() && !body && this.type !== '!') {\n            // invalid extglob, has to at least be *something* present, if it's\n            // the entire path portion.\n            const s = this.toString();\n            this.#parts = [s];\n            this.type = null;\n            this.#hasMagic = undefined;\n            return [s, unescape(this.toString()), false, false];\n        }\n        // XXX abstract out this map method\n        let bodyDotAllowed = !repeated || allowDot || dot || !startNoDot\n            ? ''\n            : this.#partsToRegExp(true);\n        if (bodyDotAllowed === body) {\n            bodyDotAllowed = '';\n        }\n        if (bodyDotAllowed) {\n            body = `(?:${body})(?:${bodyDotAllowed})*?`;\n        }\n        // an empty !() is exactly equivalent to a starNoEmpty\n        let final = '';\n        if (this.type === '!' && this.#emptyExt) {\n            final = (this.isStart() && !dot ? startNoDot : '') + starNoEmpty;\n        }\n        else {\n            const close = this.type === '!'\n                ? // !() must match something,but !(x) can match ''\n                    '))' +\n                        (this.isStart() && !dot && !allowDot ? startNoDot : '') +\n                        star +\n                        ')'\n                : this.type === '@'\n                    ? ')'\n                    : this.type === '?'\n                        ? ')?'\n                        : this.type === '+' && bodyDotAllowed\n                            ? ')'\n                            : this.type === '*' && bodyDotAllowed\n                                ? `)?`\n                                : `)${this.type}`;\n            final = start + body + close;\n        }\n        return [\n            final,\n            unescape(body),\n            (this.#hasMagic = !!this.#hasMagic),\n            this.#uflag,\n        ];\n    }\n    #partsToRegExp(dot) {\n        return this.#parts\n            .map(p => {\n            // extglob ASTs should only contain parent ASTs\n            /* c8 ignore start */\n            if (typeof p === 'string') {\n                throw new Error('string type in extglob ast??');\n            }\n            /* c8 ignore stop */\n            // can ignore hasMagic, because extglobs are already always magic\n            const [re, _, _hasMagic, uflag] = p.toRegExpSource(dot);\n            this.#uflag = this.#uflag || uflag;\n            return re;\n        })\n            .filter(p => !(this.isStart() && this.isEnd()) || !!p)\n            .join('|');\n    }\n    static #parseGlob(glob, hasMagic, noEmpty = false) {\n        let escaping = false;\n        let re = '';\n        let uflag = false;\n        for (let i = 0; i < glob.length; i++) {\n            const c = glob.charAt(i);\n            if (escaping) {\n                escaping = false;\n                re += (reSpecials.has(c) ? '\\\\' : '') + c;\n                continue;\n            }\n            if (c === '\\\\') {\n                if (i === glob.length - 1) {\n                    re += '\\\\\\\\';\n                }\n                else {\n                    escaping = true;\n                }\n                continue;\n            }\n            if (c === '[') {\n                const [src, needUflag, consumed, magic] = parseClass(glob, i);\n                if (consumed) {\n                    re += src;\n                    uflag = uflag || needUflag;\n                    i += consumed - 1;\n                    hasMagic = hasMagic || magic;\n                    continue;\n                }\n            }\n            if (c === '*') {\n                if (noEmpty && glob === '*')\n                    re += starNoEmpty;\n                else\n                    re += star;\n                hasMagic = true;\n                continue;\n            }\n            if (c === '?') {\n                re += qmark;\n                hasMagic = true;\n                continue;\n            }\n            re += regExpEscape(c);\n        }\n        return [re, unescape(glob), !!hasMagic, uflag];\n    }\n}\n//# sourceMappingURL=ast.js.map","/**\n * Escape all magic characters in a glob pattern.\n *\n * If the {@link windowsPathsNoEscape | GlobOptions.windowsPathsNoEscape}\n * option is used, then characters are escaped by wrapping in `[]`, because\n * a magic character wrapped in a character class can only be satisfied by\n * that exact character.  In this mode, `\\` is _not_ escaped, because it is\n * not interpreted as a magic character, but instead as a path separator.\n */\nexport const escape = (s, { windowsPathsNoEscape = false, } = {}) => {\n    // don't need to escape +@! because we escape the parens\n    // that make those magic, and escaping ! as [!] isn't valid,\n    // because [!]] is a valid glob class meaning not ']'.\n    return windowsPathsNoEscape\n        ? s.replace(/[?*()[\\]]/g, '[$&]')\n        : s.replace(/[?*()[\\]\\\\]/g, '\\\\$&');\n};\n//# sourceMappingURL=escape.js.map","import { expand } from '@isaacs/brace-expansion';\nimport { assertValidPattern } from './assert-valid-pattern.js';\nimport { AST } from './ast.js';\nimport { escape } from './escape.js';\nimport { unescape } from './unescape.js';\nexport const minimatch = (p, pattern, options = {}) => {\n    assertValidPattern(pattern);\n    // shortcut: comments match nothing.\n    if (!options.nocomment && pattern.charAt(0) === '#') {\n        return false;\n    }\n    return new Minimatch(pattern, options).match(p);\n};\n// Optimized checking for the most common glob patterns.\nconst starDotExtRE = /^\\*+([^+@!?\\*\\[\\(]*)$/;\nconst starDotExtTest = (ext) => (f) => !f.startsWith('.') && f.endsWith(ext);\nconst starDotExtTestDot = (ext) => (f) => f.endsWith(ext);\nconst starDotExtTestNocase = (ext) => {\n    ext = ext.toLowerCase();\n    return (f) => !f.startsWith('.') && f.toLowerCase().endsWith(ext);\n};\nconst starDotExtTestNocaseDot = (ext) => {\n    ext = ext.toLowerCase();\n    return (f) => f.toLowerCase().endsWith(ext);\n};\nconst starDotStarRE = /^\\*+\\.\\*+$/;\nconst starDotStarTest = (f) => !f.startsWith('.') && f.includes('.');\nconst starDotStarTestDot = (f) => f !== '.' && f !== '..' && f.includes('.');\nconst dotStarRE = /^\\.\\*+$/;\nconst dotStarTest = (f) => f !== '.' && f !== '..' && f.startsWith('.');\nconst starRE = /^\\*+$/;\nconst starTest = (f) => f.length !== 0 && !f.startsWith('.');\nconst starTestDot = (f) => f.length !== 0 && f !== '.' && f !== '..';\nconst qmarksRE = /^\\?+([^+@!?\\*\\[\\(]*)?$/;\nconst qmarksTestNocase = ([$0, ext = '']) => {\n    const noext = qmarksTestNoExt([$0]);\n    if (!ext)\n        return noext;\n    ext = ext.toLowerCase();\n    return (f) => noext(f) && f.toLowerCase().endsWith(ext);\n};\nconst qmarksTestNocaseDot = ([$0, ext = '']) => {\n    const noext = qmarksTestNoExtDot([$0]);\n    if (!ext)\n        return noext;\n    ext = ext.toLowerCase();\n    return (f) => noext(f) && f.toLowerCase().endsWith(ext);\n};\nconst qmarksTestDot = ([$0, ext = '']) => {\n    const noext = qmarksTestNoExtDot([$0]);\n    return !ext ? noext : (f) => noext(f) && f.endsWith(ext);\n};\nconst qmarksTest = ([$0, ext = '']) => {\n    const noext = qmarksTestNoExt([$0]);\n    return !ext ? noext : (f) => noext(f) && f.endsWith(ext);\n};\nconst qmarksTestNoExt = ([$0]) => {\n    const len = $0.length;\n    return (f) => f.length === len && !f.startsWith('.');\n};\nconst qmarksTestNoExtDot = ([$0]) => {\n    const len = $0.length;\n    return (f) => f.length === len && f !== '.' && f !== '..';\n};\n/* c8 ignore start */\nconst defaultPlatform = (typeof process === 'object' && process\n    ? (typeof process.env === 'object' &&\n        process.env &&\n        process.env.__MINIMATCH_TESTING_PLATFORM__) ||\n        process.platform\n    : 'posix');\nconst path = {\n    win32: { sep: '\\\\' },\n    posix: { sep: '/' },\n};\n/* c8 ignore stop */\nexport const sep = defaultPlatform === 'win32' ? path.win32.sep : path.posix.sep;\nminimatch.sep = sep;\nexport const GLOBSTAR = Symbol('globstar **');\nminimatch.GLOBSTAR = GLOBSTAR;\n// any single thing other than /\n// don't need to escape / when using new RegExp()\nconst qmark = '[^/]';\n// * => any number of characters\nconst star = qmark + '*?';\n// ** when dots are allowed.  Anything goes, except .. and .\n// not (^ or / followed by one or two dots followed by $ or /),\n// followed by anything, any number of times.\nconst twoStarDot = '(?:(?!(?:\\\\/|^)(?:\\\\.{1,2})($|\\\\/)).)*?';\n// not a ^ or / followed by a dot,\n// followed by anything, any number of times.\nconst twoStarNoDot = '(?:(?!(?:\\\\/|^)\\\\.).)*?';\nexport const filter = (pattern, options = {}) => (p) => minimatch(p, pattern, options);\nminimatch.filter = filter;\nconst ext = (a, b = {}) => Object.assign({}, a, b);\nexport const defaults = (def) => {\n    if (!def || typeof def !== 'object' || !Object.keys(def).length) {\n        return minimatch;\n    }\n    const orig = minimatch;\n    const m = (p, pattern, options = {}) => orig(p, pattern, ext(def, options));\n    return Object.assign(m, {\n        Minimatch: class Minimatch extends orig.Minimatch {\n            constructor(pattern, options = {}) {\n                super(pattern, ext(def, options));\n            }\n            static defaults(options) {\n                return orig.defaults(ext(def, options)).Minimatch;\n            }\n        },\n        AST: class AST extends orig.AST {\n            /* c8 ignore start */\n            constructor(type, parent, options = {}) {\n                super(type, parent, ext(def, options));\n            }\n            /* c8 ignore stop */\n            static fromGlob(pattern, options = {}) {\n                return orig.AST.fromGlob(pattern, ext(def, options));\n            }\n        },\n        unescape: (s, options = {}) => orig.unescape(s, ext(def, options)),\n        escape: (s, options = {}) => orig.escape(s, ext(def, options)),\n        filter: (pattern, options = {}) => orig.filter(pattern, ext(def, options)),\n        defaults: (options) => orig.defaults(ext(def, options)),\n        makeRe: (pattern, options = {}) => orig.makeRe(pattern, ext(def, options)),\n        braceExpand: (pattern, options = {}) => orig.braceExpand(pattern, ext(def, options)),\n        match: (list, pattern, options = {}) => orig.match(list, pattern, ext(def, options)),\n        sep: orig.sep,\n        GLOBSTAR: GLOBSTAR,\n    });\n};\nminimatch.defaults = defaults;\n// Brace expansion:\n// a{b,c}d -> abd acd\n// a{b,}c -> abc ac\n// a{0..3}d -> a0d a1d a2d a3d\n// a{b,c{d,e}f}g -> abg acdfg acefg\n// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg\n//\n// Invalid sets are not expanded.\n// a{2..}b -> a{2..}b\n// a{b}c -> a{b}c\nexport const braceExpand = (pattern, options = {}) => {\n    assertValidPattern(pattern);\n    // Thanks to Yeting Li <https://github.com/yetingli> for\n    // improving this regexp to avoid a ReDOS vulnerability.\n    if (options.nobrace || !/\\{(?:(?!\\{).)*\\}/.test(pattern)) {\n        // shortcut. no need to expand.\n        return [pattern];\n    }\n    return expand(pattern);\n};\nminimatch.braceExpand = braceExpand;\n// parse a component of the expanded set.\n// At this point, no pattern may contain \"/\" in it\n// so we're going to return a 2d array, where each entry is the full\n// pattern, split on '/', and then turned into a regular expression.\n// A regexp is made at the end which joins each array with an\n// escaped /, and another full one which joins each regexp with |.\n//\n// Following the lead of Bash 4.1, note that \"**\" only has special meaning\n// when it is the *only* thing in a path portion.  Otherwise, any series\n// of * is equivalent to a single *.  Globstar behavior is enabled by\n// default, and can be disabled by setting options.noglobstar.\nexport const makeRe = (pattern, options = {}) => new Minimatch(pattern, options).makeRe();\nminimatch.makeRe = makeRe;\nexport const match = (list, pattern, options = {}) => {\n    const mm = new Minimatch(pattern, options);\n    list = list.filter(f => mm.match(f));\n    if (mm.options.nonull && !list.length) {\n        list.push(pattern);\n    }\n    return list;\n};\nminimatch.match = match;\n// replace stuff like \\* with *\nconst globMagic = /[?*]|[+@!]\\(.*?\\)|\\[|\\]/;\nconst regExpEscape = (s) => s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\nexport class Minimatch {\n    options;\n    set;\n    pattern;\n    windowsPathsNoEscape;\n    nonegate;\n    negate;\n    comment;\n    empty;\n    preserveMultipleSlashes;\n    partial;\n    globSet;\n    globParts;\n    nocase;\n    isWindows;\n    platform;\n    windowsNoMagicRoot;\n    regexp;\n    constructor(pattern, options = {}) {\n        assertValidPattern(pattern);\n        options = options || {};\n        this.options = options;\n        this.pattern = pattern;\n        this.platform = options.platform || defaultPlatform;\n        this.isWindows = this.platform === 'win32';\n        this.windowsPathsNoEscape =\n            !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;\n        if (this.windowsPathsNoEscape) {\n            this.pattern = this.pattern.replace(/\\\\/g, '/');\n        }\n        this.preserveMultipleSlashes = !!options.preserveMultipleSlashes;\n        this.regexp = null;\n        this.negate = false;\n        this.nonegate = !!options.nonegate;\n        this.comment = false;\n        this.empty = false;\n        this.partial = !!options.partial;\n        this.nocase = !!this.options.nocase;\n        this.windowsNoMagicRoot =\n            options.windowsNoMagicRoot !== undefined\n                ? options.windowsNoMagicRoot\n                : !!(this.isWindows && this.nocase);\n        this.globSet = [];\n        this.globParts = [];\n        this.set = [];\n        // make the set of regexps etc.\n        this.make();\n    }\n    hasMagic() {\n        if (this.options.magicalBraces && this.set.length > 1) {\n            return true;\n        }\n        for (const pattern of this.set) {\n            for (const part of pattern) {\n                if (typeof part !== 'string')\n                    return true;\n            }\n        }\n        return false;\n    }\n    debug(..._) { }\n    make() {\n        const pattern = this.pattern;\n        const options = this.options;\n        // empty patterns and comments match nothing.\n        if (!options.nocomment && pattern.charAt(0) === '#') {\n            this.comment = true;\n            return;\n        }\n        if (!pattern) {\n            this.empty = true;\n            return;\n        }\n        // step 1: figure out negation, etc.\n        this.parseNegate();\n        // step 2: expand braces\n        this.globSet = [...new Set(this.braceExpand())];\n        if (options.debug) {\n            this.debug = (...args) => console.error(...args);\n        }\n        this.debug(this.pattern, this.globSet);\n        // step 3: now we have a set, so turn each one into a series of\n        // path-portion matching patterns.\n        // These will be regexps, except in the case of \"**\", which is\n        // set to the GLOBSTAR object for globstar behavior,\n        // and will not contain any / characters\n        //\n        // First, we preprocess to make the glob pattern sets a bit simpler\n        // and deduped.  There are some perf-killing patterns that can cause\n        // problems with a glob walk, but we can simplify them down a bit.\n        const rawGlobParts = this.globSet.map(s => this.slashSplit(s));\n        this.globParts = this.preprocess(rawGlobParts);\n        this.debug(this.pattern, this.globParts);\n        // glob --> regexps\n        let set = this.globParts.map((s, _, __) => {\n            if (this.isWindows && this.windowsNoMagicRoot) {\n                // check if it's a drive or unc path.\n                const isUNC = s[0] === '' &&\n                    s[1] === '' &&\n                    (s[2] === '?' || !globMagic.test(s[2])) &&\n                    !globMagic.test(s[3]);\n                const isDrive = /^[a-z]:/i.test(s[0]);\n                if (isUNC) {\n                    return [...s.slice(0, 4), ...s.slice(4).map(ss => this.parse(ss))];\n                }\n                else if (isDrive) {\n                    return [s[0], ...s.slice(1).map(ss => this.parse(ss))];\n                }\n            }\n            return s.map(ss => this.parse(ss));\n        });\n        this.debug(this.pattern, set);\n        // filter out everything that didn't compile properly.\n        this.set = set.filter(s => s.indexOf(false) === -1);\n        // do not treat the ? in UNC paths as magic\n        if (this.isWindows) {\n            for (let i = 0; i < this.set.length; i++) {\n                const p = this.set[i];\n                if (p[0] === '' &&\n                    p[1] === '' &&\n                    this.globParts[i][2] === '?' &&\n                    typeof p[3] === 'string' &&\n                    /^[a-z]:$/i.test(p[3])) {\n                    p[2] = '?';\n                }\n            }\n        }\n        this.debug(this.pattern, this.set);\n    }\n    // various transforms to equivalent pattern sets that are\n    // faster to process in a filesystem walk.  The goal is to\n    // eliminate what we can, and push all ** patterns as far\n    // to the right as possible, even if it increases the number\n    // of patterns that we have to process.\n    preprocess(globParts) {\n        // if we're not in globstar mode, then turn all ** into *\n        if (this.options.noglobstar) {\n            for (let i = 0; i < globParts.length; i++) {\n                for (let j = 0; j < globParts[i].length; j++) {\n                    if (globParts[i][j] === '**') {\n                        globParts[i][j] = '*';\n                    }\n                }\n            }\n        }\n        const { optimizationLevel = 1 } = this.options;\n        if (optimizationLevel >= 2) {\n            // aggressive optimization for the purpose of fs walking\n            globParts = this.firstPhasePreProcess(globParts);\n            globParts = this.secondPhasePreProcess(globParts);\n        }\n        else if (optimizationLevel >= 1) {\n            // just basic optimizations to remove some .. parts\n            globParts = this.levelOneOptimize(globParts);\n        }\n        else {\n            // just collapse multiple ** portions into one\n            globParts = this.adjascentGlobstarOptimize(globParts);\n        }\n        return globParts;\n    }\n    // just get rid of adjascent ** portions\n    adjascentGlobstarOptimize(globParts) {\n        return globParts.map(parts => {\n            let gs = -1;\n            while (-1 !== (gs = parts.indexOf('**', gs + 1))) {\n                let i = gs;\n                while (parts[i + 1] === '**') {\n                    i++;\n                }\n                if (i !== gs) {\n                    parts.splice(gs, i - gs);\n                }\n            }\n            return parts;\n        });\n    }\n    // get rid of adjascent ** and resolve .. portions\n    levelOneOptimize(globParts) {\n        return globParts.map(parts => {\n            parts = parts.reduce((set, part) => {\n                const prev = set[set.length - 1];\n                if (part === '**' && prev === '**') {\n                    return set;\n                }\n                if (part === '..') {\n                    if (prev && prev !== '..' && prev !== '.' && prev !== '**') {\n                        set.pop();\n                        return set;\n                    }\n                }\n                set.push(part);\n                return set;\n            }, []);\n            return parts.length === 0 ? [''] : parts;\n        });\n    }\n    levelTwoFileOptimize(parts) {\n        if (!Array.isArray(parts)) {\n            parts = this.slashSplit(parts);\n        }\n        let didSomething = false;\n        do {\n            didSomething = false;\n            // <pre>/<e>/<rest> -> <pre>/<rest>\n            if (!this.preserveMultipleSlashes) {\n                for (let i = 1; i < parts.length - 1; i++) {\n                    const p = parts[i];\n                    // don't squeeze out UNC patterns\n                    if (i === 1 && p === '' && parts[0] === '')\n                        continue;\n                    if (p === '.' || p === '') {\n                        didSomething = true;\n                        parts.splice(i, 1);\n                        i--;\n                    }\n                }\n                if (parts[0] === '.' &&\n                    parts.length === 2 &&\n                    (parts[1] === '.' || parts[1] === '')) {\n                    didSomething = true;\n                    parts.pop();\n                }\n            }\n            // <pre>/<p>/../<rest> -> <pre>/<rest>\n            let dd = 0;\n            while (-1 !== (dd = parts.indexOf('..', dd + 1))) {\n                const p = parts[dd - 1];\n                if (p && p !== '.' && p !== '..' && p !== '**') {\n                    didSomething = true;\n                    parts.splice(dd - 1, 2);\n                    dd -= 2;\n                }\n            }\n        } while (didSomething);\n        return parts.length === 0 ? [''] : parts;\n    }\n    // First phase: single-pattern processing\n    // <pre> is 1 or more portions\n    // <rest> is 1 or more portions\n    // <p> is any portion other than ., .., '', or **\n    // <e> is . or ''\n    //\n    // **/.. is *brutal* for filesystem walking performance, because\n    // it effectively resets the recursive walk each time it occurs,\n    // and ** cannot be reduced out by a .. pattern part like a regexp\n    // or most strings (other than .., ., and '') can be.\n    //\n    // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}\n    // <pre>/<e>/<rest> -> <pre>/<rest>\n    // <pre>/<p>/../<rest> -> <pre>/<rest>\n    // **/**/<rest> -> **/<rest>\n    //\n    // **/*/<rest> -> */**/<rest> <== not valid because ** doesn't follow\n    // this WOULD be allowed if ** did follow symlinks, or * didn't\n    firstPhasePreProcess(globParts) {\n        let didSomething = false;\n        do {\n            didSomething = false;\n            // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}\n            for (let parts of globParts) {\n                let gs = -1;\n                while (-1 !== (gs = parts.indexOf('**', gs + 1))) {\n                    let gss = gs;\n                    while (parts[gss + 1] === '**') {\n                        // <pre>/**/**/<rest> -> <pre>/**/<rest>\n                        gss++;\n                    }\n                    // eg, if gs is 2 and gss is 4, that means we have 3 **\n                    // parts, and can remove 2 of them.\n                    if (gss > gs) {\n                        parts.splice(gs + 1, gss - gs);\n                    }\n                    let next = parts[gs + 1];\n                    const p = parts[gs + 2];\n                    const p2 = parts[gs + 3];\n                    if (next !== '..')\n                        continue;\n                    if (!p ||\n                        p === '.' ||\n                        p === '..' ||\n                        !p2 ||\n                        p2 === '.' ||\n                        p2 === '..') {\n                        continue;\n                    }\n                    didSomething = true;\n                    // edit parts in place, and push the new one\n                    parts.splice(gs, 1);\n                    const other = parts.slice(0);\n                    other[gs] = '**';\n                    globParts.push(other);\n                    gs--;\n                }\n                // <pre>/<e>/<rest> -> <pre>/<rest>\n                if (!this.preserveMultipleSlashes) {\n                    for (let i = 1; i < parts.length - 1; i++) {\n                        const p = parts[i];\n                        // don't squeeze out UNC patterns\n                        if (i === 1 && p === '' && parts[0] === '')\n                            continue;\n                        if (p === '.' || p === '') {\n                            didSomething = true;\n                            parts.splice(i, 1);\n                            i--;\n                        }\n                    }\n                    if (parts[0] === '.' &&\n                        parts.length === 2 &&\n                        (parts[1] === '.' || parts[1] === '')) {\n                        didSomething = true;\n                        parts.pop();\n                    }\n                }\n                // <pre>/<p>/../<rest> -> <pre>/<rest>\n                let dd = 0;\n                while (-1 !== (dd = parts.indexOf('..', dd + 1))) {\n                    const p = parts[dd - 1];\n                    if (p && p !== '.' && p !== '..' && p !== '**') {\n                        didSomething = true;\n                        const needDot = dd === 1 && parts[dd + 1] === '**';\n                        const splin = needDot ? ['.'] : [];\n                        parts.splice(dd - 1, 2, ...splin);\n                        if (parts.length === 0)\n                            parts.push('');\n                        dd -= 2;\n                    }\n                }\n            }\n        } while (didSomething);\n        return globParts;\n    }\n    // second phase: multi-pattern dedupes\n    // {<pre>/*/<rest>,<pre>/<p>/<rest>} -> <pre>/*/<rest>\n    // {<pre>/<rest>,<pre>/<rest>} -> <pre>/<rest>\n    // {<pre>/**/<rest>,<pre>/<rest>} -> <pre>/**/<rest>\n    //\n    // {<pre>/**/<rest>,<pre>/**/<p>/<rest>} -> <pre>/**/<rest>\n    // ^-- not valid because ** doens't follow symlinks\n    secondPhasePreProcess(globParts) {\n        for (let i = 0; i < globParts.length - 1; i++) {\n            for (let j = i + 1; j < globParts.length; j++) {\n                const matched = this.partsMatch(globParts[i], globParts[j], !this.preserveMultipleSlashes);\n                if (matched) {\n                    globParts[i] = [];\n                    globParts[j] = matched;\n                    break;\n                }\n            }\n        }\n        return globParts.filter(gs => gs.length);\n    }\n    partsMatch(a, b, emptyGSMatch = false) {\n        let ai = 0;\n        let bi = 0;\n        let result = [];\n        let which = '';\n        while (ai < a.length && bi < b.length) {\n            if (a[ai] === b[bi]) {\n                result.push(which === 'b' ? b[bi] : a[ai]);\n                ai++;\n                bi++;\n            }\n            else if (emptyGSMatch && a[ai] === '**' && b[bi] === a[ai + 1]) {\n                result.push(a[ai]);\n                ai++;\n            }\n            else if (emptyGSMatch && b[bi] === '**' && a[ai] === b[bi + 1]) {\n                result.push(b[bi]);\n                bi++;\n            }\n            else if (a[ai] === '*' &&\n                b[bi] &&\n                (this.options.dot || !b[bi].startsWith('.')) &&\n                b[bi] !== '**') {\n                if (which === 'b')\n                    return false;\n                which = 'a';\n                result.push(a[ai]);\n                ai++;\n                bi++;\n            }\n            else if (b[bi] === '*' &&\n                a[ai] &&\n                (this.options.dot || !a[ai].startsWith('.')) &&\n                a[ai] !== '**') {\n                if (which === 'a')\n                    return false;\n                which = 'b';\n                result.push(b[bi]);\n                ai++;\n                bi++;\n            }\n            else {\n                return false;\n            }\n        }\n        // if we fall out of the loop, it means they two are identical\n        // as long as their lengths match\n        return a.length === b.length && result;\n    }\n    parseNegate() {\n        if (this.nonegate)\n            return;\n        const pattern = this.pattern;\n        let negate = false;\n        let negateOffset = 0;\n        for (let i = 0; i < pattern.length && pattern.charAt(i) === '!'; i++) {\n            negate = !negate;\n            negateOffset++;\n        }\n        if (negateOffset)\n            this.pattern = pattern.slice(negateOffset);\n        this.negate = negate;\n    }\n    // set partial to true to test if, for example,\n    // \"/a/b\" matches the start of \"/*/b/*/d\"\n    // Partial means, if you run out of file before you run\n    // out of pattern, then that's fine, as long as all\n    // the parts match.\n    matchOne(file, pattern, partial = false) {\n        const options = this.options;\n        // UNC paths like //?/X:/... can match X:/... and vice versa\n        // Drive letters in absolute drive or unc paths are always compared\n        // case-insensitively.\n        if (this.isWindows) {\n            const fileDrive = typeof file[0] === 'string' && /^[a-z]:$/i.test(file[0]);\n            const fileUNC = !fileDrive &&\n                file[0] === '' &&\n                file[1] === '' &&\n                file[2] === '?' &&\n                /^[a-z]:$/i.test(file[3]);\n            const patternDrive = typeof pattern[0] === 'string' && /^[a-z]:$/i.test(pattern[0]);\n            const patternUNC = !patternDrive &&\n                pattern[0] === '' &&\n                pattern[1] === '' &&\n                pattern[2] === '?' &&\n                typeof pattern[3] === 'string' &&\n                /^[a-z]:$/i.test(pattern[3]);\n            const fdi = fileUNC ? 3 : fileDrive ? 0 : undefined;\n            const pdi = patternUNC ? 3 : patternDrive ? 0 : undefined;\n            if (typeof fdi === 'number' && typeof pdi === 'number') {\n                const [fd, pd] = [file[fdi], pattern[pdi]];\n                if (fd.toLowerCase() === pd.toLowerCase()) {\n                    pattern[pdi] = fd;\n                    if (pdi > fdi) {\n                        pattern = pattern.slice(pdi);\n                    }\n                    else if (fdi > pdi) {\n                        file = file.slice(fdi);\n                    }\n                }\n            }\n        }\n        // resolve and reduce . and .. portions in the file as well.\n        // dont' need to do the second phase, because it's only one string[]\n        const { optimizationLevel = 1 } = this.options;\n        if (optimizationLevel >= 2) {\n            file = this.levelTwoFileOptimize(file);\n        }\n        this.debug('matchOne', this, { file, pattern });\n        this.debug('matchOne', file.length, pattern.length);\n        for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {\n            this.debug('matchOne loop');\n            var p = pattern[pi];\n            var f = file[fi];\n            this.debug(pattern, p, f);\n            // should be impossible.\n            // some invalid regexp stuff in the set.\n            /* c8 ignore start */\n            if (p === false) {\n                return false;\n            }\n            /* c8 ignore stop */\n            if (p === GLOBSTAR) {\n                this.debug('GLOBSTAR', [pattern, p, f]);\n                // \"**\"\n                // a/**/b/**/c would match the following:\n                // a/b/x/y/z/c\n                // a/x/y/z/b/c\n                // a/b/x/b/x/c\n                // a/b/c\n                // To do this, take the rest of the pattern after\n                // the **, and see if it would match the file remainder.\n                // If so, return success.\n                // If not, the ** \"swallows\" a segment, and try again.\n                // This is recursively awful.\n                //\n                // a/**/b/**/c matching a/b/x/y/z/c\n                // - a matches a\n                // - doublestar\n                //   - matchOne(b/x/y/z/c, b/**/c)\n                //     - b matches b\n                //     - doublestar\n                //       - matchOne(x/y/z/c, c) -> no\n                //       - matchOne(y/z/c, c) -> no\n                //       - matchOne(z/c, c) -> no\n                //       - matchOne(c, c) yes, hit\n                var fr = fi;\n                var pr = pi + 1;\n                if (pr === pl) {\n                    this.debug('** at the end');\n                    // a ** at the end will just swallow the rest.\n                    // We have found a match.\n                    // however, it will not swallow /.x, unless\n                    // options.dot is set.\n                    // . and .. are *never* matched by **, for explosively\n                    // exponential reasons.\n                    for (; fi < fl; fi++) {\n                        if (file[fi] === '.' ||\n                            file[fi] === '..' ||\n                            (!options.dot && file[fi].charAt(0) === '.'))\n                            return false;\n                    }\n                    return true;\n                }\n                // ok, let's see if we can swallow whatever we can.\n                while (fr < fl) {\n                    var swallowee = file[fr];\n                    this.debug('\\nglobstar while', file, fr, pattern, pr, swallowee);\n                    // XXX remove this slice.  Just pass the start index.\n                    if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {\n                        this.debug('globstar found match!', fr, fl, swallowee);\n                        // found a match.\n                        return true;\n                    }\n                    else {\n                        // can't swallow \".\" or \"..\" ever.\n                        // can only swallow \".foo\" when explicitly asked.\n                        if (swallowee === '.' ||\n                            swallowee === '..' ||\n                            (!options.dot && swallowee.charAt(0) === '.')) {\n                            this.debug('dot detected!', file, fr, pattern, pr);\n                            break;\n                        }\n                        // ** swallows a segment, and continue.\n                        this.debug('globstar swallow a segment, and continue');\n                        fr++;\n                    }\n                }\n                // no match was found.\n                // However, in partial mode, we can't say this is necessarily over.\n                /* c8 ignore start */\n                if (partial) {\n                    // ran out of file\n                    this.debug('\\n>>> no match, partial?', file, fr, pattern, pr);\n                    if (fr === fl) {\n                        return true;\n                    }\n                }\n                /* c8 ignore stop */\n                return false;\n            }\n            // something other than **\n            // non-magic patterns just have to match exactly\n            // patterns with magic have been turned into regexps.\n            let hit;\n            if (typeof p === 'string') {\n                hit = f === p;\n                this.debug('string match', p, f, hit);\n            }\n            else {\n                hit = p.test(f);\n                this.debug('pattern match', p, f, hit);\n            }\n            if (!hit)\n                return false;\n        }\n        // Note: ending in / means that we'll get a final \"\"\n        // at the end of the pattern.  This can only match a\n        // corresponding \"\" at the end of the file.\n        // If the file ends in /, then it can only match a\n        // a pattern that ends in /, unless the pattern just\n        // doesn't have any more for it. But, a/b/ should *not*\n        // match \"a/b/*\", even though \"\" matches against the\n        // [^/]*? pattern, except in partial mode, where it might\n        // simply not be reached yet.\n        // However, a/b/ should still satisfy a/*\n        // now either we fell off the end of the pattern, or we're done.\n        if (fi === fl && pi === pl) {\n            // ran out of pattern and filename at the same time.\n            // an exact hit!\n            return true;\n        }\n        else if (fi === fl) {\n            // ran out of file, but still had pattern left.\n            // this is ok if we're doing the match as part of\n            // a glob fs traversal.\n            return partial;\n        }\n        else if (pi === pl) {\n            // ran out of pattern, still have file left.\n            // this is only acceptable if we're on the very last\n            // empty segment of a file with a trailing slash.\n            // a/* should match a/b/\n            return fi === fl - 1 && file[fi] === '';\n            /* c8 ignore start */\n        }\n        else {\n            // should be unreachable.\n            throw new Error('wtf?');\n        }\n        /* c8 ignore stop */\n    }\n    braceExpand() {\n        return braceExpand(this.pattern, this.options);\n    }\n    parse(pattern) {\n        assertValidPattern(pattern);\n        const options = this.options;\n        // shortcuts\n        if (pattern === '**')\n            return GLOBSTAR;\n        if (pattern === '')\n            return '';\n        // far and away, the most common glob pattern parts are\n        // *, *.*, and *.<ext>  Add a fast check method for those.\n        let m;\n        let fastTest = null;\n        if ((m = pattern.match(starRE))) {\n            fastTest = options.dot ? starTestDot : starTest;\n        }\n        else if ((m = pattern.match(starDotExtRE))) {\n            fastTest = (options.nocase\n                ? options.dot\n                    ? starDotExtTestNocaseDot\n                    : starDotExtTestNocase\n                : options.dot\n                    ? starDotExtTestDot\n                    : starDotExtTest)(m[1]);\n        }\n        else if ((m = pattern.match(qmarksRE))) {\n            fastTest = (options.nocase\n                ? options.dot\n                    ? qmarksTestNocaseDot\n                    : qmarksTestNocase\n                : options.dot\n                    ? qmarksTestDot\n                    : qmarksTest)(m);\n        }\n        else if ((m = pattern.match(starDotStarRE))) {\n            fastTest = options.dot ? starDotStarTestDot : starDotStarTest;\n        }\n        else if ((m = pattern.match(dotStarRE))) {\n            fastTest = dotStarTest;\n        }\n        const re = AST.fromGlob(pattern, this.options).toMMPattern();\n        if (fastTest && typeof re === 'object') {\n            // Avoids overriding in frozen environments\n            Reflect.defineProperty(re, 'test', { value: fastTest });\n        }\n        return re;\n    }\n    makeRe() {\n        if (this.regexp || this.regexp === false)\n            return this.regexp;\n        // at this point, this.set is a 2d array of partial\n        // pattern strings, or \"**\".\n        //\n        // It's better to use .match().  This function shouldn't\n        // be used, really, but it's pretty convenient sometimes,\n        // when you just want to work with a regex.\n        const set = this.set;\n        if (!set.length) {\n            this.regexp = false;\n            return this.regexp;\n        }\n        const options = this.options;\n        const twoStar = options.noglobstar\n            ? star\n            : options.dot\n                ? twoStarDot\n                : twoStarNoDot;\n        const flags = new Set(options.nocase ? ['i'] : []);\n        // regexpify non-globstar patterns\n        // if ** is only item, then we just do one twoStar\n        // if ** is first, and there are more, prepend (\\/|twoStar\\/)? to next\n        // if ** is last, append (\\/twoStar|) to previous\n        // if ** is in the middle, append (\\/|\\/twoStar\\/) to previous\n        // then filter out GLOBSTAR symbols\n        let re = set\n            .map(pattern => {\n            const pp = pattern.map(p => {\n                if (p instanceof RegExp) {\n                    for (const f of p.flags.split(''))\n                        flags.add(f);\n                }\n                return typeof p === 'string'\n                    ? regExpEscape(p)\n                    : p === GLOBSTAR\n                        ? GLOBSTAR\n                        : p._src;\n            });\n            pp.forEach((p, i) => {\n                const next = pp[i + 1];\n                const prev = pp[i - 1];\n                if (p !== GLOBSTAR || prev === GLOBSTAR) {\n                    return;\n                }\n                if (prev === undefined) {\n                    if (next !== undefined && next !== GLOBSTAR) {\n                        pp[i + 1] = '(?:\\\\/|' + twoStar + '\\\\/)?' + next;\n                    }\n                    else {\n                        pp[i] = twoStar;\n                    }\n                }\n                else if (next === undefined) {\n                    pp[i - 1] = prev + '(?:\\\\/|' + twoStar + ')?';\n                }\n                else if (next !== GLOBSTAR) {\n                    pp[i - 1] = prev + '(?:\\\\/|\\\\/' + twoStar + '\\\\/)' + next;\n                    pp[i + 1] = GLOBSTAR;\n                }\n            });\n            return pp.filter(p => p !== GLOBSTAR).join('/');\n        })\n            .join('|');\n        // need to wrap in parens if we had more than one thing with |,\n        // otherwise only the first will be anchored to ^ and the last to $\n        const [open, close] = set.length > 1 ? ['(?:', ')'] : ['', ''];\n        // must match entire pattern\n        // ending in a * or ** will make it less strict.\n        re = '^' + open + re + close + '$';\n        // can match anything, as long as it's not this.\n        if (this.negate)\n            re = '^(?!' + re + ').+$';\n        try {\n            this.regexp = new RegExp(re, [...flags].join(''));\n            /* c8 ignore start */\n        }\n        catch (ex) {\n            // should be impossible\n            this.regexp = false;\n        }\n        /* c8 ignore stop */\n        return this.regexp;\n    }\n    slashSplit(p) {\n        // if p starts with // on windows, we preserve that\n        // so that UNC paths aren't broken.  Otherwise, any number of\n        // / characters are coalesced into one, unless\n        // preserveMultipleSlashes is set to true.\n        if (this.preserveMultipleSlashes) {\n            return p.split('/');\n        }\n        else if (this.isWindows && /^\\/\\/[^\\/]+/.test(p)) {\n            // add an extra '' for the one we lose\n            return ['', ...p.split(/\\/+/)];\n        }\n        else {\n            return p.split(/\\/+/);\n        }\n    }\n    match(f, partial = this.partial) {\n        this.debug('match', f, this.pattern);\n        // short-circuit in the case of busted things.\n        // comments, etc.\n        if (this.comment) {\n            return false;\n        }\n        if (this.empty) {\n            return f === '';\n        }\n        if (f === '/' && partial) {\n            return true;\n        }\n        const options = this.options;\n        // windows: need to use /, not \\\n        if (this.isWindows) {\n            f = f.split('\\\\').join('/');\n        }\n        // treat the test path as a set of pathparts.\n        const ff = this.slashSplit(f);\n        this.debug(this.pattern, 'split', ff);\n        // just ONE of the pattern sets in this.set needs to match\n        // in order for it to be valid.  If negating, then just one\n        // match means that we have failed.\n        // Either way, return on the first hit.\n        const set = this.set;\n        this.debug(this.pattern, 'set', set);\n        // Find the basename of the path by looking for the last non-empty segment\n        let filename = ff[ff.length - 1];\n        if (!filename) {\n            for (let i = ff.length - 2; !filename && i >= 0; i--) {\n                filename = ff[i];\n            }\n        }\n        for (let i = 0; i < set.length; i++) {\n            const pattern = set[i];\n            let file = ff;\n            if (options.matchBase && pattern.length === 1) {\n                file = [filename];\n            }\n            const hit = this.matchOne(file, pattern, partial);\n            if (hit) {\n                if (options.flipNegate) {\n                    return true;\n                }\n                return !this.negate;\n            }\n        }\n        // didn't get any hits.  this is success if it's a negative\n        // pattern, failure otherwise.\n        if (options.flipNegate) {\n            return false;\n        }\n        return this.negate;\n    }\n    static defaults(def) {\n        return minimatch.defaults(def).Minimatch;\n    }\n}\n/* c8 ignore start */\nexport { AST } from './ast.js';\nexport { escape } from './escape.js';\nexport { unescape } from './unescape.js';\n/* c8 ignore stop */\nminimatch.AST = AST;\nminimatch.Minimatch = Minimatch;\nminimatch.escape = escape;\nminimatch.unescape = unescape;\n//# sourceMappingURL=index.js.map","import { minimatch } from 'minimatch';\n\nimport { encodeString } from './encoder';\nimport {\n    DirectoryOperationError,\n    ExistenceError,\n    FileTypeError,\n    OPFSNotSupportedError,\n    ValidationError,\n    mapDomError\n} from './errors';\n\nimport type { Encoding } from '../types';\n\n\n/**\n * Check if the browser supports the OPFS API\n * \n * @throws {OPFSNotSupportedError} If the browser does not support the OPFS API\n */\nexport function checkOPFSSupport(): void {\n    if (!('storage' in navigator) || !('getDirectory' in (navigator.storage as any))) {\n        throw new OPFSNotSupportedError();\n    }\n}\n\nexport async function withLock<T>(\n    path: string,\n    mode: 'shared' | 'exclusive',\n    fn: () => Promise<T>\n): Promise<T> {\n    if (typeof navigator !== 'undefined' && navigator.locks?.request) {\n        return navigator.locks.request(`opfs:${ path.replace(/\\/+/g, '/') }`, { mode }, fn);\n    }\n\n    return fn();\n}\n\n/** \n * Split a path into an array of segments\n * \n * @param path - The path to split\n * @returns The array of segments\n * \n * @example\n * ```typescript\n * splitPath('/path/to/file'); // ['path', 'to', 'file']\n * splitPath('~/path/to/file'); // ['path', 'to', 'file'] (home dir handled)\n * splitPath('relative/path'); // ['relative', 'path']\n * ```\n */\nexport function splitPath(path: string | string[]): string[] {\n    if (Array.isArray(path)) {\n        return path;\n    }\n\n    const normalizedPath = path.startsWith('~/') ? path.slice(2) : path;\n\n    return normalizedPath.split('/').filter(Boolean);\n}\n\n\n/**\n * Join an array of path segments into a single path\n * \n * @param segments - The array of path segments\n * @returns The joined path\n */\nexport function joinPath(segments: string[] | string): string {\n    return typeof segments === 'string'\n        ? (segments ?? '/')\n        : `/${ segments.join('/') }`;\n}\n\n/**\n * Extract the filename from a path\n * \n * @param path - The file path\n * @returns The filename without the directory path\n * \n * @example\n * ```typescript\n * basename('/path/to/file.txt'); // 'file.txt'\n * basename('/path/to/directory/'); // ''\n * basename('file.txt'); // 'file.txt'\n * ```\n */\nexport function basename(path: string): string {\n    const segments = splitPath(path);\n\n    return segments[segments.length - 1] || '';\n}\n\n/**\n * Extract the directory path from a file path\n * \n * @param path - The file path\n * @returns The directory path without the filename\n * \n * @example\n * ```typescript\n * dirname('/path/to/file.txt'); // '/path/to'\n * dirname('/path/to/directory/'); // '/path/to/directory'\n * dirname('file.txt'); // '/'\n * ```\n */\nexport function dirname(path: string): string {\n    const segments = splitPath(path);\n\n    segments.pop();\n\n    return joinPath(segments);\n}\n\n/**\n * Normalize a path to ensure it starts with '/'\n * \n * @param path - The path to normalize\n * @returns The normalized path\n * \n * @example\n * ```typescript\n * normalizePath('path/to/file'); // '/path/to/file'\n * normalizePath('/path/to/file'); // '/path/to/file'\n * normalizePath('~/path/to/file'); // '/path/to/file' (home dir normalized to root)\n * normalizePath(''); // '/'\n * ```\n */\nexport function normalizePath(path: string): string {\n    if (!path || path === '/') {\n        return '/';\n    }\n\n    if (path.startsWith('~/')) {\n        return `/${ path.slice(2) }`;\n    }\n\n    return path.startsWith('/') ? path : `/${ path }`;\n}\n\nexport function normalizeMinimatch(path: string, recursive: boolean = false): string {\n    path = path.replace(/\\/$/, '');\n    if (recursive && !path.includes('*')) {\n        return `${ path }/**`;\n    }\n\n    return path;\n}\n\nexport function matchMinimatch(path: string, pattern: string): boolean {\n    return minimatch(path, pattern, {\n        dot: true,\n        matchBase: true,\n    });\n}\n\n/**\n * Check if a path matches any of the provided exclude patterns (minimatch syntax)\n *\n * @param path - Absolute or relative path\n * @param patterns - Glob pattern(s) to match against\n * @returns true if excluded, false otherwise\n */\nexport function isPathExcluded(path: string, patterns?: string | string[]): boolean {\n    if (!patterns || (Array.isArray(patterns) && patterns.length === 0)) {\n        return false;\n    }\n\n    const normalized = normalizePath(path);\n    const list = Array.isArray(patterns) ? patterns : [patterns];\n\n    return list.some(pattern => minimatch(normalized, pattern, { dot: true }));\n}\n\n/**\n * Resolve a path to an absolute path, handling relative segments\n * \n * @param path - The path to resolve\n * @returns The resolved absolute path\n * \n * @example\n * ```typescript\n * resolvePath('./config/../data/file.txt'); // '/data/file.txt'\n * resolvePath('/path/to/../file.txt'); // '/path/file.txt'\n * resolvePath('../../file.txt'); // '/file.txt' (truncated to root)\n * resolvePath('~/config/../data/file.txt'); // '/data/file.txt' (home dir normalized to root)\n * ```\n */\nexport function resolvePath(path: string): string {\n    // First normalize the path to handle home directory references\n    const normalizedPath = normalizePath(path);\n    const segments = splitPath(normalizedPath);\n    const normalizedSegments: string[] = [];\n\n    for (const segment of segments) {\n        if (segment === '.' || segment === '') {\n            // Skip current directory references and empty segments\n            continue;\n        }\n        else if (segment === '..') {\n            if (normalizedSegments.length === 0) {\n                // Path escapes root, keep at root level\n                continue;\n            }\n\n            // Go up one directory\n            normalizedSegments.pop();\n        }\n        else {\n            normalizedSegments.push(segment);\n        }\n    }\n\n    return joinPath(normalizedSegments);\n}\n\n/**\n * Get the file extension from a path\n * \n * @param path - The file path\n * @returns The file extension including the dot, or empty string if no extension\n * \n * @example\n * ```typescript\n * extname('/path/to/file.txt'); // '.txt'\n * extname('/path/to/file'); // ''\n * extname('/path/to/file.name.ext'); // '.ext'\n * extname('/path/to/.hidden'); // ''\n * ```\n */\nexport function extname(path: string): string {\n    const filename = basename(path);\n    const lastDotIndex = filename.lastIndexOf('.');\n\n    if (lastDotIndex <= 0 || lastDotIndex === filename.length - 1) {\n        return '';\n    }\n\n    return filename.slice(lastDotIndex);\n}\n\nexport function createBuffer(data: string | Uint8Array | ArrayBuffer, encoding: Encoding = 'utf-8'): Uint8Array {\n    if (typeof data === 'string') {\n        return encodeString(data, encoding);\n    }\n\n    return data instanceof Uint8Array ? data : new Uint8Array(data);\n}\n\n/**\n * Calculate file hash using Web Crypto API\n * \n * @param buffer - The file content as File, ArrayBuffer, or Uint8Array\n * @param algorithm - Hash algorithm to use (default: 'SHA-1')\n * @param maxSize - Maximum file size in bytes. If file is larger, throws error (default: 50MB)\n * @returns Promise that resolves to the hash string\n * @throws Error if file size exceeds maxSize\n */\nexport async function calculateFileHash(\n    buffer: File | ArrayBuffer | Uint8Array,\n    algorithm: string = 'SHA-1',\n    maxSize: number = 50 * 1024 * 1024 // 50MB default\n): Promise<string> {\n    if (buffer instanceof File) {\n        buffer = await buffer.arrayBuffer();\n    }\n\n    // Check file size before processing\n    if (buffer.byteLength > maxSize) {\n        throw new Error(`File size ${ buffer.byteLength } bytes exceeds maximum allowed size ${ maxSize } bytes`);\n    }\n\n    const bufferSource = new Uint8Array(buffer);\n    const hashBuffer = await crypto.subtle.digest(algorithm, bufferSource);\n    const hashArray = Array.from(new Uint8Array(hashBuffer));\n\n    return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');\n}\n\n/**\n * Compare two Uint8Array buffers for equality\n * \n * @param a - First buffer\n * @param b - Second buffer\n * @returns true if buffers are equal, false otherwise\n */\nexport function buffersEqual(a: Uint8Array, b: Uint8Array): boolean {\n    if (a.length !== b.length) {\n        return false;\n    }\n\n    for (let i = 0; i < a.length; i++) {\n        if (a[i] !== b[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n/**\n * Convert a Blob to Uint8Array\n * \n * This function converts a Blob object to a Uint8Array for use with file operations.\n * It's useful when working with file uploads or other Blob data sources.\n * \n * @param blob - The Blob to convert\n * @returns Promise that resolves to the Uint8Array representation of the Blob\n * \n * @example\n * ```typescript\n * const fileInput = document.getElementById('file') as HTMLInputElement;\n * const file = fileInput.files?.[0];\n * if (file) {\n *   const data = await convertBlobToUint8Array(file);\n *   await fs.writeFile('/uploaded-file', data);\n * }\n * }\n * ```\n */\nexport async function convertBlobToUint8Array(blob: Blob): Promise<Uint8Array> {\n    const arrayBuffer = await blob.arrayBuffer();\n\n    return new Uint8Array(arrayBuffer);\n}\n\n/**\n * Remove a file or directory entry using a directory handle\n *\n * @param parentHandle - The parent directory handle\n * @param path - The full path of the entry to remove\n * @param options - Remove options (recursive, force, useTrash)\n */\nexport async function removeEntry(\n    parentHandle: FileSystemDirectoryHandle,\n    path: string,\n    options: { recursive?: boolean; force?: boolean; useTrash?: boolean } = {}\n): Promise<void> {\n    const name = basename(path);\n\n    return withLock(path, 'exclusive', async() => {\n        const recursive = options.recursive ?? false;\n        const force = options.force ?? false;\n\n        try {\n            await parentHandle.removeEntry(name, { recursive });\n        }\n        catch (e: any) {\n            if (e.name === 'NotFoundError') {\n                if (!force) {\n                    throw new ExistenceError('file', path, e);\n                }\n            }\n            else if (e.name === 'InvalidModificationError') {\n                throw new DirectoryOperationError('ENOTEMPTY', path, e);\n            }\n            else if (e.name === 'TypeMismatchError' && !recursive) {\n                throw new FileTypeError('directory', path, e);\n            }\n            else {\n                throw new DirectoryOperationError('RM_FAILED', path, e);\n            }\n        }\n    });\n}\n\n/**\n * Validate read/write arguments for file descriptor operations\n * \n * @param bufferLen - Length of the buffer\n * @param offset - Offset in the buffer\n * @param length - Number of bytes to read/write\n * @param position - Position in the file (null for current position)\n * @param opts - Options for validation\n * @throws {OPFSError} If arguments are invalid\n */\nexport function validateReadWriteArgs(\n    bufferLen: number,\n    offset: number,\n    length: number,\n    position: number | null | undefined\n): void {\n    if (!Number.isInteger(offset) || !Number.isInteger(length)) {\n        throw new ValidationError('argument', 'Invalid offset or length');\n    }\n\n    if (offset < 0 || length < 0) {\n        throw new ValidationError('argument', 'Negative offset or length not allowed');\n    }\n\n    if (offset + length > bufferLen) {\n        throw new ValidationError('overflow', 'Operation would overflow buffer');\n    }\n\n    if (position != null && (!Number.isInteger(position) || position < 0)) {\n        throw new ValidationError('argument', 'Invalid position');\n    }\n}\n\n/**\n * Safely close a file descriptor's sync handle\n * \n * @param fd - The file descriptor number (for logging)\n * @param syncHandle - The sync handle to close\n * @param path - The file path (for logging)\n */\nexport function safeCloseSyncHandle(fd: number, syncHandle: any, path: string): void {\n    try {\n        syncHandle.flush();\n        syncHandle.close();\n    }\n    catch (error) {\n        // Log warning but don't throw, as the fd should still be removed\n        console.warn(`Warning: Failed to properly close file descriptor ${ fd } (${ path }):`, error);\n    }\n}\n\n/**\n * Check if position is at or beyond end of file and calculate actual read length\n * \n * @param position - The position to read from\n * @param requestedLength - The requested length to read\n * @param fileSize - The current file size\n * @returns Object with isEOF flag and actual length to read\n */\nexport function calculateReadLength(position: number, requestedLength: number, fileSize: number): { isEOF: boolean; actualLength: number } {\n    // Check if we're at or beyond end of file\n    if (position >= fileSize) {\n        return { isEOF: true, actualLength: 0 };\n    }\n\n    // Calculate actual length to read (don't read beyond file end)\n    const actualLength = Math.min(requestedLength, fileSize - position);\n\n    if (actualLength <= 0) {\n        return { isEOF: true, actualLength: 0 };\n    }\n\n    return { isEOF: false, actualLength };\n}\n\n/**\n * Safely create a sync access handle with proper error mapping\n * \n * @param fileHandle - The file handle to create sync access handle from\n * @param path - The file path for error context\n * @returns Promise that resolves to FileSystemSyncAccessHandle\n * @throws {OPFSError} If creation fails\n */\nexport async function createSyncHandleSafe(\n    fileHandle: FileSystemFileHandle,\n    path: string\n): Promise<FileSystemSyncAccessHandle> {\n    try {\n        return await fileHandle.createSyncAccessHandle();\n    }\n    catch (error: any) {\n        throw mapDomError(error, { path, isDirectory: false });\n    }\n}\n"],"names":["ERROR_CODE_TO_ERRNO","OPFSError","message","code","path","syscall","cause","OPFSNotSupportedError","PathError","ExistenceError","type","messages","PermissionError","operation","StorageError","FileBusyError","FileTypeError","actualType","ValidationError","codes","OperationAbortedError","IOError","OperationNotSupportedError","DirectoryOperationError","InitializationFailedError","FileSystemOperationError","AlreadyExistsError","createFDError","fd","error","errorCode","mapDomError","context","isDirectory","BINARY_FILE_EXTENSIONS","isBinaryFileExtension","i","ext","encodeString","data","encoding","encodeUtf16LE","encodeAscii","encodeLatin1","char","c","b","decodeBuffer","buffer","decodeUtf16LE","str","buf","codeUnits","WatchEventType","balanced","a","ma","maybeMatch","mb","r","range","reg","m","begs","beg","left","right","result","ai","bi","escSlash","escOpen","escClose","escComma","escPeriod","escSlashPattern","escOpenPattern","escClosePattern","escCommaPattern","escPeriodPattern","slashPattern","openPattern","closePattern","commaPattern","periodPattern","numeric","escapeBraces","unescapeBraces","parseCommaParts","parts","pre","body","post","p","postParts","expand","expand_","embrace","isPadded","el","lte","y","gte","isTop","expansions","k","expansion","isNumericSequence","isAlphaSequence","isSequence","isOptions","n","N","x","width","incr","test","pad","need","z","j","MAX_PATTERN_LENGTH","assertValidPattern","pattern","posixClasses","braceEscape","regexpEscape","rangesToString","ranges","parseClass","glob","position","pos","negs","sawStart","uflag","escaping","negate","endPos","rangeStart","WHILE","cls","unip","u","neg","sranges","snegs","unescape","windowsPathsNoEscape","types","isExtglobType","startNoTraversal","startNoDot","addPatternStart","justDots","reSpecials","regExpEscape","qmark","star","starNoEmpty","AST","#root","#hasMagic","#uflag","#parts","#parent","#parentIndex","#negs","#filledNegs","#options","#toString","#emptyExt","parent","options","#fillNegs","pp","part","ret","pl","#parseAST","ast","opt","inBrace","braceStart","braceNeg","acc","re","hasMagic","flags","allowDot","dot","noEmpty","src","_","#parseGlob","start","aps","needNoTrav","needNoDot","end","repeated","#partsToRegExp","s","bodyDotAllowed","final","close","_hasMagic","needUflag","consumed","magic","escape","minimatch","Minimatch","starDotExtRE","starDotExtTest","f","starDotExtTestDot","starDotExtTestNocase","starDotExtTestNocaseDot","starDotStarRE","starDotStarTest","starDotStarTestDot","dotStarRE","dotStarTest","starRE","starTest","starTestDot","qmarksRE","qmarksTestNocase","$0","noext","qmarksTestNoExt","qmarksTestNocaseDot","qmarksTestNoExtDot","qmarksTestDot","qmarksTest","len","defaultPlatform","sep","GLOBSTAR","twoStarDot","twoStarNoDot","filter","defaults","def","orig","list","braceExpand","makeRe","match","mm","globMagic","args","rawGlobParts","set","__","isUNC","isDrive","ss","globParts","optimizationLevel","gs","prev","didSomething","dd","gss","next","p2","other","splin","matched","emptyGSMatch","which","negateOffset","file","partial","fileDrive","fileUNC","patternDrive","patternUNC","fdi","pdi","pd","fi","pi","fl","fr","pr","swallowee","hit","fastTest","twoStar","open","ff","filename","checkOPFSSupport","withLock","mode","fn","splitPath","joinPath","segments","basename","dirname","normalizePath","normalizeMinimatch","recursive","matchMinimatch","isPathExcluded","patterns","normalized","resolvePath","normalizedPath","normalizedSegments","segment","extname","lastDotIndex","createBuffer","calculateFileHash","algorithm","maxSize","bufferSource","hashBuffer","buffersEqual","convertBlobToUint8Array","blob","arrayBuffer","removeEntry","parentHandle","name","force","e","validateReadWriteArgs","bufferLen","offset","length","safeCloseSyncHandle","syncHandle","calculateReadLength","requestedLength","fileSize","actualLength","createSyncHandleSafe","fileHandle"],"mappings":"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","x_google_ignoreList":[3,4,5,6,7,8,9,10]}