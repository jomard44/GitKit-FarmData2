import type { Encoding } from '../types';
/**
 * Check if the browser supports the OPFS API
 *
 * @throws {OPFSNotSupportedError} If the browser does not support the OPFS API
 */
export declare function checkOPFSSupport(): void;
export declare function withLock<T>(path: string, mode: 'shared' | 'exclusive', fn: () => Promise<T>): Promise<T>;
/**
 * Split a path into an array of segments
 *
 * @param path - The path to split
 * @returns The array of segments
 *
 * @example
 * ```typescript
 * splitPath('/path/to/file'); // ['path', 'to', 'file']
 * splitPath('~/path/to/file'); // ['path', 'to', 'file'] (home dir handled)
 * splitPath('relative/path'); // ['relative', 'path']
 * ```
 */
export declare function splitPath(path: string | string[]): string[];
/**
 * Join an array of path segments into a single path
 *
 * @param segments - The array of path segments
 * @returns The joined path
 */
export declare function joinPath(segments: string[] | string): string;
/**
 * Extract the filename from a path
 *
 * @param path - The file path
 * @returns The filename without the directory path
 *
 * @example
 * ```typescript
 * basename('/path/to/file.txt'); // 'file.txt'
 * basename('/path/to/directory/'); // ''
 * basename('file.txt'); // 'file.txt'
 * ```
 */
export declare function basename(path: string): string;
/**
 * Extract the directory path from a file path
 *
 * @param path - The file path
 * @returns The directory path without the filename
 *
 * @example
 * ```typescript
 * dirname('/path/to/file.txt'); // '/path/to'
 * dirname('/path/to/directory/'); // '/path/to/directory'
 * dirname('file.txt'); // '/'
 * ```
 */
export declare function dirname(path: string): string;
/**
 * Normalize a path to ensure it starts with '/'
 *
 * @param path - The path to normalize
 * @returns The normalized path
 *
 * @example
 * ```typescript
 * normalizePath('path/to/file'); // '/path/to/file'
 * normalizePath('/path/to/file'); // '/path/to/file'
 * normalizePath('~/path/to/file'); // '/path/to/file' (home dir normalized to root)
 * normalizePath(''); // '/'
 * ```
 */
export declare function normalizePath(path: string): string;
export declare function normalizeMinimatch(path: string, recursive?: boolean): string;
export declare function matchMinimatch(path: string, pattern: string): boolean;
/**
 * Check if a path matches any of the provided exclude patterns (minimatch syntax)
 *
 * @param path - Absolute or relative path
 * @param patterns - Glob pattern(s) to match against
 * @returns true if excluded, false otherwise
 */
export declare function isPathExcluded(path: string, patterns?: string | string[]): boolean;
/**
 * Resolve a path to an absolute path, handling relative segments
 *
 * @param path - The path to resolve
 * @returns The resolved absolute path
 *
 * @example
 * ```typescript
 * resolvePath('./config/../data/file.txt'); // '/data/file.txt'
 * resolvePath('/path/to/../file.txt'); // '/path/file.txt'
 * resolvePath('../../file.txt'); // '/file.txt' (truncated to root)
 * resolvePath('~/config/../data/file.txt'); // '/data/file.txt' (home dir normalized to root)
 * ```
 */
export declare function resolvePath(path: string): string;
/**
 * Get the file extension from a path
 *
 * @param path - The file path
 * @returns The file extension including the dot, or empty string if no extension
 *
 * @example
 * ```typescript
 * extname('/path/to/file.txt'); // '.txt'
 * extname('/path/to/file'); // ''
 * extname('/path/to/file.name.ext'); // '.ext'
 * extname('/path/to/.hidden'); // ''
 * ```
 */
export declare function extname(path: string): string;
export declare function createBuffer(data: string | Uint8Array | ArrayBuffer, encoding?: Encoding): Uint8Array;
/**
 * Calculate file hash using Web Crypto API
 *
 * @param buffer - The file content as File, ArrayBuffer, or Uint8Array
 * @param algorithm - Hash algorithm to use (default: 'SHA-1')
 * @param maxSize - Maximum file size in bytes. If file is larger, throws error (default: 50MB)
 * @returns Promise that resolves to the hash string
 * @throws Error if file size exceeds maxSize
 */
export declare function calculateFileHash(buffer: File | ArrayBuffer | Uint8Array, algorithm?: string, maxSize?: number): Promise<string>;
/**
 * Compare two Uint8Array buffers for equality
 *
 * @param a - First buffer
 * @param b - Second buffer
 * @returns true if buffers are equal, false otherwise
 */
export declare function buffersEqual(a: Uint8Array, b: Uint8Array): boolean;
/**
 * Convert a Blob to Uint8Array
 *
 * This function converts a Blob object to a Uint8Array for use with file operations.
 * It's useful when working with file uploads or other Blob data sources.
 *
 * @param blob - The Blob to convert
 * @returns Promise that resolves to the Uint8Array representation of the Blob
 *
 * @example
 * ```typescript
 * const fileInput = document.getElementById('file') as HTMLInputElement;
 * const file = fileInput.files?.[0];
 * if (file) {
 *   const data = await convertBlobToUint8Array(file);
 *   await fs.writeFile('/uploaded-file', data);
 * }
 * }
 * ```
 */
export declare function convertBlobToUint8Array(blob: Blob): Promise<Uint8Array>;
/**
 * Remove a file or directory entry using a directory handle
 *
 * @param parentHandle - The parent directory handle
 * @param path - The full path of the entry to remove
 * @param options - Remove options (recursive, force, useTrash)
 */
export declare function removeEntry(parentHandle: FileSystemDirectoryHandle, path: string, options?: {
    recursive?: boolean;
    force?: boolean;
    useTrash?: boolean;
}): Promise<void>;
/**
 * Validate read/write arguments for file descriptor operations
 *
 * @param bufferLen - Length of the buffer
 * @param offset - Offset in the buffer
 * @param length - Number of bytes to read/write
 * @param position - Position in the file (null for current position)
 * @param opts - Options for validation
 * @throws {OPFSError} If arguments are invalid
 */
export declare function validateReadWriteArgs(bufferLen: number, offset: number, length: number, position: number | null | undefined): void;
/**
 * Safely close a file descriptor's sync handle
 *
 * @param fd - The file descriptor number (for logging)
 * @param syncHandle - The sync handle to close
 * @param path - The file path (for logging)
 */
export declare function safeCloseSyncHandle(fd: number, syncHandle: any, path: string): void;
/**
 * Check if position is at or beyond end of file and calculate actual read length
 *
 * @param position - The position to read from
 * @param requestedLength - The requested length to read
 * @param fileSize - The current file size
 * @returns Object with isEOF flag and actual length to read
 */
export declare function calculateReadLength(position: number, requestedLength: number, fileSize: number): {
    isEOF: boolean;
    actualLength: number;
};
/**
 * Safely create a sync access handle with proper error mapping
 *
 * @param fileHandle - The file handle to create sync access handle from
 * @param path - The file path for error context
 * @returns Promise that resolves to FileSystemSyncAccessHandle
 * @throws {OPFSError} If creation fails
 */
export declare function createSyncHandleSafe(fileHandle: FileSystemFileHandle, path: string): Promise<FileSystemSyncAccessHandle>;
//# sourceMappingURL=helpers.d.ts.map