{"version":3,"file":"worker-BeJaVyBV.js","sources":["../node_modules/comlink/dist/esm/comlink.mjs","../src/types.ts","../src/utils/errors.ts","../node_modules/@isaacs/balanced-match/dist/esm/index.js","../node_modules/@isaacs/brace-expansion/dist/esm/index.js","../node_modules/minimatch/dist/esm/assert-valid-pattern.js","../node_modules/minimatch/dist/esm/brace-expressions.js","../node_modules/minimatch/dist/esm/unescape.js","../node_modules/minimatch/dist/esm/ast.js","../node_modules/minimatch/dist/esm/escape.js","../node_modules/minimatch/dist/esm/index.js","../src/utils/helpers.ts","../src/worker.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nconst proxyMarker = Symbol(\"Comlink.proxy\");\nconst createEndpoint = Symbol(\"Comlink.endpoint\");\nconst releaseProxy = Symbol(\"Comlink.releaseProxy\");\nconst finalizer = Symbol(\"Comlink.finalizer\");\nconst throwMarker = Symbol(\"Comlink.thrown\");\nconst isObject = (val) => (typeof val === \"object\" && val !== null) || typeof val === \"function\";\n/**\n * Internal transfer handle to handle objects marked to proxy.\n */\nconst proxyTransferHandler = {\n    canHandle: (val) => isObject(val) && val[proxyMarker],\n    serialize(obj) {\n        const { port1, port2 } = new MessageChannel();\n        expose(obj, port1);\n        return [port2, [port2]];\n    },\n    deserialize(port) {\n        port.start();\n        return wrap(port);\n    },\n};\n/**\n * Internal transfer handler to handle thrown exceptions.\n */\nconst throwTransferHandler = {\n    canHandle: (value) => isObject(value) && throwMarker in value,\n    serialize({ value }) {\n        let serialized;\n        if (value instanceof Error) {\n            serialized = {\n                isError: true,\n                value: {\n                    message: value.message,\n                    name: value.name,\n                    stack: value.stack,\n                },\n            };\n        }\n        else {\n            serialized = { isError: false, value };\n        }\n        return [serialized, []];\n    },\n    deserialize(serialized) {\n        if (serialized.isError) {\n            throw Object.assign(new Error(serialized.value.message), serialized.value);\n        }\n        throw serialized.value;\n    },\n};\n/**\n * Allows customizing the serialization of certain values.\n */\nconst transferHandlers = new Map([\n    [\"proxy\", proxyTransferHandler],\n    [\"throw\", throwTransferHandler],\n]);\nfunction isAllowedOrigin(allowedOrigins, origin) {\n    for (const allowedOrigin of allowedOrigins) {\n        if (origin === allowedOrigin || allowedOrigin === \"*\") {\n            return true;\n        }\n        if (allowedOrigin instanceof RegExp && allowedOrigin.test(origin)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction expose(obj, ep = globalThis, allowedOrigins = [\"*\"]) {\n    ep.addEventListener(\"message\", function callback(ev) {\n        if (!ev || !ev.data) {\n            return;\n        }\n        if (!isAllowedOrigin(allowedOrigins, ev.origin)) {\n            console.warn(`Invalid origin '${ev.origin}' for comlink proxy`);\n            return;\n        }\n        const { id, type, path } = Object.assign({ path: [] }, ev.data);\n        const argumentList = (ev.data.argumentList || []).map(fromWireValue);\n        let returnValue;\n        try {\n            const parent = path.slice(0, -1).reduce((obj, prop) => obj[prop], obj);\n            const rawValue = path.reduce((obj, prop) => obj[prop], obj);\n            switch (type) {\n                case \"GET\" /* MessageType.GET */:\n                    {\n                        returnValue = rawValue;\n                    }\n                    break;\n                case \"SET\" /* MessageType.SET */:\n                    {\n                        parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);\n                        returnValue = true;\n                    }\n                    break;\n                case \"APPLY\" /* MessageType.APPLY */:\n                    {\n                        returnValue = rawValue.apply(parent, argumentList);\n                    }\n                    break;\n                case \"CONSTRUCT\" /* MessageType.CONSTRUCT */:\n                    {\n                        const value = new rawValue(...argumentList);\n                        returnValue = proxy(value);\n                    }\n                    break;\n                case \"ENDPOINT\" /* MessageType.ENDPOINT */:\n                    {\n                        const { port1, port2 } = new MessageChannel();\n                        expose(obj, port2);\n                        returnValue = transfer(port1, [port1]);\n                    }\n                    break;\n                case \"RELEASE\" /* MessageType.RELEASE */:\n                    {\n                        returnValue = undefined;\n                    }\n                    break;\n                default:\n                    return;\n            }\n        }\n        catch (value) {\n            returnValue = { value, [throwMarker]: 0 };\n        }\n        Promise.resolve(returnValue)\n            .catch((value) => {\n            return { value, [throwMarker]: 0 };\n        })\n            .then((returnValue) => {\n            const [wireValue, transferables] = toWireValue(returnValue);\n            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);\n            if (type === \"RELEASE\" /* MessageType.RELEASE */) {\n                // detach and deactive after sending release response above.\n                ep.removeEventListener(\"message\", callback);\n                closeEndPoint(ep);\n                if (finalizer in obj && typeof obj[finalizer] === \"function\") {\n                    obj[finalizer]();\n                }\n            }\n        })\n            .catch((error) => {\n            // Send Serialization Error To Caller\n            const [wireValue, transferables] = toWireValue({\n                value: new TypeError(\"Unserializable return value\"),\n                [throwMarker]: 0,\n            });\n            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);\n        });\n    });\n    if (ep.start) {\n        ep.start();\n    }\n}\nfunction isMessagePort(endpoint) {\n    return endpoint.constructor.name === \"MessagePort\";\n}\nfunction closeEndPoint(endpoint) {\n    if (isMessagePort(endpoint))\n        endpoint.close();\n}\nfunction wrap(ep, target) {\n    const pendingListeners = new Map();\n    ep.addEventListener(\"message\", function handleMessage(ev) {\n        const { data } = ev;\n        if (!data || !data.id) {\n            return;\n        }\n        const resolver = pendingListeners.get(data.id);\n        if (!resolver) {\n            return;\n        }\n        try {\n            resolver(data);\n        }\n        finally {\n            pendingListeners.delete(data.id);\n        }\n    });\n    return createProxy(ep, pendingListeners, [], target);\n}\nfunction throwIfProxyReleased(isReleased) {\n    if (isReleased) {\n        throw new Error(\"Proxy has been released and is not useable\");\n    }\n}\nfunction releaseEndpoint(ep) {\n    return requestResponseMessage(ep, new Map(), {\n        type: \"RELEASE\" /* MessageType.RELEASE */,\n    }).then(() => {\n        closeEndPoint(ep);\n    });\n}\nconst proxyCounter = new WeakMap();\nconst proxyFinalizers = \"FinalizationRegistry\" in globalThis &&\n    new FinalizationRegistry((ep) => {\n        const newCount = (proxyCounter.get(ep) || 0) - 1;\n        proxyCounter.set(ep, newCount);\n        if (newCount === 0) {\n            releaseEndpoint(ep);\n        }\n    });\nfunction registerProxy(proxy, ep) {\n    const newCount = (proxyCounter.get(ep) || 0) + 1;\n    proxyCounter.set(ep, newCount);\n    if (proxyFinalizers) {\n        proxyFinalizers.register(proxy, ep, proxy);\n    }\n}\nfunction unregisterProxy(proxy) {\n    if (proxyFinalizers) {\n        proxyFinalizers.unregister(proxy);\n    }\n}\nfunction createProxy(ep, pendingListeners, path = [], target = function () { }) {\n    let isProxyReleased = false;\n    const proxy = new Proxy(target, {\n        get(_target, prop) {\n            throwIfProxyReleased(isProxyReleased);\n            if (prop === releaseProxy) {\n                return () => {\n                    unregisterProxy(proxy);\n                    releaseEndpoint(ep);\n                    pendingListeners.clear();\n                    isProxyReleased = true;\n                };\n            }\n            if (prop === \"then\") {\n                if (path.length === 0) {\n                    return { then: () => proxy };\n                }\n                const r = requestResponseMessage(ep, pendingListeners, {\n                    type: \"GET\" /* MessageType.GET */,\n                    path: path.map((p) => p.toString()),\n                }).then(fromWireValue);\n                return r.then.bind(r);\n            }\n            return createProxy(ep, pendingListeners, [...path, prop]);\n        },\n        set(_target, prop, rawValue) {\n            throwIfProxyReleased(isProxyReleased);\n            // FIXME: ES6 Proxy Handler `set` methods are supposed to return a\n            // boolean. To show good will, we return true asynchronously ¯\\_(ツ)_/¯\n            const [value, transferables] = toWireValue(rawValue);\n            return requestResponseMessage(ep, pendingListeners, {\n                type: \"SET\" /* MessageType.SET */,\n                path: [...path, prop].map((p) => p.toString()),\n                value,\n            }, transferables).then(fromWireValue);\n        },\n        apply(_target, _thisArg, rawArgumentList) {\n            throwIfProxyReleased(isProxyReleased);\n            const last = path[path.length - 1];\n            if (last === createEndpoint) {\n                return requestResponseMessage(ep, pendingListeners, {\n                    type: \"ENDPOINT\" /* MessageType.ENDPOINT */,\n                }).then(fromWireValue);\n            }\n            // We just pretend that `bind()` didn’t happen.\n            if (last === \"bind\") {\n                return createProxy(ep, pendingListeners, path.slice(0, -1));\n            }\n            const [argumentList, transferables] = processArguments(rawArgumentList);\n            return requestResponseMessage(ep, pendingListeners, {\n                type: \"APPLY\" /* MessageType.APPLY */,\n                path: path.map((p) => p.toString()),\n                argumentList,\n            }, transferables).then(fromWireValue);\n        },\n        construct(_target, rawArgumentList) {\n            throwIfProxyReleased(isProxyReleased);\n            const [argumentList, transferables] = processArguments(rawArgumentList);\n            return requestResponseMessage(ep, pendingListeners, {\n                type: \"CONSTRUCT\" /* MessageType.CONSTRUCT */,\n                path: path.map((p) => p.toString()),\n                argumentList,\n            }, transferables).then(fromWireValue);\n        },\n    });\n    registerProxy(proxy, ep);\n    return proxy;\n}\nfunction myFlat(arr) {\n    return Array.prototype.concat.apply([], arr);\n}\nfunction processArguments(argumentList) {\n    const processed = argumentList.map(toWireValue);\n    return [processed.map((v) => v[0]), myFlat(processed.map((v) => v[1]))];\n}\nconst transferCache = new WeakMap();\nfunction transfer(obj, transfers) {\n    transferCache.set(obj, transfers);\n    return obj;\n}\nfunction proxy(obj) {\n    return Object.assign(obj, { [proxyMarker]: true });\n}\nfunction windowEndpoint(w, context = globalThis, targetOrigin = \"*\") {\n    return {\n        postMessage: (msg, transferables) => w.postMessage(msg, targetOrigin, transferables),\n        addEventListener: context.addEventListener.bind(context),\n        removeEventListener: context.removeEventListener.bind(context),\n    };\n}\nfunction toWireValue(value) {\n    for (const [name, handler] of transferHandlers) {\n        if (handler.canHandle(value)) {\n            const [serializedValue, transferables] = handler.serialize(value);\n            return [\n                {\n                    type: \"HANDLER\" /* WireValueType.HANDLER */,\n                    name,\n                    value: serializedValue,\n                },\n                transferables,\n            ];\n        }\n    }\n    return [\n        {\n            type: \"RAW\" /* WireValueType.RAW */,\n            value,\n        },\n        transferCache.get(value) || [],\n    ];\n}\nfunction fromWireValue(value) {\n    switch (value.type) {\n        case \"HANDLER\" /* WireValueType.HANDLER */:\n            return transferHandlers.get(value.name).deserialize(value.value);\n        case \"RAW\" /* WireValueType.RAW */:\n            return value.value;\n    }\n}\nfunction requestResponseMessage(ep, pendingListeners, msg, transfers) {\n    return new Promise((resolve) => {\n        const id = generateUUID();\n        pendingListeners.set(id, resolve);\n        if (ep.start) {\n            ep.start();\n        }\n        ep.postMessage(Object.assign({ id }, msg), transfers);\n    });\n}\nfunction generateUUID() {\n    return new Array(4)\n        .fill(0)\n        .map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16))\n        .join(\"-\");\n}\n\nexport { createEndpoint, expose, finalizer, proxy, proxyMarker, releaseProxy, transfer, transferHandlers, windowEndpoint, wrap };\n//# sourceMappingURL=comlink.mjs.map\n","import type { OPFSWorker } from './worker';\nimport type { Remote } from 'comlink';\n\n/**\n * Type for paths that can be either a string or URI\n */\nexport type PathLike = string | URL;\n\nexport type Kind = 'file' | 'directory';\n\nexport type StringEncoding = 'ascii'\n  | 'utf8'\n  | 'utf-8'\n  | 'utf16le'\n  | 'utf-16le'\n  | 'ucs2'\n  | 'ucs-2'\n  | 'base64'\n  | 'latin1'\n  | 'hex';\n\nexport type BinaryEncoding = 'binary';\n\nexport type Encoding = StringEncoding | BinaryEncoding;\n\nexport interface FileStat {\n    kind: Kind;\n    size: number;\n    mtime: string; // ISO string\n    ctime: string; // ISO string\n    isFile: boolean;\n    isDirectory: boolean;\n    /** Hash of file content (only for files, undefined for directories) */\n    hash?: string;\n}\n\nexport interface DirentData {\n    name: string;\n    kind: 'file' | 'directory';\n    isFile: boolean;\n    isDirectory: boolean;\n}\n\nexport enum WatchEventType {\n    Added = 'added',\n    Changed = 'changed',\n    Removed = 'removed'\n}\n\nexport interface WatchEvent {\n    namespace: string;\n    path: string;\n    type: WatchEventType;\n    isDirectory: boolean;\n    timestamp: string;\n    hash?: string;\n}\n\nexport type { OPFSWorker };\nexport type RemoteOPFSWorker = Remote<OPFSWorker>;\n\nexport interface OPFSOptions {\n    /** Root path for the file system (default: '/') */\n    root?: string;\n    /** Namespace for the events (default: 'opfs-worker:${root}') */\n    namespace?: string;\n    /** Hash algorithm for file hashing, or false/null to disable (default: 'etag') */\n    hashAlgorithm?: null | false | 'etag' | 'SHA-1' | 'SHA-256' | 'SHA-384' | 'SHA-512';\n    /** Maximum file size in bytes for hashing (default: 50MB) */\n    maxFileSize?: number;\n    /** Custom name for the broadcast channel (default: 'opfs-worker') */\n    broadcastChannel?: string | BroadcastChannel | null;\n}\n\nexport interface RenameOptions {\n    /** Whether to overwrite existing files (default: false) */\n    overwrite?: boolean;\n}\n\nexport interface WatchOptions {\n    /** Whether to watch recursively (default: true) */\n    recursive?: boolean;\n    /** Glob patterns to include in watching (minimatch syntax, default: ['**']) */\n    include?: string | string[];\n    /** Glob patterns to exclude from watching (minimatch syntax, default: []) */\n    exclude?: string | string[];\n}\n\nexport interface FileOpenOptions {\n    create?: boolean;\n    exclusive?: boolean;\n    truncate?: boolean;\n}\n\nexport interface WatchSnapshot {\n    pattern: string;\n    include: string[];\n    exclude: string[];\n}\n","/**\n * Error code to numeric errno mapping (Node.js compatible)\n */\nconst ERROR_CODE_TO_ERRNO: Record<string, number> = {\n    ENOENT: -2, // No such file or directory\n    EISDIR: -21, // Is a directory\n    ENOTDIR: -20, // Not a directory\n    EACCES: -13, // Permission denied\n    EEXIST: -17, // File exists\n    ENOTEMPTY: -39, // Directory not empty\n    EINVAL: -22, // Invalid argument\n    EIO: -5, // I/O error\n    ENOSPC: -28, // No space left on device\n    EBUSY: -16, // Device or resource busy\n    EINTR: -4, // Interrupted system call\n    ENOTSUP: -95, // Operation not supported\n    ERANGE: -34, // Result too large\n    EBADF: -9, // Bad file descriptor\n    EROOT: -1, // Custom: Cannot remove root directory\n};\n\n/**\n * Base error class for all OPFS-related errors (Node.js SystemError compatible)\n */\nexport class OPFSError extends Error {\n    public readonly errno: number;\n    public readonly syscall?: string;\n    public readonly path?: string;\n\n    constructor(\n        message: string,\n        code: string,\n        path?: string,\n        syscall?: string,\n        cause?: any\n    ) {\n        super(message, { cause });\n        this.name = code;\n        this.errno = ERROR_CODE_TO_ERRNO[code] || -1;\n        this.path = path;\n        this.syscall = syscall;\n    }\n}\n\n/**\n * Error thrown when OPFS is not supported in the current browser\n */\nexport class OPFSNotSupportedError extends OPFSError {\n    constructor(cause?: unknown) {\n        super('OPFS is not supported in this browser', 'ENOTSUP', undefined, undefined, cause);\n    }\n}\n\n/**\n * Error thrown for invalid paths or path traversal attempts\n */\nexport class PathError extends OPFSError {\n    constructor(message: string, path: string, cause?: unknown) {\n        super(message, 'INVALID_PATH', path, 'access', cause);\n    }\n}\n\n/**\n * Error thrown when files or directories don't exist\n */\nexport class ExistenceError extends OPFSError {\n    constructor(type: 'file' | 'directory' | 'source', path: string, cause?: unknown) {\n        const messages = {\n            file: `File not found: ${ path }`,\n            directory: `Directory not found: ${ path }`,\n            source: `Source does not exist: ${ path }`,\n        };\n\n        super(messages[type], 'ENOENT', path, 'access', cause);\n    }\n}\n\n/**\n * Error thrown when permission is denied for an operation\n */\nexport class PermissionError extends OPFSError {\n    constructor(path: string, operation: string, cause?: unknown) {\n        super(`Permission denied for ${ operation } on: ${ path }`, 'EACCES', path, operation, cause);\n    }\n}\n\n/**\n * Error thrown when an operation fails due to insufficient storage\n */\nexport class StorageError extends OPFSError {\n    constructor(message: string, path?: string, cause?: unknown) {\n        super(message, 'ENOSPC', path, 'write', cause);\n    }\n}\n\n/**\n * Error thrown when a file is busy (locked by another operation)\n */\nexport class FileBusyError extends OPFSError {\n    constructor(path: string, cause?: unknown) {\n        super(`File is busy: ${ path }`, 'EBUSY', path, 'open', cause);\n    }\n}\n\n/**\n * Error thrown when file/directory type expectations don't match\n */\nexport class FileTypeError extends OPFSError {\n    constructor(actualType: 'file' | 'directory', path: string, cause?: unknown) {\n        const message = actualType === 'directory'\n            ? `Is a directory: ${ path }`\n            : `Not a directory: ${ path }`;\n        const code = actualType === 'directory' ? 'EISDIR' : 'ENOTDIR';\n\n        super(message, code, path, 'access', cause);\n    }\n}\n\n/**\n * Error thrown for validation failures (invalid arguments, formats, etc.)\n */\nexport class ValidationError extends OPFSError {\n    constructor(type: 'argument' | 'format' | 'descriptor' | 'overflow', message: string, path?: string, cause?: unknown) {\n        const codes = {\n            argument: 'EINVAL',\n            format: 'INVALID_FORMAT',\n            descriptor: 'EBADF',\n            overflow: 'ERANGE',\n        };\n\n        super(message, codes[type], path, 'validate', cause);\n    }\n}\n\n/**\n * Error thrown when an operation is aborted\n */\nexport class OperationAbortedError extends OPFSError {\n    constructor(path: string, cause?: unknown) {\n        super(`Operation aborted: ${ path }`, 'EINTR', path, 'interrupt', cause);\n    }\n}\n\n/**\n * Error thrown for I/O operation failures\n */\nexport class IOError extends OPFSError {\n    constructor(message: string, path?: string, cause?: unknown) {\n        super(message, 'EIO', path, 'io', cause);\n    }\n}\n\n/**\n * Error thrown when an operation is not supported\n */\nexport class OperationNotSupportedError extends OPFSError {\n    constructor(path: string, cause?: unknown) {\n        super(`Operation not supported: ${ path }`, 'ENOTSUP', path, 'operation', cause);\n    }\n}\n\n/**\n * Error thrown when directory operations fail\n */\nexport class DirectoryOperationError extends OPFSError {\n    constructor(code: string, path: string, cause?: unknown) {\n        const messages = {\n            RM_FAILED: `Failed to remove entry: ${ path }`,\n            ENOTEMPTY: `Directory not empty: ${ path }. Use recursive option to force removal.`,\n            EROOT: 'Cannot remove root directory',\n        };\n\n        super(messages[code as keyof typeof messages] || `Directory operation failed: ${ path }`, code, path, 'unlink', cause);\n    }\n}\n\n\n/**\n * Error thrown when OPFS initialization fails\n */\nexport class InitializationFailedError extends OPFSError {\n    constructor(path: string, cause?: unknown) {\n        super('Failed to initialize OPFS', 'INIT_FAILED', path, 'init', cause);\n    }\n}\n\n/**\n * Error thrown when file system operations fail\n */\nexport class FileSystemOperationError extends OPFSError {\n    constructor(operation: string, path: string, cause?: unknown) {\n        super(`Failed to ${ operation }: ${ path }`, `${ operation.toUpperCase() }_FAILED`, path, operation, cause);\n    }\n}\n\n/**\n * Error thrown when a file or directory already exists\n */\nexport class AlreadyExistsError extends OPFSError {\n    constructor(path: string, cause?: unknown) {\n        super(`Destination already exists: ${ path }`, 'EEXIST', path, 'open', cause);\n    }\n}\n\n/**\n * Create an OPFSError with file descriptor context\n * \n * @param operation - The operation that failed (e.g., 'read', 'write', 'close')\n * @param fd - The file descriptor number\n * @param path - The file path\n * @param error - The underlying error (optional)\n * @returns OPFSError with appropriate context\n */\nexport function createFDError(operation: string, fd: number, path: string, error?: any): OPFSError {\n    const errorCode = `${ operation.toUpperCase() }_FAILED` as 'READ_FAILED' | 'WRITE_FAILED' | 'CLOSE_FAILED';\n\n    return new OPFSError(`Failed to ${ operation } file descriptor: ${ fd }`, errorCode, path, operation, error);\n}\n\n/**\n * Map DOM exceptions to OPFS error codes\n * \n * @param error - The DOM exception to map\n * @param context - Context information for better error mapping\n * @param context.path - File path for context-specific errors\n * @param context.isDirectory - Whether the operation involves a directory\n * @returns OPFSError with appropriate error code\n */\nexport function mapDomError(error: any, context?: { path?: string; isDirectory?: boolean }): OPFSError {\n    const path = context?.path;\n    const isDirectory = context?.isDirectory;\n\n    switch (error.name) {\n        case 'InvalidStateError':\n            return new FileBusyError(path || 'unknown', error);\n\n        case 'QuotaExceededError':\n            return new StorageError(`No space left on device: ${ path || 'unknown' }`, path, error);\n\n        case 'NotFoundError':\n            return new ExistenceError('file', path!, error);\n\n        case 'TypeMismatchError':\n            if (isDirectory !== undefined) {\n                if (isDirectory) {\n                    return new FileTypeError('directory', path || 'unknown', error);\n                }\n                else {\n                    return new FileTypeError('file', path || 'unknown', error);\n                }\n            }\n\n            // Fall through to default for ambiguous cases\n            return new ValidationError('argument', `Type mismatch: ${ path || 'unknown' }`, path, error);\n\n        case 'NotAllowedError':\n        case 'SecurityError':\n            return new PermissionError(path!, 'unknown', error);\n\n        case 'InvalidModificationError':\n            return new ValidationError('argument', `Invalid modification: ${ path || 'unknown' }`, path, error);\n\n        case 'AbortError':\n            return new OperationAbortedError(path || 'unknown', error);\n\n        case 'OperationError':\n            return new IOError(`Operation failed: ${ path || 'unknown' }`, path, error);\n\n        case 'TypeError':\n            return new OperationNotSupportedError(path || 'unknown', error);\n\n        default:\n            return new IOError(`I/O error: ${ path || 'unknown' }`, path, error);\n    }\n}\n","export const balanced = (a, b, str) => {\n    const ma = a instanceof RegExp ? maybeMatch(a, str) : a;\n    const mb = b instanceof RegExp ? maybeMatch(b, str) : b;\n    const r = ma !== null && mb != null && range(ma, mb, str);\n    return (r && {\n        start: r[0],\n        end: r[1],\n        pre: str.slice(0, r[0]),\n        body: str.slice(r[0] + ma.length, r[1]),\n        post: str.slice(r[1] + mb.length),\n    });\n};\nconst maybeMatch = (reg, str) => {\n    const m = str.match(reg);\n    return m ? m[0] : null;\n};\nexport const range = (a, b, str) => {\n    let begs, beg, left, right = undefined, result;\n    let ai = str.indexOf(a);\n    let bi = str.indexOf(b, ai + 1);\n    let i = ai;\n    if (ai >= 0 && bi > 0) {\n        if (a === b) {\n            return [ai, bi];\n        }\n        begs = [];\n        left = str.length;\n        while (i >= 0 && !result) {\n            if (i === ai) {\n                begs.push(i);\n                ai = str.indexOf(a, i + 1);\n            }\n            else if (begs.length === 1) {\n                const r = begs.pop();\n                if (r !== undefined)\n                    result = [r, bi];\n            }\n            else {\n                beg = begs.pop();\n                if (beg !== undefined && beg < left) {\n                    left = beg;\n                    right = bi;\n                }\n                bi = str.indexOf(b, i + 1);\n            }\n            i = ai < bi && ai >= 0 ? ai : bi;\n        }\n        if (begs.length && right !== undefined) {\n            result = [left, right];\n        }\n    }\n    return result;\n};\n//# sourceMappingURL=index.js.map","import { balanced } from '@isaacs/balanced-match';\nconst escSlash = '\\0SLASH' + Math.random() + '\\0';\nconst escOpen = '\\0OPEN' + Math.random() + '\\0';\nconst escClose = '\\0CLOSE' + Math.random() + '\\0';\nconst escComma = '\\0COMMA' + Math.random() + '\\0';\nconst escPeriod = '\\0PERIOD' + Math.random() + '\\0';\nconst escSlashPattern = new RegExp(escSlash, 'g');\nconst escOpenPattern = new RegExp(escOpen, 'g');\nconst escClosePattern = new RegExp(escClose, 'g');\nconst escCommaPattern = new RegExp(escComma, 'g');\nconst escPeriodPattern = new RegExp(escPeriod, 'g');\nconst slashPattern = /\\\\\\\\/g;\nconst openPattern = /\\\\{/g;\nconst closePattern = /\\\\}/g;\nconst commaPattern = /\\\\,/g;\nconst periodPattern = /\\\\./g;\nfunction numeric(str) {\n    return !isNaN(str) ? parseInt(str, 10) : str.charCodeAt(0);\n}\nfunction escapeBraces(str) {\n    return str\n        .replace(slashPattern, escSlash)\n        .replace(openPattern, escOpen)\n        .replace(closePattern, escClose)\n        .replace(commaPattern, escComma)\n        .replace(periodPattern, escPeriod);\n}\nfunction unescapeBraces(str) {\n    return str\n        .replace(escSlashPattern, '\\\\')\n        .replace(escOpenPattern, '{')\n        .replace(escClosePattern, '}')\n        .replace(escCommaPattern, ',')\n        .replace(escPeriodPattern, '.');\n}\n/**\n * Basically just str.split(\",\"), but handling cases\n * where we have nested braced sections, which should be\n * treated as individual members, like {a,{b,c},d}\n */\nfunction parseCommaParts(str) {\n    if (!str) {\n        return [''];\n    }\n    const parts = [];\n    const m = balanced('{', '}', str);\n    if (!m) {\n        return str.split(',');\n    }\n    const { pre, body, post } = m;\n    const p = pre.split(',');\n    p[p.length - 1] += '{' + body + '}';\n    const postParts = parseCommaParts(post);\n    if (post.length) {\n        ;\n        p[p.length - 1] += postParts.shift();\n        p.push.apply(p, postParts);\n    }\n    parts.push.apply(parts, p);\n    return parts;\n}\nexport function expand(str) {\n    if (!str) {\n        return [];\n    }\n    // I don't know why Bash 4.3 does this, but it does.\n    // Anything starting with {} will have the first two bytes preserved\n    // but *only* at the top level, so {},a}b will not expand to anything,\n    // but a{},b}c will be expanded to [a}c,abc].\n    // One could argue that this is a bug in Bash, but since the goal of\n    // this module is to match Bash's rules, we escape a leading {}\n    if (str.slice(0, 2) === '{}') {\n        str = '\\\\{\\\\}' + str.slice(2);\n    }\n    return expand_(escapeBraces(str), true).map(unescapeBraces);\n}\nfunction embrace(str) {\n    return '{' + str + '}';\n}\nfunction isPadded(el) {\n    return /^-?0\\d/.test(el);\n}\nfunction lte(i, y) {\n    return i <= y;\n}\nfunction gte(i, y) {\n    return i >= y;\n}\nfunction expand_(str, isTop) {\n    /** @type {string[]} */\n    const expansions = [];\n    const m = balanced('{', '}', str);\n    if (!m)\n        return [str];\n    // no need to expand pre, since it is guaranteed to be free of brace-sets\n    const pre = m.pre;\n    const post = m.post.length ? expand_(m.post, false) : [''];\n    if (/\\$$/.test(m.pre)) {\n        for (let k = 0; k < post.length; k++) {\n            const expansion = pre + '{' + m.body + '}' + post[k];\n            expansions.push(expansion);\n        }\n    }\n    else {\n        const isNumericSequence = /^-?\\d+\\.\\.-?\\d+(?:\\.\\.-?\\d+)?$/.test(m.body);\n        const isAlphaSequence = /^[a-zA-Z]\\.\\.[a-zA-Z](?:\\.\\.-?\\d+)?$/.test(m.body);\n        const isSequence = isNumericSequence || isAlphaSequence;\n        const isOptions = m.body.indexOf(',') >= 0;\n        if (!isSequence && !isOptions) {\n            // {a},b}\n            if (m.post.match(/,(?!,).*\\}/)) {\n                str = m.pre + '{' + m.body + escClose + m.post;\n                return expand_(str);\n            }\n            return [str];\n        }\n        let n;\n        if (isSequence) {\n            n = m.body.split(/\\.\\./);\n        }\n        else {\n            n = parseCommaParts(m.body);\n            if (n.length === 1 && n[0] !== undefined) {\n                // x{{a,b}}y ==> x{a}y x{b}y\n                n = expand_(n[0], false).map(embrace);\n                //XXX is this necessary? Can't seem to hit it in tests.\n                /* c8 ignore start */\n                if (n.length === 1) {\n                    return post.map(p => m.pre + n[0] + p);\n                }\n                /* c8 ignore stop */\n            }\n        }\n        // at this point, n is the parts, and we know it's not a comma set\n        // with a single entry.\n        let N;\n        if (isSequence && n[0] !== undefined && n[1] !== undefined) {\n            const x = numeric(n[0]);\n            const y = numeric(n[1]);\n            const width = Math.max(n[0].length, n[1].length);\n            let incr = n.length === 3 && n[2] !== undefined ? Math.abs(numeric(n[2])) : 1;\n            let test = lte;\n            const reverse = y < x;\n            if (reverse) {\n                incr *= -1;\n                test = gte;\n            }\n            const pad = n.some(isPadded);\n            N = [];\n            for (let i = x; test(i, y); i += incr) {\n                let c;\n                if (isAlphaSequence) {\n                    c = String.fromCharCode(i);\n                    if (c === '\\\\') {\n                        c = '';\n                    }\n                }\n                else {\n                    c = String(i);\n                    if (pad) {\n                        const need = width - c.length;\n                        if (need > 0) {\n                            const z = new Array(need + 1).join('0');\n                            if (i < 0) {\n                                c = '-' + z + c.slice(1);\n                            }\n                            else {\n                                c = z + c;\n                            }\n                        }\n                    }\n                }\n                N.push(c);\n            }\n        }\n        else {\n            N = [];\n            for (let j = 0; j < n.length; j++) {\n                N.push.apply(N, expand_(n[j], false));\n            }\n        }\n        for (let j = 0; j < N.length; j++) {\n            for (let k = 0; k < post.length; k++) {\n                const expansion = pre + N[j] + post[k];\n                if (!isTop || isSequence || expansion) {\n                    expansions.push(expansion);\n                }\n            }\n        }\n    }\n    return expansions;\n}\n//# sourceMappingURL=index.js.map","const MAX_PATTERN_LENGTH = 1024 * 64;\nexport const assertValidPattern = (pattern) => {\n    if (typeof pattern !== 'string') {\n        throw new TypeError('invalid pattern');\n    }\n    if (pattern.length > MAX_PATTERN_LENGTH) {\n        throw new TypeError('pattern is too long');\n    }\n};\n//# sourceMappingURL=assert-valid-pattern.js.map","// translate the various posix character classes into unicode properties\n// this works across all unicode locales\n// { <posix class>: [<translation>, /u flag required, negated]\nconst posixClasses = {\n    '[:alnum:]': ['\\\\p{L}\\\\p{Nl}\\\\p{Nd}', true],\n    '[:alpha:]': ['\\\\p{L}\\\\p{Nl}', true],\n    '[:ascii:]': ['\\\\x' + '00-\\\\x' + '7f', false],\n    '[:blank:]': ['\\\\p{Zs}\\\\t', true],\n    '[:cntrl:]': ['\\\\p{Cc}', true],\n    '[:digit:]': ['\\\\p{Nd}', true],\n    '[:graph:]': ['\\\\p{Z}\\\\p{C}', true, true],\n    '[:lower:]': ['\\\\p{Ll}', true],\n    '[:print:]': ['\\\\p{C}', true],\n    '[:punct:]': ['\\\\p{P}', true],\n    '[:space:]': ['\\\\p{Z}\\\\t\\\\r\\\\n\\\\v\\\\f', true],\n    '[:upper:]': ['\\\\p{Lu}', true],\n    '[:word:]': ['\\\\p{L}\\\\p{Nl}\\\\p{Nd}\\\\p{Pc}', true],\n    '[:xdigit:]': ['A-Fa-f0-9', false],\n};\n// only need to escape a few things inside of brace expressions\n// escapes: [ \\ ] -\nconst braceEscape = (s) => s.replace(/[[\\]\\\\-]/g, '\\\\$&');\n// escape all regexp magic characters\nconst regexpEscape = (s) => s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n// everything has already been escaped, we just have to join\nconst rangesToString = (ranges) => ranges.join('');\n// takes a glob string at a posix brace expression, and returns\n// an equivalent regular expression source, and boolean indicating\n// whether the /u flag needs to be applied, and the number of chars\n// consumed to parse the character class.\n// This also removes out of order ranges, and returns ($.) if the\n// entire class just no good.\nexport const parseClass = (glob, position) => {\n    const pos = position;\n    /* c8 ignore start */\n    if (glob.charAt(pos) !== '[') {\n        throw new Error('not in a brace expression');\n    }\n    /* c8 ignore stop */\n    const ranges = [];\n    const negs = [];\n    let i = pos + 1;\n    let sawStart = false;\n    let uflag = false;\n    let escaping = false;\n    let negate = false;\n    let endPos = pos;\n    let rangeStart = '';\n    WHILE: while (i < glob.length) {\n        const c = glob.charAt(i);\n        if ((c === '!' || c === '^') && i === pos + 1) {\n            negate = true;\n            i++;\n            continue;\n        }\n        if (c === ']' && sawStart && !escaping) {\n            endPos = i + 1;\n            break;\n        }\n        sawStart = true;\n        if (c === '\\\\') {\n            if (!escaping) {\n                escaping = true;\n                i++;\n                continue;\n            }\n            // escaped \\ char, fall through and treat like normal char\n        }\n        if (c === '[' && !escaping) {\n            // either a posix class, a collation equivalent, or just a [\n            for (const [cls, [unip, u, neg]] of Object.entries(posixClasses)) {\n                if (glob.startsWith(cls, i)) {\n                    // invalid, [a-[] is fine, but not [a-[:alpha]]\n                    if (rangeStart) {\n                        return ['$.', false, glob.length - pos, true];\n                    }\n                    i += cls.length;\n                    if (neg)\n                        negs.push(unip);\n                    else\n                        ranges.push(unip);\n                    uflag = uflag || u;\n                    continue WHILE;\n                }\n            }\n        }\n        // now it's just a normal character, effectively\n        escaping = false;\n        if (rangeStart) {\n            // throw this range away if it's not valid, but others\n            // can still match.\n            if (c > rangeStart) {\n                ranges.push(braceEscape(rangeStart) + '-' + braceEscape(c));\n            }\n            else if (c === rangeStart) {\n                ranges.push(braceEscape(c));\n            }\n            rangeStart = '';\n            i++;\n            continue;\n        }\n        // now might be the start of a range.\n        // can be either c-d or c-] or c<more...>] or c] at this point\n        if (glob.startsWith('-]', i + 1)) {\n            ranges.push(braceEscape(c + '-'));\n            i += 2;\n            continue;\n        }\n        if (glob.startsWith('-', i + 1)) {\n            rangeStart = c;\n            i += 2;\n            continue;\n        }\n        // not the start of a range, just a single character\n        ranges.push(braceEscape(c));\n        i++;\n    }\n    if (endPos < i) {\n        // didn't see the end of the class, not a valid class,\n        // but might still be valid as a literal match.\n        return ['', false, 0, false];\n    }\n    // if we got no ranges and no negates, then we have a range that\n    // cannot possibly match anything, and that poisons the whole glob\n    if (!ranges.length && !negs.length) {\n        return ['$.', false, glob.length - pos, true];\n    }\n    // if we got one positive range, and it's a single character, then that's\n    // not actually a magic pattern, it's just that one literal character.\n    // we should not treat that as \"magic\", we should just return the literal\n    // character. [_] is a perfectly valid way to escape glob magic chars.\n    if (negs.length === 0 &&\n        ranges.length === 1 &&\n        /^\\\\?.$/.test(ranges[0]) &&\n        !negate) {\n        const r = ranges[0].length === 2 ? ranges[0].slice(-1) : ranges[0];\n        return [regexpEscape(r), false, endPos - pos, false];\n    }\n    const sranges = '[' + (negate ? '^' : '') + rangesToString(ranges) + ']';\n    const snegs = '[' + (negate ? '' : '^') + rangesToString(negs) + ']';\n    const comb = ranges.length && negs.length\n        ? '(' + sranges + '|' + snegs + ')'\n        : ranges.length\n            ? sranges\n            : snegs;\n    return [comb, uflag, endPos - pos, true];\n};\n//# sourceMappingURL=brace-expressions.js.map","/**\n * Un-escape a string that has been escaped with {@link escape}.\n *\n * If the {@link windowsPathsNoEscape} option is used, then square-brace\n * escapes are removed, but not backslash escapes.  For example, it will turn\n * the string `'[*]'` into `*`, but it will not turn `'\\\\*'` into `'*'`,\n * becuase `\\` is a path separator in `windowsPathsNoEscape` mode.\n *\n * When `windowsPathsNoEscape` is not set, then both brace escapes and\n * backslash escapes are removed.\n *\n * Slashes (and backslashes in `windowsPathsNoEscape` mode) cannot be escaped\n * or unescaped.\n */\nexport const unescape = (s, { windowsPathsNoEscape = false, } = {}) => {\n    return windowsPathsNoEscape\n        ? s.replace(/\\[([^\\/\\\\])\\]/g, '$1')\n        : s.replace(/((?!\\\\).|^)\\[([^\\/\\\\])\\]/g, '$1$2').replace(/\\\\([^\\/])/g, '$1');\n};\n//# sourceMappingURL=unescape.js.map","// parse a single path portion\nimport { parseClass } from './brace-expressions.js';\nimport { unescape } from './unescape.js';\nconst types = new Set(['!', '?', '+', '*', '@']);\nconst isExtglobType = (c) => types.has(c);\n// Patterns that get prepended to bind to the start of either the\n// entire string, or just a single path portion, to prevent dots\n// and/or traversal patterns, when needed.\n// Exts don't need the ^ or / bit, because the root binds that already.\nconst startNoTraversal = '(?!(?:^|/)\\\\.\\\\.?(?:$|/))';\nconst startNoDot = '(?!\\\\.)';\n// characters that indicate a start of pattern needs the \"no dots\" bit,\n// because a dot *might* be matched. ( is not in the list, because in\n// the case of a child extglob, it will handle the prevention itself.\nconst addPatternStart = new Set(['[', '.']);\n// cases where traversal is A-OK, no dot prevention needed\nconst justDots = new Set(['..', '.']);\nconst reSpecials = new Set('().*{}+?[]^$\\\\!');\nconst regExpEscape = (s) => s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n// any single thing other than /\nconst qmark = '[^/]';\n// * => any number of characters\nconst star = qmark + '*?';\n// use + when we need to ensure that *something* matches, because the * is\n// the only thing in the path portion.\nconst starNoEmpty = qmark + '+?';\n// remove the \\ chars that we added if we end up doing a nonmagic compare\n// const deslash = (s: string) => s.replace(/\\\\(.)/g, '$1')\nexport class AST {\n    type;\n    #root;\n    #hasMagic;\n    #uflag = false;\n    #parts = [];\n    #parent;\n    #parentIndex;\n    #negs;\n    #filledNegs = false;\n    #options;\n    #toString;\n    // set to true if it's an extglob with no children\n    // (which really means one child of '')\n    #emptyExt = false;\n    constructor(type, parent, options = {}) {\n        this.type = type;\n        // extglobs are inherently magical\n        if (type)\n            this.#hasMagic = true;\n        this.#parent = parent;\n        this.#root = this.#parent ? this.#parent.#root : this;\n        this.#options = this.#root === this ? options : this.#root.#options;\n        this.#negs = this.#root === this ? [] : this.#root.#negs;\n        if (type === '!' && !this.#root.#filledNegs)\n            this.#negs.push(this);\n        this.#parentIndex = this.#parent ? this.#parent.#parts.length : 0;\n    }\n    get hasMagic() {\n        /* c8 ignore start */\n        if (this.#hasMagic !== undefined)\n            return this.#hasMagic;\n        /* c8 ignore stop */\n        for (const p of this.#parts) {\n            if (typeof p === 'string')\n                continue;\n            if (p.type || p.hasMagic)\n                return (this.#hasMagic = true);\n        }\n        // note: will be undefined until we generate the regexp src and find out\n        return this.#hasMagic;\n    }\n    // reconstructs the pattern\n    toString() {\n        if (this.#toString !== undefined)\n            return this.#toString;\n        if (!this.type) {\n            return (this.#toString = this.#parts.map(p => String(p)).join(''));\n        }\n        else {\n            return (this.#toString =\n                this.type + '(' + this.#parts.map(p => String(p)).join('|') + ')');\n        }\n    }\n    #fillNegs() {\n        /* c8 ignore start */\n        if (this !== this.#root)\n            throw new Error('should only call on root');\n        if (this.#filledNegs)\n            return this;\n        /* c8 ignore stop */\n        // call toString() once to fill this out\n        this.toString();\n        this.#filledNegs = true;\n        let n;\n        while ((n = this.#negs.pop())) {\n            if (n.type !== '!')\n                continue;\n            // walk up the tree, appending everthing that comes AFTER parentIndex\n            let p = n;\n            let pp = p.#parent;\n            while (pp) {\n                for (let i = p.#parentIndex + 1; !pp.type && i < pp.#parts.length; i++) {\n                    for (const part of n.#parts) {\n                        /* c8 ignore start */\n                        if (typeof part === 'string') {\n                            throw new Error('string part in extglob AST??');\n                        }\n                        /* c8 ignore stop */\n                        part.copyIn(pp.#parts[i]);\n                    }\n                }\n                p = pp;\n                pp = p.#parent;\n            }\n        }\n        return this;\n    }\n    push(...parts) {\n        for (const p of parts) {\n            if (p === '')\n                continue;\n            /* c8 ignore start */\n            if (typeof p !== 'string' && !(p instanceof AST && p.#parent === this)) {\n                throw new Error('invalid part: ' + p);\n            }\n            /* c8 ignore stop */\n            this.#parts.push(p);\n        }\n    }\n    toJSON() {\n        const ret = this.type === null\n            ? this.#parts.slice().map(p => (typeof p === 'string' ? p : p.toJSON()))\n            : [this.type, ...this.#parts.map(p => p.toJSON())];\n        if (this.isStart() && !this.type)\n            ret.unshift([]);\n        if (this.isEnd() &&\n            (this === this.#root ||\n                (this.#root.#filledNegs && this.#parent?.type === '!'))) {\n            ret.push({});\n        }\n        return ret;\n    }\n    isStart() {\n        if (this.#root === this)\n            return true;\n        // if (this.type) return !!this.#parent?.isStart()\n        if (!this.#parent?.isStart())\n            return false;\n        if (this.#parentIndex === 0)\n            return true;\n        // if everything AHEAD of this is a negation, then it's still the \"start\"\n        const p = this.#parent;\n        for (let i = 0; i < this.#parentIndex; i++) {\n            const pp = p.#parts[i];\n            if (!(pp instanceof AST && pp.type === '!')) {\n                return false;\n            }\n        }\n        return true;\n    }\n    isEnd() {\n        if (this.#root === this)\n            return true;\n        if (this.#parent?.type === '!')\n            return true;\n        if (!this.#parent?.isEnd())\n            return false;\n        if (!this.type)\n            return this.#parent?.isEnd();\n        // if not root, it'll always have a parent\n        /* c8 ignore start */\n        const pl = this.#parent ? this.#parent.#parts.length : 0;\n        /* c8 ignore stop */\n        return this.#parentIndex === pl - 1;\n    }\n    copyIn(part) {\n        if (typeof part === 'string')\n            this.push(part);\n        else\n            this.push(part.clone(this));\n    }\n    clone(parent) {\n        const c = new AST(this.type, parent);\n        for (const p of this.#parts) {\n            c.copyIn(p);\n        }\n        return c;\n    }\n    static #parseAST(str, ast, pos, opt) {\n        let escaping = false;\n        let inBrace = false;\n        let braceStart = -1;\n        let braceNeg = false;\n        if (ast.type === null) {\n            // outside of a extglob, append until we find a start\n            let i = pos;\n            let acc = '';\n            while (i < str.length) {\n                const c = str.charAt(i++);\n                // still accumulate escapes at this point, but we do ignore\n                // starts that are escaped\n                if (escaping || c === '\\\\') {\n                    escaping = !escaping;\n                    acc += c;\n                    continue;\n                }\n                if (inBrace) {\n                    if (i === braceStart + 1) {\n                        if (c === '^' || c === '!') {\n                            braceNeg = true;\n                        }\n                    }\n                    else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {\n                        inBrace = false;\n                    }\n                    acc += c;\n                    continue;\n                }\n                else if (c === '[') {\n                    inBrace = true;\n                    braceStart = i;\n                    braceNeg = false;\n                    acc += c;\n                    continue;\n                }\n                if (!opt.noext && isExtglobType(c) && str.charAt(i) === '(') {\n                    ast.push(acc);\n                    acc = '';\n                    const ext = new AST(c, ast);\n                    i = AST.#parseAST(str, ext, i, opt);\n                    ast.push(ext);\n                    continue;\n                }\n                acc += c;\n            }\n            ast.push(acc);\n            return i;\n        }\n        // some kind of extglob, pos is at the (\n        // find the next | or )\n        let i = pos + 1;\n        let part = new AST(null, ast);\n        const parts = [];\n        let acc = '';\n        while (i < str.length) {\n            const c = str.charAt(i++);\n            // still accumulate escapes at this point, but we do ignore\n            // starts that are escaped\n            if (escaping || c === '\\\\') {\n                escaping = !escaping;\n                acc += c;\n                continue;\n            }\n            if (inBrace) {\n                if (i === braceStart + 1) {\n                    if (c === '^' || c === '!') {\n                        braceNeg = true;\n                    }\n                }\n                else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {\n                    inBrace = false;\n                }\n                acc += c;\n                continue;\n            }\n            else if (c === '[') {\n                inBrace = true;\n                braceStart = i;\n                braceNeg = false;\n                acc += c;\n                continue;\n            }\n            if (isExtglobType(c) && str.charAt(i) === '(') {\n                part.push(acc);\n                acc = '';\n                const ext = new AST(c, part);\n                part.push(ext);\n                i = AST.#parseAST(str, ext, i, opt);\n                continue;\n            }\n            if (c === '|') {\n                part.push(acc);\n                acc = '';\n                parts.push(part);\n                part = new AST(null, ast);\n                continue;\n            }\n            if (c === ')') {\n                if (acc === '' && ast.#parts.length === 0) {\n                    ast.#emptyExt = true;\n                }\n                part.push(acc);\n                acc = '';\n                ast.push(...parts, part);\n                return i;\n            }\n            acc += c;\n        }\n        // unfinished extglob\n        // if we got here, it was a malformed extglob! not an extglob, but\n        // maybe something else in there.\n        ast.type = null;\n        ast.#hasMagic = undefined;\n        ast.#parts = [str.substring(pos - 1)];\n        return i;\n    }\n    static fromGlob(pattern, options = {}) {\n        const ast = new AST(null, undefined, options);\n        AST.#parseAST(pattern, ast, 0, options);\n        return ast;\n    }\n    // returns the regular expression if there's magic, or the unescaped\n    // string if not.\n    toMMPattern() {\n        // should only be called on root\n        /* c8 ignore start */\n        if (this !== this.#root)\n            return this.#root.toMMPattern();\n        /* c8 ignore stop */\n        const glob = this.toString();\n        const [re, body, hasMagic, uflag] = this.toRegExpSource();\n        // if we're in nocase mode, and not nocaseMagicOnly, then we do\n        // still need a regular expression if we have to case-insensitively\n        // match capital/lowercase characters.\n        const anyMagic = hasMagic ||\n            this.#hasMagic ||\n            (this.#options.nocase &&\n                !this.#options.nocaseMagicOnly &&\n                glob.toUpperCase() !== glob.toLowerCase());\n        if (!anyMagic) {\n            return body;\n        }\n        const flags = (this.#options.nocase ? 'i' : '') + (uflag ? 'u' : '');\n        return Object.assign(new RegExp(`^${re}$`, flags), {\n            _src: re,\n            _glob: glob,\n        });\n    }\n    get options() {\n        return this.#options;\n    }\n    // returns the string match, the regexp source, whether there's magic\n    // in the regexp (so a regular expression is required) and whether or\n    // not the uflag is needed for the regular expression (for posix classes)\n    // TODO: instead of injecting the start/end at this point, just return\n    // the BODY of the regexp, along with the start/end portions suitable\n    // for binding the start/end in either a joined full-path makeRe context\n    // (where we bind to (^|/), or a standalone matchPart context (where\n    // we bind to ^, and not /).  Otherwise slashes get duped!\n    //\n    // In part-matching mode, the start is:\n    // - if not isStart: nothing\n    // - if traversal possible, but not allowed: ^(?!\\.\\.?$)\n    // - if dots allowed or not possible: ^\n    // - if dots possible and not allowed: ^(?!\\.)\n    // end is:\n    // - if not isEnd(): nothing\n    // - else: $\n    //\n    // In full-path matching mode, we put the slash at the START of the\n    // pattern, so start is:\n    // - if first pattern: same as part-matching mode\n    // - if not isStart(): nothing\n    // - if traversal possible, but not allowed: /(?!\\.\\.?(?:$|/))\n    // - if dots allowed or not possible: /\n    // - if dots possible and not allowed: /(?!\\.)\n    // end is:\n    // - if last pattern, same as part-matching mode\n    // - else nothing\n    //\n    // Always put the (?:$|/) on negated tails, though, because that has to be\n    // there to bind the end of the negated pattern portion, and it's easier to\n    // just stick it in now rather than try to inject it later in the middle of\n    // the pattern.\n    //\n    // We can just always return the same end, and leave it up to the caller\n    // to know whether it's going to be used joined or in parts.\n    // And, if the start is adjusted slightly, can do the same there:\n    // - if not isStart: nothing\n    // - if traversal possible, but not allowed: (?:/|^)(?!\\.\\.?$)\n    // - if dots allowed or not possible: (?:/|^)\n    // - if dots possible and not allowed: (?:/|^)(?!\\.)\n    //\n    // But it's better to have a simpler binding without a conditional, for\n    // performance, so probably better to return both start options.\n    //\n    // Then the caller just ignores the end if it's not the first pattern,\n    // and the start always gets applied.\n    //\n    // But that's always going to be $ if it's the ending pattern, or nothing,\n    // so the caller can just attach $ at the end of the pattern when building.\n    //\n    // So the todo is:\n    // - better detect what kind of start is needed\n    // - return both flavors of starting pattern\n    // - attach $ at the end of the pattern when creating the actual RegExp\n    //\n    // Ah, but wait, no, that all only applies to the root when the first pattern\n    // is not an extglob. If the first pattern IS an extglob, then we need all\n    // that dot prevention biz to live in the extglob portions, because eg\n    // +(*|.x*) can match .xy but not .yx.\n    //\n    // So, return the two flavors if it's #root and the first child is not an\n    // AST, otherwise leave it to the child AST to handle it, and there,\n    // use the (?:^|/) style of start binding.\n    //\n    // Even simplified further:\n    // - Since the start for a join is eg /(?!\\.) and the start for a part\n    // is ^(?!\\.), we can just prepend (?!\\.) to the pattern (either root\n    // or start or whatever) and prepend ^ or / at the Regexp construction.\n    toRegExpSource(allowDot) {\n        const dot = allowDot ?? !!this.#options.dot;\n        if (this.#root === this)\n            this.#fillNegs();\n        if (!this.type) {\n            const noEmpty = this.isStart() && this.isEnd();\n            const src = this.#parts\n                .map(p => {\n                const [re, _, hasMagic, uflag] = typeof p === 'string'\n                    ? AST.#parseGlob(p, this.#hasMagic, noEmpty)\n                    : p.toRegExpSource(allowDot);\n                this.#hasMagic = this.#hasMagic || hasMagic;\n                this.#uflag = this.#uflag || uflag;\n                return re;\n            })\n                .join('');\n            let start = '';\n            if (this.isStart()) {\n                if (typeof this.#parts[0] === 'string') {\n                    // this is the string that will match the start of the pattern,\n                    // so we need to protect against dots and such.\n                    // '.' and '..' cannot match unless the pattern is that exactly,\n                    // even if it starts with . or dot:true is set.\n                    const dotTravAllowed = this.#parts.length === 1 && justDots.has(this.#parts[0]);\n                    if (!dotTravAllowed) {\n                        const aps = addPatternStart;\n                        // check if we have a possibility of matching . or ..,\n                        // and prevent that.\n                        const needNoTrav = \n                        // dots are allowed, and the pattern starts with [ or .\n                        (dot && aps.has(src.charAt(0))) ||\n                            // the pattern starts with \\., and then [ or .\n                            (src.startsWith('\\\\.') && aps.has(src.charAt(2))) ||\n                            // the pattern starts with \\.\\., and then [ or .\n                            (src.startsWith('\\\\.\\\\.') && aps.has(src.charAt(4)));\n                        // no need to prevent dots if it can't match a dot, or if a\n                        // sub-pattern will be preventing it anyway.\n                        const needNoDot = !dot && !allowDot && aps.has(src.charAt(0));\n                        start = needNoTrav ? startNoTraversal : needNoDot ? startNoDot : '';\n                    }\n                }\n            }\n            // append the \"end of path portion\" pattern to negation tails\n            let end = '';\n            if (this.isEnd() &&\n                this.#root.#filledNegs &&\n                this.#parent?.type === '!') {\n                end = '(?:$|\\\\/)';\n            }\n            const final = start + src + end;\n            return [\n                final,\n                unescape(src),\n                (this.#hasMagic = !!this.#hasMagic),\n                this.#uflag,\n            ];\n        }\n        // We need to calculate the body *twice* if it's a repeat pattern\n        // at the start, once in nodot mode, then again in dot mode, so a\n        // pattern like *(?) can match 'x.y'\n        const repeated = this.type === '*' || this.type === '+';\n        // some kind of extglob\n        const start = this.type === '!' ? '(?:(?!(?:' : '(?:';\n        let body = this.#partsToRegExp(dot);\n        if (this.isStart() && this.isEnd() && !body && this.type !== '!') {\n            // invalid extglob, has to at least be *something* present, if it's\n            // the entire path portion.\n            const s = this.toString();\n            this.#parts = [s];\n            this.type = null;\n            this.#hasMagic = undefined;\n            return [s, unescape(this.toString()), false, false];\n        }\n        // XXX abstract out this map method\n        let bodyDotAllowed = !repeated || allowDot || dot || !startNoDot\n            ? ''\n            : this.#partsToRegExp(true);\n        if (bodyDotAllowed === body) {\n            bodyDotAllowed = '';\n        }\n        if (bodyDotAllowed) {\n            body = `(?:${body})(?:${bodyDotAllowed})*?`;\n        }\n        // an empty !() is exactly equivalent to a starNoEmpty\n        let final = '';\n        if (this.type === '!' && this.#emptyExt) {\n            final = (this.isStart() && !dot ? startNoDot : '') + starNoEmpty;\n        }\n        else {\n            const close = this.type === '!'\n                ? // !() must match something,but !(x) can match ''\n                    '))' +\n                        (this.isStart() && !dot && !allowDot ? startNoDot : '') +\n                        star +\n                        ')'\n                : this.type === '@'\n                    ? ')'\n                    : this.type === '?'\n                        ? ')?'\n                        : this.type === '+' && bodyDotAllowed\n                            ? ')'\n                            : this.type === '*' && bodyDotAllowed\n                                ? `)?`\n                                : `)${this.type}`;\n            final = start + body + close;\n        }\n        return [\n            final,\n            unescape(body),\n            (this.#hasMagic = !!this.#hasMagic),\n            this.#uflag,\n        ];\n    }\n    #partsToRegExp(dot) {\n        return this.#parts\n            .map(p => {\n            // extglob ASTs should only contain parent ASTs\n            /* c8 ignore start */\n            if (typeof p === 'string') {\n                throw new Error('string type in extglob ast??');\n            }\n            /* c8 ignore stop */\n            // can ignore hasMagic, because extglobs are already always magic\n            const [re, _, _hasMagic, uflag] = p.toRegExpSource(dot);\n            this.#uflag = this.#uflag || uflag;\n            return re;\n        })\n            .filter(p => !(this.isStart() && this.isEnd()) || !!p)\n            .join('|');\n    }\n    static #parseGlob(glob, hasMagic, noEmpty = false) {\n        let escaping = false;\n        let re = '';\n        let uflag = false;\n        for (let i = 0; i < glob.length; i++) {\n            const c = glob.charAt(i);\n            if (escaping) {\n                escaping = false;\n                re += (reSpecials.has(c) ? '\\\\' : '') + c;\n                continue;\n            }\n            if (c === '\\\\') {\n                if (i === glob.length - 1) {\n                    re += '\\\\\\\\';\n                }\n                else {\n                    escaping = true;\n                }\n                continue;\n            }\n            if (c === '[') {\n                const [src, needUflag, consumed, magic] = parseClass(glob, i);\n                if (consumed) {\n                    re += src;\n                    uflag = uflag || needUflag;\n                    i += consumed - 1;\n                    hasMagic = hasMagic || magic;\n                    continue;\n                }\n            }\n            if (c === '*') {\n                if (noEmpty && glob === '*')\n                    re += starNoEmpty;\n                else\n                    re += star;\n                hasMagic = true;\n                continue;\n            }\n            if (c === '?') {\n                re += qmark;\n                hasMagic = true;\n                continue;\n            }\n            re += regExpEscape(c);\n        }\n        return [re, unescape(glob), !!hasMagic, uflag];\n    }\n}\n//# sourceMappingURL=ast.js.map","/**\n * Escape all magic characters in a glob pattern.\n *\n * If the {@link windowsPathsNoEscape | GlobOptions.windowsPathsNoEscape}\n * option is used, then characters are escaped by wrapping in `[]`, because\n * a magic character wrapped in a character class can only be satisfied by\n * that exact character.  In this mode, `\\` is _not_ escaped, because it is\n * not interpreted as a magic character, but instead as a path separator.\n */\nexport const escape = (s, { windowsPathsNoEscape = false, } = {}) => {\n    // don't need to escape +@! because we escape the parens\n    // that make those magic, and escaping ! as [!] isn't valid,\n    // because [!]] is a valid glob class meaning not ']'.\n    return windowsPathsNoEscape\n        ? s.replace(/[?*()[\\]]/g, '[$&]')\n        : s.replace(/[?*()[\\]\\\\]/g, '\\\\$&');\n};\n//# sourceMappingURL=escape.js.map","import { expand } from '@isaacs/brace-expansion';\nimport { assertValidPattern } from './assert-valid-pattern.js';\nimport { AST } from './ast.js';\nimport { escape } from './escape.js';\nimport { unescape } from './unescape.js';\nexport const minimatch = (p, pattern, options = {}) => {\n    assertValidPattern(pattern);\n    // shortcut: comments match nothing.\n    if (!options.nocomment && pattern.charAt(0) === '#') {\n        return false;\n    }\n    return new Minimatch(pattern, options).match(p);\n};\n// Optimized checking for the most common glob patterns.\nconst starDotExtRE = /^\\*+([^+@!?\\*\\[\\(]*)$/;\nconst starDotExtTest = (ext) => (f) => !f.startsWith('.') && f.endsWith(ext);\nconst starDotExtTestDot = (ext) => (f) => f.endsWith(ext);\nconst starDotExtTestNocase = (ext) => {\n    ext = ext.toLowerCase();\n    return (f) => !f.startsWith('.') && f.toLowerCase().endsWith(ext);\n};\nconst starDotExtTestNocaseDot = (ext) => {\n    ext = ext.toLowerCase();\n    return (f) => f.toLowerCase().endsWith(ext);\n};\nconst starDotStarRE = /^\\*+\\.\\*+$/;\nconst starDotStarTest = (f) => !f.startsWith('.') && f.includes('.');\nconst starDotStarTestDot = (f) => f !== '.' && f !== '..' && f.includes('.');\nconst dotStarRE = /^\\.\\*+$/;\nconst dotStarTest = (f) => f !== '.' && f !== '..' && f.startsWith('.');\nconst starRE = /^\\*+$/;\nconst starTest = (f) => f.length !== 0 && !f.startsWith('.');\nconst starTestDot = (f) => f.length !== 0 && f !== '.' && f !== '..';\nconst qmarksRE = /^\\?+([^+@!?\\*\\[\\(]*)?$/;\nconst qmarksTestNocase = ([$0, ext = '']) => {\n    const noext = qmarksTestNoExt([$0]);\n    if (!ext)\n        return noext;\n    ext = ext.toLowerCase();\n    return (f) => noext(f) && f.toLowerCase().endsWith(ext);\n};\nconst qmarksTestNocaseDot = ([$0, ext = '']) => {\n    const noext = qmarksTestNoExtDot([$0]);\n    if (!ext)\n        return noext;\n    ext = ext.toLowerCase();\n    return (f) => noext(f) && f.toLowerCase().endsWith(ext);\n};\nconst qmarksTestDot = ([$0, ext = '']) => {\n    const noext = qmarksTestNoExtDot([$0]);\n    return !ext ? noext : (f) => noext(f) && f.endsWith(ext);\n};\nconst qmarksTest = ([$0, ext = '']) => {\n    const noext = qmarksTestNoExt([$0]);\n    return !ext ? noext : (f) => noext(f) && f.endsWith(ext);\n};\nconst qmarksTestNoExt = ([$0]) => {\n    const len = $0.length;\n    return (f) => f.length === len && !f.startsWith('.');\n};\nconst qmarksTestNoExtDot = ([$0]) => {\n    const len = $0.length;\n    return (f) => f.length === len && f !== '.' && f !== '..';\n};\n/* c8 ignore start */\nconst defaultPlatform = (typeof process === 'object' && process\n    ? (typeof process.env === 'object' &&\n        process.env &&\n        process.env.__MINIMATCH_TESTING_PLATFORM__) ||\n        process.platform\n    : 'posix');\nconst path = {\n    win32: { sep: '\\\\' },\n    posix: { sep: '/' },\n};\n/* c8 ignore stop */\nexport const sep = defaultPlatform === 'win32' ? path.win32.sep : path.posix.sep;\nminimatch.sep = sep;\nexport const GLOBSTAR = Symbol('globstar **');\nminimatch.GLOBSTAR = GLOBSTAR;\n// any single thing other than /\n// don't need to escape / when using new RegExp()\nconst qmark = '[^/]';\n// * => any number of characters\nconst star = qmark + '*?';\n// ** when dots are allowed.  Anything goes, except .. and .\n// not (^ or / followed by one or two dots followed by $ or /),\n// followed by anything, any number of times.\nconst twoStarDot = '(?:(?!(?:\\\\/|^)(?:\\\\.{1,2})($|\\\\/)).)*?';\n// not a ^ or / followed by a dot,\n// followed by anything, any number of times.\nconst twoStarNoDot = '(?:(?!(?:\\\\/|^)\\\\.).)*?';\nexport const filter = (pattern, options = {}) => (p) => minimatch(p, pattern, options);\nminimatch.filter = filter;\nconst ext = (a, b = {}) => Object.assign({}, a, b);\nexport const defaults = (def) => {\n    if (!def || typeof def !== 'object' || !Object.keys(def).length) {\n        return minimatch;\n    }\n    const orig = minimatch;\n    const m = (p, pattern, options = {}) => orig(p, pattern, ext(def, options));\n    return Object.assign(m, {\n        Minimatch: class Minimatch extends orig.Minimatch {\n            constructor(pattern, options = {}) {\n                super(pattern, ext(def, options));\n            }\n            static defaults(options) {\n                return orig.defaults(ext(def, options)).Minimatch;\n            }\n        },\n        AST: class AST extends orig.AST {\n            /* c8 ignore start */\n            constructor(type, parent, options = {}) {\n                super(type, parent, ext(def, options));\n            }\n            /* c8 ignore stop */\n            static fromGlob(pattern, options = {}) {\n                return orig.AST.fromGlob(pattern, ext(def, options));\n            }\n        },\n        unescape: (s, options = {}) => orig.unescape(s, ext(def, options)),\n        escape: (s, options = {}) => orig.escape(s, ext(def, options)),\n        filter: (pattern, options = {}) => orig.filter(pattern, ext(def, options)),\n        defaults: (options) => orig.defaults(ext(def, options)),\n        makeRe: (pattern, options = {}) => orig.makeRe(pattern, ext(def, options)),\n        braceExpand: (pattern, options = {}) => orig.braceExpand(pattern, ext(def, options)),\n        match: (list, pattern, options = {}) => orig.match(list, pattern, ext(def, options)),\n        sep: orig.sep,\n        GLOBSTAR: GLOBSTAR,\n    });\n};\nminimatch.defaults = defaults;\n// Brace expansion:\n// a{b,c}d -> abd acd\n// a{b,}c -> abc ac\n// a{0..3}d -> a0d a1d a2d a3d\n// a{b,c{d,e}f}g -> abg acdfg acefg\n// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg\n//\n// Invalid sets are not expanded.\n// a{2..}b -> a{2..}b\n// a{b}c -> a{b}c\nexport const braceExpand = (pattern, options = {}) => {\n    assertValidPattern(pattern);\n    // Thanks to Yeting Li <https://github.com/yetingli> for\n    // improving this regexp to avoid a ReDOS vulnerability.\n    if (options.nobrace || !/\\{(?:(?!\\{).)*\\}/.test(pattern)) {\n        // shortcut. no need to expand.\n        return [pattern];\n    }\n    return expand(pattern);\n};\nminimatch.braceExpand = braceExpand;\n// parse a component of the expanded set.\n// At this point, no pattern may contain \"/\" in it\n// so we're going to return a 2d array, where each entry is the full\n// pattern, split on '/', and then turned into a regular expression.\n// A regexp is made at the end which joins each array with an\n// escaped /, and another full one which joins each regexp with |.\n//\n// Following the lead of Bash 4.1, note that \"**\" only has special meaning\n// when it is the *only* thing in a path portion.  Otherwise, any series\n// of * is equivalent to a single *.  Globstar behavior is enabled by\n// default, and can be disabled by setting options.noglobstar.\nexport const makeRe = (pattern, options = {}) => new Minimatch(pattern, options).makeRe();\nminimatch.makeRe = makeRe;\nexport const match = (list, pattern, options = {}) => {\n    const mm = new Minimatch(pattern, options);\n    list = list.filter(f => mm.match(f));\n    if (mm.options.nonull && !list.length) {\n        list.push(pattern);\n    }\n    return list;\n};\nminimatch.match = match;\n// replace stuff like \\* with *\nconst globMagic = /[?*]|[+@!]\\(.*?\\)|\\[|\\]/;\nconst regExpEscape = (s) => s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\nexport class Minimatch {\n    options;\n    set;\n    pattern;\n    windowsPathsNoEscape;\n    nonegate;\n    negate;\n    comment;\n    empty;\n    preserveMultipleSlashes;\n    partial;\n    globSet;\n    globParts;\n    nocase;\n    isWindows;\n    platform;\n    windowsNoMagicRoot;\n    regexp;\n    constructor(pattern, options = {}) {\n        assertValidPattern(pattern);\n        options = options || {};\n        this.options = options;\n        this.pattern = pattern;\n        this.platform = options.platform || defaultPlatform;\n        this.isWindows = this.platform === 'win32';\n        this.windowsPathsNoEscape =\n            !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;\n        if (this.windowsPathsNoEscape) {\n            this.pattern = this.pattern.replace(/\\\\/g, '/');\n        }\n        this.preserveMultipleSlashes = !!options.preserveMultipleSlashes;\n        this.regexp = null;\n        this.negate = false;\n        this.nonegate = !!options.nonegate;\n        this.comment = false;\n        this.empty = false;\n        this.partial = !!options.partial;\n        this.nocase = !!this.options.nocase;\n        this.windowsNoMagicRoot =\n            options.windowsNoMagicRoot !== undefined\n                ? options.windowsNoMagicRoot\n                : !!(this.isWindows && this.nocase);\n        this.globSet = [];\n        this.globParts = [];\n        this.set = [];\n        // make the set of regexps etc.\n        this.make();\n    }\n    hasMagic() {\n        if (this.options.magicalBraces && this.set.length > 1) {\n            return true;\n        }\n        for (const pattern of this.set) {\n            for (const part of pattern) {\n                if (typeof part !== 'string')\n                    return true;\n            }\n        }\n        return false;\n    }\n    debug(..._) { }\n    make() {\n        const pattern = this.pattern;\n        const options = this.options;\n        // empty patterns and comments match nothing.\n        if (!options.nocomment && pattern.charAt(0) === '#') {\n            this.comment = true;\n            return;\n        }\n        if (!pattern) {\n            this.empty = true;\n            return;\n        }\n        // step 1: figure out negation, etc.\n        this.parseNegate();\n        // step 2: expand braces\n        this.globSet = [...new Set(this.braceExpand())];\n        if (options.debug) {\n            this.debug = (...args) => console.error(...args);\n        }\n        this.debug(this.pattern, this.globSet);\n        // step 3: now we have a set, so turn each one into a series of\n        // path-portion matching patterns.\n        // These will be regexps, except in the case of \"**\", which is\n        // set to the GLOBSTAR object for globstar behavior,\n        // and will not contain any / characters\n        //\n        // First, we preprocess to make the glob pattern sets a bit simpler\n        // and deduped.  There are some perf-killing patterns that can cause\n        // problems with a glob walk, but we can simplify them down a bit.\n        const rawGlobParts = this.globSet.map(s => this.slashSplit(s));\n        this.globParts = this.preprocess(rawGlobParts);\n        this.debug(this.pattern, this.globParts);\n        // glob --> regexps\n        let set = this.globParts.map((s, _, __) => {\n            if (this.isWindows && this.windowsNoMagicRoot) {\n                // check if it's a drive or unc path.\n                const isUNC = s[0] === '' &&\n                    s[1] === '' &&\n                    (s[2] === '?' || !globMagic.test(s[2])) &&\n                    !globMagic.test(s[3]);\n                const isDrive = /^[a-z]:/i.test(s[0]);\n                if (isUNC) {\n                    return [...s.slice(0, 4), ...s.slice(4).map(ss => this.parse(ss))];\n                }\n                else if (isDrive) {\n                    return [s[0], ...s.slice(1).map(ss => this.parse(ss))];\n                }\n            }\n            return s.map(ss => this.parse(ss));\n        });\n        this.debug(this.pattern, set);\n        // filter out everything that didn't compile properly.\n        this.set = set.filter(s => s.indexOf(false) === -1);\n        // do not treat the ? in UNC paths as magic\n        if (this.isWindows) {\n            for (let i = 0; i < this.set.length; i++) {\n                const p = this.set[i];\n                if (p[0] === '' &&\n                    p[1] === '' &&\n                    this.globParts[i][2] === '?' &&\n                    typeof p[3] === 'string' &&\n                    /^[a-z]:$/i.test(p[3])) {\n                    p[2] = '?';\n                }\n            }\n        }\n        this.debug(this.pattern, this.set);\n    }\n    // various transforms to equivalent pattern sets that are\n    // faster to process in a filesystem walk.  The goal is to\n    // eliminate what we can, and push all ** patterns as far\n    // to the right as possible, even if it increases the number\n    // of patterns that we have to process.\n    preprocess(globParts) {\n        // if we're not in globstar mode, then turn all ** into *\n        if (this.options.noglobstar) {\n            for (let i = 0; i < globParts.length; i++) {\n                for (let j = 0; j < globParts[i].length; j++) {\n                    if (globParts[i][j] === '**') {\n                        globParts[i][j] = '*';\n                    }\n                }\n            }\n        }\n        const { optimizationLevel = 1 } = this.options;\n        if (optimizationLevel >= 2) {\n            // aggressive optimization for the purpose of fs walking\n            globParts = this.firstPhasePreProcess(globParts);\n            globParts = this.secondPhasePreProcess(globParts);\n        }\n        else if (optimizationLevel >= 1) {\n            // just basic optimizations to remove some .. parts\n            globParts = this.levelOneOptimize(globParts);\n        }\n        else {\n            // just collapse multiple ** portions into one\n            globParts = this.adjascentGlobstarOptimize(globParts);\n        }\n        return globParts;\n    }\n    // just get rid of adjascent ** portions\n    adjascentGlobstarOptimize(globParts) {\n        return globParts.map(parts => {\n            let gs = -1;\n            while (-1 !== (gs = parts.indexOf('**', gs + 1))) {\n                let i = gs;\n                while (parts[i + 1] === '**') {\n                    i++;\n                }\n                if (i !== gs) {\n                    parts.splice(gs, i - gs);\n                }\n            }\n            return parts;\n        });\n    }\n    // get rid of adjascent ** and resolve .. portions\n    levelOneOptimize(globParts) {\n        return globParts.map(parts => {\n            parts = parts.reduce((set, part) => {\n                const prev = set[set.length - 1];\n                if (part === '**' && prev === '**') {\n                    return set;\n                }\n                if (part === '..') {\n                    if (prev && prev !== '..' && prev !== '.' && prev !== '**') {\n                        set.pop();\n                        return set;\n                    }\n                }\n                set.push(part);\n                return set;\n            }, []);\n            return parts.length === 0 ? [''] : parts;\n        });\n    }\n    levelTwoFileOptimize(parts) {\n        if (!Array.isArray(parts)) {\n            parts = this.slashSplit(parts);\n        }\n        let didSomething = false;\n        do {\n            didSomething = false;\n            // <pre>/<e>/<rest> -> <pre>/<rest>\n            if (!this.preserveMultipleSlashes) {\n                for (let i = 1; i < parts.length - 1; i++) {\n                    const p = parts[i];\n                    // don't squeeze out UNC patterns\n                    if (i === 1 && p === '' && parts[0] === '')\n                        continue;\n                    if (p === '.' || p === '') {\n                        didSomething = true;\n                        parts.splice(i, 1);\n                        i--;\n                    }\n                }\n                if (parts[0] === '.' &&\n                    parts.length === 2 &&\n                    (parts[1] === '.' || parts[1] === '')) {\n                    didSomething = true;\n                    parts.pop();\n                }\n            }\n            // <pre>/<p>/../<rest> -> <pre>/<rest>\n            let dd = 0;\n            while (-1 !== (dd = parts.indexOf('..', dd + 1))) {\n                const p = parts[dd - 1];\n                if (p && p !== '.' && p !== '..' && p !== '**') {\n                    didSomething = true;\n                    parts.splice(dd - 1, 2);\n                    dd -= 2;\n                }\n            }\n        } while (didSomething);\n        return parts.length === 0 ? [''] : parts;\n    }\n    // First phase: single-pattern processing\n    // <pre> is 1 or more portions\n    // <rest> is 1 or more portions\n    // <p> is any portion other than ., .., '', or **\n    // <e> is . or ''\n    //\n    // **/.. is *brutal* for filesystem walking performance, because\n    // it effectively resets the recursive walk each time it occurs,\n    // and ** cannot be reduced out by a .. pattern part like a regexp\n    // or most strings (other than .., ., and '') can be.\n    //\n    // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}\n    // <pre>/<e>/<rest> -> <pre>/<rest>\n    // <pre>/<p>/../<rest> -> <pre>/<rest>\n    // **/**/<rest> -> **/<rest>\n    //\n    // **/*/<rest> -> */**/<rest> <== not valid because ** doesn't follow\n    // this WOULD be allowed if ** did follow symlinks, or * didn't\n    firstPhasePreProcess(globParts) {\n        let didSomething = false;\n        do {\n            didSomething = false;\n            // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}\n            for (let parts of globParts) {\n                let gs = -1;\n                while (-1 !== (gs = parts.indexOf('**', gs + 1))) {\n                    let gss = gs;\n                    while (parts[gss + 1] === '**') {\n                        // <pre>/**/**/<rest> -> <pre>/**/<rest>\n                        gss++;\n                    }\n                    // eg, if gs is 2 and gss is 4, that means we have 3 **\n                    // parts, and can remove 2 of them.\n                    if (gss > gs) {\n                        parts.splice(gs + 1, gss - gs);\n                    }\n                    let next = parts[gs + 1];\n                    const p = parts[gs + 2];\n                    const p2 = parts[gs + 3];\n                    if (next !== '..')\n                        continue;\n                    if (!p ||\n                        p === '.' ||\n                        p === '..' ||\n                        !p2 ||\n                        p2 === '.' ||\n                        p2 === '..') {\n                        continue;\n                    }\n                    didSomething = true;\n                    // edit parts in place, and push the new one\n                    parts.splice(gs, 1);\n                    const other = parts.slice(0);\n                    other[gs] = '**';\n                    globParts.push(other);\n                    gs--;\n                }\n                // <pre>/<e>/<rest> -> <pre>/<rest>\n                if (!this.preserveMultipleSlashes) {\n                    for (let i = 1; i < parts.length - 1; i++) {\n                        const p = parts[i];\n                        // don't squeeze out UNC patterns\n                        if (i === 1 && p === '' && parts[0] === '')\n                            continue;\n                        if (p === '.' || p === '') {\n                            didSomething = true;\n                            parts.splice(i, 1);\n                            i--;\n                        }\n                    }\n                    if (parts[0] === '.' &&\n                        parts.length === 2 &&\n                        (parts[1] === '.' || parts[1] === '')) {\n                        didSomething = true;\n                        parts.pop();\n                    }\n                }\n                // <pre>/<p>/../<rest> -> <pre>/<rest>\n                let dd = 0;\n                while (-1 !== (dd = parts.indexOf('..', dd + 1))) {\n                    const p = parts[dd - 1];\n                    if (p && p !== '.' && p !== '..' && p !== '**') {\n                        didSomething = true;\n                        const needDot = dd === 1 && parts[dd + 1] === '**';\n                        const splin = needDot ? ['.'] : [];\n                        parts.splice(dd - 1, 2, ...splin);\n                        if (parts.length === 0)\n                            parts.push('');\n                        dd -= 2;\n                    }\n                }\n            }\n        } while (didSomething);\n        return globParts;\n    }\n    // second phase: multi-pattern dedupes\n    // {<pre>/*/<rest>,<pre>/<p>/<rest>} -> <pre>/*/<rest>\n    // {<pre>/<rest>,<pre>/<rest>} -> <pre>/<rest>\n    // {<pre>/**/<rest>,<pre>/<rest>} -> <pre>/**/<rest>\n    //\n    // {<pre>/**/<rest>,<pre>/**/<p>/<rest>} -> <pre>/**/<rest>\n    // ^-- not valid because ** doens't follow symlinks\n    secondPhasePreProcess(globParts) {\n        for (let i = 0; i < globParts.length - 1; i++) {\n            for (let j = i + 1; j < globParts.length; j++) {\n                const matched = this.partsMatch(globParts[i], globParts[j], !this.preserveMultipleSlashes);\n                if (matched) {\n                    globParts[i] = [];\n                    globParts[j] = matched;\n                    break;\n                }\n            }\n        }\n        return globParts.filter(gs => gs.length);\n    }\n    partsMatch(a, b, emptyGSMatch = false) {\n        let ai = 0;\n        let bi = 0;\n        let result = [];\n        let which = '';\n        while (ai < a.length && bi < b.length) {\n            if (a[ai] === b[bi]) {\n                result.push(which === 'b' ? b[bi] : a[ai]);\n                ai++;\n                bi++;\n            }\n            else if (emptyGSMatch && a[ai] === '**' && b[bi] === a[ai + 1]) {\n                result.push(a[ai]);\n                ai++;\n            }\n            else if (emptyGSMatch && b[bi] === '**' && a[ai] === b[bi + 1]) {\n                result.push(b[bi]);\n                bi++;\n            }\n            else if (a[ai] === '*' &&\n                b[bi] &&\n                (this.options.dot || !b[bi].startsWith('.')) &&\n                b[bi] !== '**') {\n                if (which === 'b')\n                    return false;\n                which = 'a';\n                result.push(a[ai]);\n                ai++;\n                bi++;\n            }\n            else if (b[bi] === '*' &&\n                a[ai] &&\n                (this.options.dot || !a[ai].startsWith('.')) &&\n                a[ai] !== '**') {\n                if (which === 'a')\n                    return false;\n                which = 'b';\n                result.push(b[bi]);\n                ai++;\n                bi++;\n            }\n            else {\n                return false;\n            }\n        }\n        // if we fall out of the loop, it means they two are identical\n        // as long as their lengths match\n        return a.length === b.length && result;\n    }\n    parseNegate() {\n        if (this.nonegate)\n            return;\n        const pattern = this.pattern;\n        let negate = false;\n        let negateOffset = 0;\n        for (let i = 0; i < pattern.length && pattern.charAt(i) === '!'; i++) {\n            negate = !negate;\n            negateOffset++;\n        }\n        if (negateOffset)\n            this.pattern = pattern.slice(negateOffset);\n        this.negate = negate;\n    }\n    // set partial to true to test if, for example,\n    // \"/a/b\" matches the start of \"/*/b/*/d\"\n    // Partial means, if you run out of file before you run\n    // out of pattern, then that's fine, as long as all\n    // the parts match.\n    matchOne(file, pattern, partial = false) {\n        const options = this.options;\n        // UNC paths like //?/X:/... can match X:/... and vice versa\n        // Drive letters in absolute drive or unc paths are always compared\n        // case-insensitively.\n        if (this.isWindows) {\n            const fileDrive = typeof file[0] === 'string' && /^[a-z]:$/i.test(file[0]);\n            const fileUNC = !fileDrive &&\n                file[0] === '' &&\n                file[1] === '' &&\n                file[2] === '?' &&\n                /^[a-z]:$/i.test(file[3]);\n            const patternDrive = typeof pattern[0] === 'string' && /^[a-z]:$/i.test(pattern[0]);\n            const patternUNC = !patternDrive &&\n                pattern[0] === '' &&\n                pattern[1] === '' &&\n                pattern[2] === '?' &&\n                typeof pattern[3] === 'string' &&\n                /^[a-z]:$/i.test(pattern[3]);\n            const fdi = fileUNC ? 3 : fileDrive ? 0 : undefined;\n            const pdi = patternUNC ? 3 : patternDrive ? 0 : undefined;\n            if (typeof fdi === 'number' && typeof pdi === 'number') {\n                const [fd, pd] = [file[fdi], pattern[pdi]];\n                if (fd.toLowerCase() === pd.toLowerCase()) {\n                    pattern[pdi] = fd;\n                    if (pdi > fdi) {\n                        pattern = pattern.slice(pdi);\n                    }\n                    else if (fdi > pdi) {\n                        file = file.slice(fdi);\n                    }\n                }\n            }\n        }\n        // resolve and reduce . and .. portions in the file as well.\n        // dont' need to do the second phase, because it's only one string[]\n        const { optimizationLevel = 1 } = this.options;\n        if (optimizationLevel >= 2) {\n            file = this.levelTwoFileOptimize(file);\n        }\n        this.debug('matchOne', this, { file, pattern });\n        this.debug('matchOne', file.length, pattern.length);\n        for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {\n            this.debug('matchOne loop');\n            var p = pattern[pi];\n            var f = file[fi];\n            this.debug(pattern, p, f);\n            // should be impossible.\n            // some invalid regexp stuff in the set.\n            /* c8 ignore start */\n            if (p === false) {\n                return false;\n            }\n            /* c8 ignore stop */\n            if (p === GLOBSTAR) {\n                this.debug('GLOBSTAR', [pattern, p, f]);\n                // \"**\"\n                // a/**/b/**/c would match the following:\n                // a/b/x/y/z/c\n                // a/x/y/z/b/c\n                // a/b/x/b/x/c\n                // a/b/c\n                // To do this, take the rest of the pattern after\n                // the **, and see if it would match the file remainder.\n                // If so, return success.\n                // If not, the ** \"swallows\" a segment, and try again.\n                // This is recursively awful.\n                //\n                // a/**/b/**/c matching a/b/x/y/z/c\n                // - a matches a\n                // - doublestar\n                //   - matchOne(b/x/y/z/c, b/**/c)\n                //     - b matches b\n                //     - doublestar\n                //       - matchOne(x/y/z/c, c) -> no\n                //       - matchOne(y/z/c, c) -> no\n                //       - matchOne(z/c, c) -> no\n                //       - matchOne(c, c) yes, hit\n                var fr = fi;\n                var pr = pi + 1;\n                if (pr === pl) {\n                    this.debug('** at the end');\n                    // a ** at the end will just swallow the rest.\n                    // We have found a match.\n                    // however, it will not swallow /.x, unless\n                    // options.dot is set.\n                    // . and .. are *never* matched by **, for explosively\n                    // exponential reasons.\n                    for (; fi < fl; fi++) {\n                        if (file[fi] === '.' ||\n                            file[fi] === '..' ||\n                            (!options.dot && file[fi].charAt(0) === '.'))\n                            return false;\n                    }\n                    return true;\n                }\n                // ok, let's see if we can swallow whatever we can.\n                while (fr < fl) {\n                    var swallowee = file[fr];\n                    this.debug('\\nglobstar while', file, fr, pattern, pr, swallowee);\n                    // XXX remove this slice.  Just pass the start index.\n                    if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {\n                        this.debug('globstar found match!', fr, fl, swallowee);\n                        // found a match.\n                        return true;\n                    }\n                    else {\n                        // can't swallow \".\" or \"..\" ever.\n                        // can only swallow \".foo\" when explicitly asked.\n                        if (swallowee === '.' ||\n                            swallowee === '..' ||\n                            (!options.dot && swallowee.charAt(0) === '.')) {\n                            this.debug('dot detected!', file, fr, pattern, pr);\n                            break;\n                        }\n                        // ** swallows a segment, and continue.\n                        this.debug('globstar swallow a segment, and continue');\n                        fr++;\n                    }\n                }\n                // no match was found.\n                // However, in partial mode, we can't say this is necessarily over.\n                /* c8 ignore start */\n                if (partial) {\n                    // ran out of file\n                    this.debug('\\n>>> no match, partial?', file, fr, pattern, pr);\n                    if (fr === fl) {\n                        return true;\n                    }\n                }\n                /* c8 ignore stop */\n                return false;\n            }\n            // something other than **\n            // non-magic patterns just have to match exactly\n            // patterns with magic have been turned into regexps.\n            let hit;\n            if (typeof p === 'string') {\n                hit = f === p;\n                this.debug('string match', p, f, hit);\n            }\n            else {\n                hit = p.test(f);\n                this.debug('pattern match', p, f, hit);\n            }\n            if (!hit)\n                return false;\n        }\n        // Note: ending in / means that we'll get a final \"\"\n        // at the end of the pattern.  This can only match a\n        // corresponding \"\" at the end of the file.\n        // If the file ends in /, then it can only match a\n        // a pattern that ends in /, unless the pattern just\n        // doesn't have any more for it. But, a/b/ should *not*\n        // match \"a/b/*\", even though \"\" matches against the\n        // [^/]*? pattern, except in partial mode, where it might\n        // simply not be reached yet.\n        // However, a/b/ should still satisfy a/*\n        // now either we fell off the end of the pattern, or we're done.\n        if (fi === fl && pi === pl) {\n            // ran out of pattern and filename at the same time.\n            // an exact hit!\n            return true;\n        }\n        else if (fi === fl) {\n            // ran out of file, but still had pattern left.\n            // this is ok if we're doing the match as part of\n            // a glob fs traversal.\n            return partial;\n        }\n        else if (pi === pl) {\n            // ran out of pattern, still have file left.\n            // this is only acceptable if we're on the very last\n            // empty segment of a file with a trailing slash.\n            // a/* should match a/b/\n            return fi === fl - 1 && file[fi] === '';\n            /* c8 ignore start */\n        }\n        else {\n            // should be unreachable.\n            throw new Error('wtf?');\n        }\n        /* c8 ignore stop */\n    }\n    braceExpand() {\n        return braceExpand(this.pattern, this.options);\n    }\n    parse(pattern) {\n        assertValidPattern(pattern);\n        const options = this.options;\n        // shortcuts\n        if (pattern === '**')\n            return GLOBSTAR;\n        if (pattern === '')\n            return '';\n        // far and away, the most common glob pattern parts are\n        // *, *.*, and *.<ext>  Add a fast check method for those.\n        let m;\n        let fastTest = null;\n        if ((m = pattern.match(starRE))) {\n            fastTest = options.dot ? starTestDot : starTest;\n        }\n        else if ((m = pattern.match(starDotExtRE))) {\n            fastTest = (options.nocase\n                ? options.dot\n                    ? starDotExtTestNocaseDot\n                    : starDotExtTestNocase\n                : options.dot\n                    ? starDotExtTestDot\n                    : starDotExtTest)(m[1]);\n        }\n        else if ((m = pattern.match(qmarksRE))) {\n            fastTest = (options.nocase\n                ? options.dot\n                    ? qmarksTestNocaseDot\n                    : qmarksTestNocase\n                : options.dot\n                    ? qmarksTestDot\n                    : qmarksTest)(m);\n        }\n        else if ((m = pattern.match(starDotStarRE))) {\n            fastTest = options.dot ? starDotStarTestDot : starDotStarTest;\n        }\n        else if ((m = pattern.match(dotStarRE))) {\n            fastTest = dotStarTest;\n        }\n        const re = AST.fromGlob(pattern, this.options).toMMPattern();\n        if (fastTest && typeof re === 'object') {\n            // Avoids overriding in frozen environments\n            Reflect.defineProperty(re, 'test', { value: fastTest });\n        }\n        return re;\n    }\n    makeRe() {\n        if (this.regexp || this.regexp === false)\n            return this.regexp;\n        // at this point, this.set is a 2d array of partial\n        // pattern strings, or \"**\".\n        //\n        // It's better to use .match().  This function shouldn't\n        // be used, really, but it's pretty convenient sometimes,\n        // when you just want to work with a regex.\n        const set = this.set;\n        if (!set.length) {\n            this.regexp = false;\n            return this.regexp;\n        }\n        const options = this.options;\n        const twoStar = options.noglobstar\n            ? star\n            : options.dot\n                ? twoStarDot\n                : twoStarNoDot;\n        const flags = new Set(options.nocase ? ['i'] : []);\n        // regexpify non-globstar patterns\n        // if ** is only item, then we just do one twoStar\n        // if ** is first, and there are more, prepend (\\/|twoStar\\/)? to next\n        // if ** is last, append (\\/twoStar|) to previous\n        // if ** is in the middle, append (\\/|\\/twoStar\\/) to previous\n        // then filter out GLOBSTAR symbols\n        let re = set\n            .map(pattern => {\n            const pp = pattern.map(p => {\n                if (p instanceof RegExp) {\n                    for (const f of p.flags.split(''))\n                        flags.add(f);\n                }\n                return typeof p === 'string'\n                    ? regExpEscape(p)\n                    : p === GLOBSTAR\n                        ? GLOBSTAR\n                        : p._src;\n            });\n            pp.forEach((p, i) => {\n                const next = pp[i + 1];\n                const prev = pp[i - 1];\n                if (p !== GLOBSTAR || prev === GLOBSTAR) {\n                    return;\n                }\n                if (prev === undefined) {\n                    if (next !== undefined && next !== GLOBSTAR) {\n                        pp[i + 1] = '(?:\\\\/|' + twoStar + '\\\\/)?' + next;\n                    }\n                    else {\n                        pp[i] = twoStar;\n                    }\n                }\n                else if (next === undefined) {\n                    pp[i - 1] = prev + '(?:\\\\/|' + twoStar + ')?';\n                }\n                else if (next !== GLOBSTAR) {\n                    pp[i - 1] = prev + '(?:\\\\/|\\\\/' + twoStar + '\\\\/)' + next;\n                    pp[i + 1] = GLOBSTAR;\n                }\n            });\n            return pp.filter(p => p !== GLOBSTAR).join('/');\n        })\n            .join('|');\n        // need to wrap in parens if we had more than one thing with |,\n        // otherwise only the first will be anchored to ^ and the last to $\n        const [open, close] = set.length > 1 ? ['(?:', ')'] : ['', ''];\n        // must match entire pattern\n        // ending in a * or ** will make it less strict.\n        re = '^' + open + re + close + '$';\n        // can match anything, as long as it's not this.\n        if (this.negate)\n            re = '^(?!' + re + ').+$';\n        try {\n            this.regexp = new RegExp(re, [...flags].join(''));\n            /* c8 ignore start */\n        }\n        catch (ex) {\n            // should be impossible\n            this.regexp = false;\n        }\n        /* c8 ignore stop */\n        return this.regexp;\n    }\n    slashSplit(p) {\n        // if p starts with // on windows, we preserve that\n        // so that UNC paths aren't broken.  Otherwise, any number of\n        // / characters are coalesced into one, unless\n        // preserveMultipleSlashes is set to true.\n        if (this.preserveMultipleSlashes) {\n            return p.split('/');\n        }\n        else if (this.isWindows && /^\\/\\/[^\\/]+/.test(p)) {\n            // add an extra '' for the one we lose\n            return ['', ...p.split(/\\/+/)];\n        }\n        else {\n            return p.split(/\\/+/);\n        }\n    }\n    match(f, partial = this.partial) {\n        this.debug('match', f, this.pattern);\n        // short-circuit in the case of busted things.\n        // comments, etc.\n        if (this.comment) {\n            return false;\n        }\n        if (this.empty) {\n            return f === '';\n        }\n        if (f === '/' && partial) {\n            return true;\n        }\n        const options = this.options;\n        // windows: need to use /, not \\\n        if (this.isWindows) {\n            f = f.split('\\\\').join('/');\n        }\n        // treat the test path as a set of pathparts.\n        const ff = this.slashSplit(f);\n        this.debug(this.pattern, 'split', ff);\n        // just ONE of the pattern sets in this.set needs to match\n        // in order for it to be valid.  If negating, then just one\n        // match means that we have failed.\n        // Either way, return on the first hit.\n        const set = this.set;\n        this.debug(this.pattern, 'set', set);\n        // Find the basename of the path by looking for the last non-empty segment\n        let filename = ff[ff.length - 1];\n        if (!filename) {\n            for (let i = ff.length - 2; !filename && i >= 0; i--) {\n                filename = ff[i];\n            }\n        }\n        for (let i = 0; i < set.length; i++) {\n            const pattern = set[i];\n            let file = ff;\n            if (options.matchBase && pattern.length === 1) {\n                file = [filename];\n            }\n            const hit = this.matchOne(file, pattern, partial);\n            if (hit) {\n                if (options.flipNegate) {\n                    return true;\n                }\n                return !this.negate;\n            }\n        }\n        // didn't get any hits.  this is success if it's a negative\n        // pattern, failure otherwise.\n        if (options.flipNegate) {\n            return false;\n        }\n        return this.negate;\n    }\n    static defaults(def) {\n        return minimatch.defaults(def).Minimatch;\n    }\n}\n/* c8 ignore start */\nexport { AST } from './ast.js';\nexport { escape } from './escape.js';\nexport { unescape } from './unescape.js';\n/* c8 ignore stop */\nminimatch.AST = AST;\nminimatch.Minimatch = Minimatch;\nminimatch.escape = escape;\nminimatch.unescape = unescape;\n//# sourceMappingURL=index.js.map","import { minimatch } from 'minimatch';\n\nimport { encodeString } from './encoder';\nimport {\n    DirectoryOperationError,\n    ExistenceError,\n    FileTypeError,\n    OPFSNotSupportedError,\n    ValidationError,\n    mapDomError\n} from './errors';\n\nimport type { Encoding } from '../types';\n\n\n/**\n * Check if the browser supports the OPFS API\n * \n * @throws {OPFSNotSupportedError} If the browser does not support the OPFS API\n */\nexport function checkOPFSSupport(): void {\n    if (!('storage' in navigator) || !('getDirectory' in (navigator.storage as any))) {\n        throw new OPFSNotSupportedError();\n    }\n}\n\nexport async function withLock<T>(\n    path: string,\n    mode: 'shared' | 'exclusive',\n    fn: () => Promise<T>\n): Promise<T> {\n    if (typeof navigator !== 'undefined' && navigator.locks?.request) {\n        return navigator.locks.request(`opfs:${ path.replace(/\\/+/g, '/') }`, { mode }, fn);\n    }\n\n    return fn();\n}\n\n/** \n * Split a path into an array of segments\n * \n * @param path - The path to split\n * @returns The array of segments\n * \n * @example\n * ```typescript\n * splitPath('/path/to/file'); // ['path', 'to', 'file']\n * splitPath('~/path/to/file'); // ['path', 'to', 'file'] (home dir handled)\n * splitPath('relative/path'); // ['relative', 'path']\n * ```\n */\nexport function splitPath(path: string | string[]): string[] {\n    if (Array.isArray(path)) {\n        return path;\n    }\n\n    const normalizedPath = path.startsWith('~/') ? path.slice(2) : path;\n\n    return normalizedPath.split('/').filter(Boolean);\n}\n\n\n/**\n * Join an array of path segments into a single path\n * \n * @param segments - The array of path segments\n * @returns The joined path\n */\nexport function joinPath(segments: string[] | string): string {\n    return typeof segments === 'string'\n        ? (segments ?? '/')\n        : `/${ segments.join('/') }`;\n}\n\n/**\n * Extract the filename from a path\n * \n * @param path - The file path\n * @returns The filename without the directory path\n * \n * @example\n * ```typescript\n * basename('/path/to/file.txt'); // 'file.txt'\n * basename('/path/to/directory/'); // ''\n * basename('file.txt'); // 'file.txt'\n * ```\n */\nexport function basename(path: string): string {\n    const segments = splitPath(path);\n\n    return segments[segments.length - 1] || '';\n}\n\n/**\n * Extract the directory path from a file path\n * \n * @param path - The file path\n * @returns The directory path without the filename\n * \n * @example\n * ```typescript\n * dirname('/path/to/file.txt'); // '/path/to'\n * dirname('/path/to/directory/'); // '/path/to/directory'\n * dirname('file.txt'); // '/'\n * ```\n */\nexport function dirname(path: string): string {\n    const segments = splitPath(path);\n\n    segments.pop();\n\n    return joinPath(segments);\n}\n\n/**\n * Normalize a path to ensure it starts with '/'\n * \n * @param path - The path to normalize\n * @returns The normalized path\n * \n * @example\n * ```typescript\n * normalizePath('path/to/file'); // '/path/to/file'\n * normalizePath('/path/to/file'); // '/path/to/file'\n * normalizePath('~/path/to/file'); // '/path/to/file' (home dir normalized to root)\n * normalizePath(''); // '/'\n * ```\n */\nexport function normalizePath(path: string): string {\n    if (!path || path === '/') {\n        return '/';\n    }\n\n    if (path.startsWith('~/')) {\n        return `/${ path.slice(2) }`;\n    }\n\n    return path.startsWith('/') ? path : `/${ path }`;\n}\n\nexport function normalizeMinimatch(path: string, recursive: boolean = false): string {\n    path = path.replace(/\\/$/, '');\n    if (recursive && !path.includes('*')) {\n        return `${ path }/**`;\n    }\n\n    return path;\n}\n\nexport function matchMinimatch(path: string, pattern: string): boolean {\n    return minimatch(path, pattern, {\n        dot: true,\n        matchBase: true,\n    });\n}\n\n/**\n * Check if a path matches any of the provided exclude patterns (minimatch syntax)\n *\n * @param path - Absolute or relative path\n * @param patterns - Glob pattern(s) to match against\n * @returns true if excluded, false otherwise\n */\nexport function isPathExcluded(path: string, patterns?: string | string[]): boolean {\n    if (!patterns || (Array.isArray(patterns) && patterns.length === 0)) {\n        return false;\n    }\n\n    const normalized = normalizePath(path);\n    const list = Array.isArray(patterns) ? patterns : [patterns];\n\n    return list.some(pattern => minimatch(normalized, pattern, { dot: true }));\n}\n\n/**\n * Resolve a path to an absolute path, handling relative segments\n * \n * @param path - The path to resolve\n * @returns The resolved absolute path\n * \n * @example\n * ```typescript\n * resolvePath('./config/../data/file.txt'); // '/data/file.txt'\n * resolvePath('/path/to/../file.txt'); // '/path/file.txt'\n * resolvePath('../../file.txt'); // '/file.txt' (truncated to root)\n * resolvePath('~/config/../data/file.txt'); // '/data/file.txt' (home dir normalized to root)\n * ```\n */\nexport function resolvePath(path: string): string {\n    // First normalize the path to handle home directory references\n    const normalizedPath = normalizePath(path);\n    const segments = splitPath(normalizedPath);\n    const normalizedSegments: string[] = [];\n\n    for (const segment of segments) {\n        if (segment === '.' || segment === '') {\n            // Skip current directory references and empty segments\n            continue;\n        }\n        else if (segment === '..') {\n            if (normalizedSegments.length === 0) {\n                // Path escapes root, keep at root level\n                continue;\n            }\n\n            // Go up one directory\n            normalizedSegments.pop();\n        }\n        else {\n            normalizedSegments.push(segment);\n        }\n    }\n\n    return joinPath(normalizedSegments);\n}\n\n/**\n * Get the file extension from a path\n * \n * @param path - The file path\n * @returns The file extension including the dot, or empty string if no extension\n * \n * @example\n * ```typescript\n * extname('/path/to/file.txt'); // '.txt'\n * extname('/path/to/file'); // ''\n * extname('/path/to/file.name.ext'); // '.ext'\n * extname('/path/to/.hidden'); // ''\n * ```\n */\nexport function extname(path: string): string {\n    const filename = basename(path);\n    const lastDotIndex = filename.lastIndexOf('.');\n\n    if (lastDotIndex <= 0 || lastDotIndex === filename.length - 1) {\n        return '';\n    }\n\n    return filename.slice(lastDotIndex);\n}\n\nexport function createBuffer(data: string | Uint8Array | ArrayBuffer, encoding: Encoding = 'utf-8'): Uint8Array {\n    if (typeof data === 'string') {\n        return encodeString(data, encoding);\n    }\n\n    return data instanceof Uint8Array ? data : new Uint8Array(data);\n}\n\n/**\n * Calculate file hash using Web Crypto API\n * \n * @param buffer - The file content as File, ArrayBuffer, or Uint8Array\n * @param algorithm - Hash algorithm to use (default: 'SHA-1')\n * @param maxSize - Maximum file size in bytes. If file is larger, throws error (default: 50MB)\n * @returns Promise that resolves to the hash string\n * @throws Error if file size exceeds maxSize\n */\nexport async function calculateFileHash(\n    buffer: File | ArrayBuffer | Uint8Array,\n    algorithm: string = 'SHA-1',\n    maxSize: number = 50 * 1024 * 1024 // 50MB default\n): Promise<string> {\n    if (buffer instanceof File) {\n        buffer = await buffer.arrayBuffer();\n    }\n\n    // Check file size before processing\n    if (buffer.byteLength > maxSize) {\n        throw new Error(`File size ${ buffer.byteLength } bytes exceeds maximum allowed size ${ maxSize } bytes`);\n    }\n\n    const bufferSource = new Uint8Array(buffer);\n    const hashBuffer = await crypto.subtle.digest(algorithm, bufferSource);\n    const hashArray = Array.from(new Uint8Array(hashBuffer));\n\n    return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');\n}\n\n/**\n * Compare two Uint8Array buffers for equality\n * \n * @param a - First buffer\n * @param b - Second buffer\n * @returns true if buffers are equal, false otherwise\n */\nexport function buffersEqual(a: Uint8Array, b: Uint8Array): boolean {\n    if (a.length !== b.length) {\n        return false;\n    }\n\n    for (let i = 0; i < a.length; i++) {\n        if (a[i] !== b[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n/**\n * Convert a Blob to Uint8Array\n * \n * This function converts a Blob object to a Uint8Array for use with file operations.\n * It's useful when working with file uploads or other Blob data sources.\n * \n * @param blob - The Blob to convert\n * @returns Promise that resolves to the Uint8Array representation of the Blob\n * \n * @example\n * ```typescript\n * const fileInput = document.getElementById('file') as HTMLInputElement;\n * const file = fileInput.files?.[0];\n * if (file) {\n *   const data = await convertBlobToUint8Array(file);\n *   await fs.writeFile('/uploaded-file', data);\n * }\n * }\n * ```\n */\nexport async function convertBlobToUint8Array(blob: Blob): Promise<Uint8Array> {\n    const arrayBuffer = await blob.arrayBuffer();\n\n    return new Uint8Array(arrayBuffer);\n}\n\n/**\n * Remove a file or directory entry using a directory handle\n *\n * @param parentHandle - The parent directory handle\n * @param path - The full path of the entry to remove\n * @param options - Remove options (recursive, force, useTrash)\n */\nexport async function removeEntry(\n    parentHandle: FileSystemDirectoryHandle,\n    path: string,\n    options: { recursive?: boolean; force?: boolean; useTrash?: boolean } = {}\n): Promise<void> {\n    const name = basename(path);\n\n    return withLock(path, 'exclusive', async() => {\n        const recursive = options.recursive ?? false;\n        const force = options.force ?? false;\n\n        try {\n            await parentHandle.removeEntry(name, { recursive });\n        }\n        catch (e: any) {\n            if (e.name === 'NotFoundError') {\n                if (!force) {\n                    throw new ExistenceError('file', path, e);\n                }\n            }\n            else if (e.name === 'InvalidModificationError') {\n                throw new DirectoryOperationError('ENOTEMPTY', path, e);\n            }\n            else if (e.name === 'TypeMismatchError' && !recursive) {\n                throw new FileTypeError('directory', path, e);\n            }\n            else {\n                throw new DirectoryOperationError('RM_FAILED', path, e);\n            }\n        }\n    });\n}\n\n/**\n * Validate read/write arguments for file descriptor operations\n * \n * @param bufferLen - Length of the buffer\n * @param offset - Offset in the buffer\n * @param length - Number of bytes to read/write\n * @param position - Position in the file (null for current position)\n * @param opts - Options for validation\n * @throws {OPFSError} If arguments are invalid\n */\nexport function validateReadWriteArgs(\n    bufferLen: number,\n    offset: number,\n    length: number,\n    position: number | null | undefined\n): void {\n    if (!Number.isInteger(offset) || !Number.isInteger(length)) {\n        throw new ValidationError('argument', 'Invalid offset or length');\n    }\n\n    if (offset < 0 || length < 0) {\n        throw new ValidationError('argument', 'Negative offset or length not allowed');\n    }\n\n    if (offset + length > bufferLen) {\n        throw new ValidationError('overflow', 'Operation would overflow buffer');\n    }\n\n    if (position != null && (!Number.isInteger(position) || position < 0)) {\n        throw new ValidationError('argument', 'Invalid position');\n    }\n}\n\n/**\n * Safely close a file descriptor's sync handle\n * \n * @param fd - The file descriptor number (for logging)\n * @param syncHandle - The sync handle to close\n * @param path - The file path (for logging)\n */\nexport function safeCloseSyncHandle(fd: number, syncHandle: any, path: string): void {\n    try {\n        syncHandle.flush();\n        syncHandle.close();\n    }\n    catch (error) {\n        // Log warning but don't throw, as the fd should still be removed\n        console.warn(`Warning: Failed to properly close file descriptor ${ fd } (${ path }):`, error);\n    }\n}\n\n/**\n * Check if position is at or beyond end of file and calculate actual read length\n * \n * @param position - The position to read from\n * @param requestedLength - The requested length to read\n * @param fileSize - The current file size\n * @returns Object with isEOF flag and actual length to read\n */\nexport function calculateReadLength(position: number, requestedLength: number, fileSize: number): { isEOF: boolean; actualLength: number } {\n    // Check if we're at or beyond end of file\n    if (position >= fileSize) {\n        return { isEOF: true, actualLength: 0 };\n    }\n\n    // Calculate actual length to read (don't read beyond file end)\n    const actualLength = Math.min(requestedLength, fileSize - position);\n\n    if (actualLength <= 0) {\n        return { isEOF: true, actualLength: 0 };\n    }\n\n    return { isEOF: false, actualLength };\n}\n\n/**\n * Safely create a sync access handle with proper error mapping\n * \n * @param fileHandle - The file handle to create sync access handle from\n * @param path - The file path for error context\n * @returns Promise that resolves to FileSystemSyncAccessHandle\n * @throws {OPFSError} If creation fails\n */\nexport async function createSyncHandleSafe(\n    fileHandle: FileSystemFileHandle,\n    path: string\n): Promise<FileSystemSyncAccessHandle> {\n    try {\n        return await fileHandle.createSyncAccessHandle();\n    }\n    catch (error: any) {\n        throw mapDomError(error, { path, isDirectory: false });\n    }\n}\n","import { expose, transfer } from 'comlink';\n\nimport { WatchEventType } from './types';\nimport {\n    AlreadyExistsError,\n    DirectoryOperationError,\n    ExistenceError,\n    FileSystemOperationError,\n    FileTypeError,\n    InitializationFailedError,\n    OPFSError,\n    OperationNotSupportedError,\n    PathError,\n    ValidationError,\n    createFDError,\n    mapDomError\n} from './utils/errors';\n\nimport {\n    basename,\n    calculateFileHash,\n    calculateReadLength,\n    checkOPFSSupport,\n    convertBlobToUint8Array,\n    createSyncHandleSafe,\n    dirname,\n    joinPath,\n    matchMinimatch,\n    normalizeMinimatch,\n    normalizePath,\n    removeEntry,\n    resolvePath,\n    safeCloseSyncHandle,\n    splitPath,\n    validateReadWriteArgs,\n    withLock\n} from './utils/helpers';\n\nimport type { DirentData, FileOpenOptions, FileStat, OPFSOptions, RenameOptions, WatchEvent, WatchOptions, WatchSnapshot } from './types';\n\n\n/**\n * OPFS (Origin Private File System) File System implementation\n * \n * This class provides a high-level interface for working with the browser's\n * Origin Private File System API, offering file and directory operations\n * similar to Node.js fs module.\n * \n * @example\n * ```typescript\n * const fs = new OPFSFileSystem();\n * await fs.init('/my-app');\n * await fs.writeFile('/data/config.json', JSON.stringify({ theme: 'dark' }));\n * const config = await fs.readFile('/data/config.json');\n * ```\n */\nexport class OPFSWorker {\n    /** Root directory handle for the file system */\n    private root!: FileSystemDirectoryHandle;\n\n    /** Map of watched paths and options */\n    private watchers = new Map<string, WatchSnapshot>();\n\n    /** Promise to prevent concurrent mount operations */\n    private mountingPromise: Promise<boolean> | null = null;\n\n    /** BroadcastChannel instance for sending events */\n    private broadcastChannel: BroadcastChannel | null = null;\n\n    /** Configuration options */\n    private options: Required<OPFSOptions> = {\n        root: '/',\n        namespace: '',\n        maxFileSize: 50 * 1024 * 1024,\n        hashAlgorithm: 'etag',\n        broadcastChannel: 'opfs-worker',\n    };\n\n    /** Map of open file descriptors to their metadata */\n    private openFiles = new Map<number, {\n        path: string;\n        fileHandle: FileSystemFileHandle;\n        syncHandle: FileSystemSyncAccessHandle;\n        position: number;\n    }>();\n\n    /** Next available file descriptor number */\n    private nextFd = 1;\n\n    /**\n     * Get file info by descriptor with validation\n     * @private\n     */\n    private _getFileDescriptor(fd: number): { path: string; fileHandle: FileSystemFileHandle; syncHandle: FileSystemSyncAccessHandle; position: number } {\n        const fileInfo = this.openFiles.get(fd);\n\n        if (!fileInfo) {\n            throw new ValidationError('descriptor', `Invalid file descriptor: ${ fd }`);\n        }\n\n        return fileInfo;\n    }\n\n\n    /**\n     * Notify about internal changes to the file system\n     * \n     * This method is called by internal operations to notify clients about\n     * changes, even when no specific paths are being watched.\n     * \n     * @param path - The path that was changed\n     * @param type - The type of change (create, change, delete)\n     */\n    private async notifyChange(event: Omit<WatchEvent, 'timestamp' | 'hash' | 'namespace'>): Promise<void> {\n        // This instance not configured to send events\n        if (!this.options.broadcastChannel) {\n            return;\n        }\n\n        const path = event.path;\n\n        const match = [...this.watchers.values()].some((snapshot) => {\n            return (\n                matchMinimatch(path, snapshot.pattern)\n                && snapshot.include.some(include => include && matchMinimatch(path, include))\n                && !snapshot.exclude.some(exclude => exclude && matchMinimatch(path, exclude))\n            );\n        });\n\n        if (!match) {\n            return;\n        }\n\n        let hash: string | undefined;\n\n        if (this.options.hashAlgorithm) {\n            try {\n                const stat = await this.stat(path);\n\n                hash = stat.hash;\n            }\n            catch {}\n        }\n\n        // Send event via BroadcastChannel\n        try {\n            if (!this.broadcastChannel) {\n                this.broadcastChannel = new BroadcastChannel(this.options.broadcastChannel as string);\n            }\n\n            const watchEvent: WatchEvent = {\n                namespace: this.options.namespace,\n                timestamp: new Date().toISOString(),\n                ...event,\n                ...(hash && { hash }),\n            };\n\n            this.broadcastChannel.postMessage(watchEvent);\n        }\n        catch (error) {\n            console.warn('Failed to send event via BroadcastChannel:', error);\n        }\n    }\n\n    /**\n     * Creates a new OPFSFileSystem instance\n     * \n     * @param options - Optional configuration options\n     * @param options.root - Root path for the file system (default: '/')\n     * @param options.watchInterval - Polling interval in milliseconds for file watching\n     * @param options.hashAlgorithm - Hash algorithm for file hashing\n     * @param options.maxFileSize - Maximum file size for hashing in bytes (default: 50MB)\n     * @throws {OPFSError} If OPFS is not supported in the current browser\n     */\n    constructor(options?: OPFSOptions) {\n        checkOPFSSupport();\n\n        if (options) {\n            void this.setOptions(options);\n        }\n    }\n\n    /**\n     * Initialize the file system within a given directory\n     * \n     * This method sets up the root directory for all subsequent operations.\n     * If no root is specified, it will use the OPFS root directory.\n     * \n     * @param root - The root path for the file system (default: '/')\n     * @returns Promise that resolves to true if initialization was successful\n     * @throws {OPFSError} If initialization fails\n     * \n     * @example\n     * ```typescript\n     * const fs = new OPFSFileSystem();\n     * \n     * // Use OPFS root (default)\n     * await fs.mount();\n     * \n     * // Use custom directory\n     * await fs.mount('/my-app');\n     * ```\n     */\n    private async mount(): Promise<boolean> {\n        const root = this.options.root;\n\n        // If already mounting, wait for previous operation to complete first\n        if (this.mountingPromise) {\n            await this.mountingPromise;\n        }\n\n        // eslint-disable-next-line no-async-promise-executor\n        this.mountingPromise = new Promise<boolean>(async(resolve, reject) => {\n            try {\n                const rootDir = await navigator.storage.getDirectory();\n\n                this.root = (root === '/') ? rootDir : await this.getDirectoryHandle(root, true, rootDir);\n\n                resolve(true);\n            }\n            catch (error) {\n                reject(new InitializationFailedError(root, error));\n            }\n            finally {\n                this.mountingPromise = null;\n            }\n        });\n\n        return this.mountingPromise;\n    }\n\n\n    /**\n     * Update configuration options\n     * \n     * @param options - Configuration options to update\n     * @param options.root - Root path for the file system\n     * @param options.watchInterval - Polling interval in milliseconds for file watching\n     * @param options.hashAlgorithm - Hash algorithm for file hashing\n     * @param options.maxFileSize - Maximum file size for hashing in bytes\n     * @param options.broadcastChannel - Custom name for the broadcast channel\n     */\n    async setOptions(options: OPFSOptions): Promise<void> {\n        if (options.hashAlgorithm !== undefined) {\n            this.options.hashAlgorithm = options.hashAlgorithm;\n        }\n\n        if (options.maxFileSize !== undefined) {\n            this.options.maxFileSize = options.maxFileSize;\n        }\n\n        if (options.broadcastChannel !== undefined) {\n            // Close existing channel if name changed\n            if (this.broadcastChannel && this.options.broadcastChannel !== options.broadcastChannel) {\n                this.broadcastChannel.close();\n                this.broadcastChannel = null;\n            }\n\n            this.options.broadcastChannel = options.broadcastChannel;\n        }\n\n        if (options.namespace) {\n            this.options.namespace = options.namespace;\n        }\n\n        if (options.root !== undefined) {\n            this.options.root = normalizePath(options.root);\n\n            if (!this.options.namespace) {\n                this.options.namespace = `opfs-worker:${ this.options.root }`;\n            }\n\n            await this.mount();\n        }\n    }\n\n    /**\n     * Get a directory handle from a path\n     * \n     * Navigates through the directory structure to find or create a directory\n     * at the specified path.\n     * \n     * @param path - The path to the directory (string or array of segments)\n     * @param create - Whether to create the directory if it doesn't exist (default: false)\n     * @param from - The directory to start from (default: root directory)\n     * @returns Promise that resolves to the directory handle\n     * @throws {OPFSError} If the directory cannot be accessed or created\n     * \n     * @example\n     * ```typescript\n     * const docsDir = await fs.getDirectoryHandle('/users/john/documents', true);\n     * const docsDir2 = await fs.getDirectoryHandle(['users', 'john', 'documents'], true);\n     * ```\n     */\n    private async getDirectoryHandle(path: string | string[], create: boolean = false, from: FileSystemDirectoryHandle | null = this.root): Promise<FileSystemDirectoryHandle> {\n        const segments = Array.isArray(path) ? path : splitPath(path);\n        let current = from;\n\n        for (const segment of segments) {\n            current = await current!.getDirectoryHandle(segment, { create });\n        }\n\n        return current!;\n    }\n\n    /**\n     * Get a file handle from a path\n     * \n     * Navigates to the parent directory and retrieves or creates a file handle\n     * for the specified file path.\n     * \n     * @param path - The path to the file (string or array of segments)\n     * @param create - Whether to create the file if it doesn't exist (default: false)\n     * @param _from - The directory to start from (default: root directory)\n     * @returns Promise that resolves to the file handle\n     * @throws {PathError} If the path is empty\n     * @throws {OPFSError} If the file cannot be accessed or created\n     * \n     * @example\n     * ```typescript\n     * const fileHandle = await fs.getFileHandle('/config/settings.json', true);\n     * const fileHandle2 = await fs.getFileHandle(['config', 'settings.json'], true);\n     * ```\n     */\n    private async getFileHandle(path: string | string[], create = false, _from: FileSystemDirectoryHandle | null = this.root): Promise<FileSystemFileHandle> {\n        const segments = splitPath(path);\n\n        if (segments.length === 0) {\n            throw new PathError('Path must not be empty', Array.isArray(path) ? path.join('/') : path);\n        }\n\n        const fileName = segments.pop()!;\n        const dir = await this.getDirectoryHandle(segments, create, _from);\n\n        return dir.getFileHandle(fileName, { create });\n    }\n\n    /**\n     * Get a complete index of all files and directories in the file system\n     * \n     * This method recursively traverses the entire file system and returns\n     * a Map containing FileStat objects for every file and directory.\n     * \n     * @returns Promise that resolves to a Map of paths to FileStat objects\n     * @throws {OPFSError} If the file system is not mounted\n     * \n     * @example\n     * ```typescript\n     * const index = await fs.index();\n     * const fileStats = index.get('/data/config.json');\n     * if (fileStats) {\n     *   console.log(`File size: ${fileStats.size} bytes`);\n     *   if (fileStats.hash) console.log(`Hash: ${fileStats.hash}`);\n     * }\n     * ```\n     */\n    async index(): Promise<Map<string, FileStat>> {\n        const result = new Map<string, FileStat>();\n\n        const walk = async(dirPath: string) => {\n            const items = await this.readDir(dirPath);\n\n            for (const item of items) {\n                const fullPath = `${ dirPath === '/' ? '' : dirPath }/${ item.name }`;\n\n                try {\n                    const stat = await this.stat(fullPath);\n\n                    result.set(fullPath, stat);\n\n                    if (stat.isDirectory) {\n                        await walk(fullPath);\n                    }\n                }\n                catch (err) {\n                    console.warn(`Skipping broken entry: ${ fullPath }`, err);\n                }\n            }\n        };\n\n        result.set('/', {\n            kind: 'directory',\n            size: 0,\n            mtime: new Date(0).toISOString(),\n            ctime: new Date(0).toISOString(),\n            isFile: false,\n            isDirectory: true,\n        });\n\n        await walk('/');\n\n        return result;\n    }\n\n    /**\n     * Read a file from the file system\n     * \n     * Reads the contents of a file and returns it as binary data.\n     * \n     * @param path - The path to the file to read\n     * @returns Promise that resolves to the file contents as Uint8Array\n     * @throws {FileNotFoundError} If the file does not exist\n     * @throws {OPFSError} If reading the file fails\n     * \n     * @example\n     * ```typescript\n     * // Read as binary data\n     * const content = await fs.readFile('/config/settings.json');\n     * \n     * // Read binary file\n     * const binaryData = await fs.readFile('/images/logo.png');\n     * ```\n     */\n    async readFile(path: string): Promise<Uint8Array> {\n        await this.mount();\n\n        try {\n            return await withLock(path, 'shared', async() => {\n                const fd = await this.open(path);\n\n                try {\n                    const { size } = await this.fstat(fd);\n                    const buffer = new Uint8Array(size);\n\n                    if (size > 0) {\n                        await this.read(fd, buffer, 0, size, 0);\n                    }\n\n                    return transfer(buffer, [buffer.buffer]);\n                }\n                finally {\n                    await this.close(fd);\n                }\n            });\n        }\n        catch (err) {\n            throw new ExistenceError('file', path, err);\n        }\n    }\n\n    /**\n     * Write data to a file\n     * \n     * Creates or overwrites a file with the specified binary data. If the file already\n     * exists, it will be truncated before writing.\n     * \n     * @param path - The path to the file to write\n     * @param data - The binary data to write to the file (Uint8Array or ArrayBuffer)\n     * @returns Promise that resolves when the write operation is complete\n     * @throws {OPFSError} If writing the file fails\n     * \n     * @example\n     * ```typescript\n     * // Write binary data\n     * const binaryData = new Uint8Array([1, 2, 3, 4, 5]);\n     * await fs.writeFile('/data/binary.dat', binaryData);\n     * \n     * // Write from ArrayBuffer\n     * const arrayBuffer = new ArrayBuffer(10);\n     * await fs.writeFile('/data/buffer.dat', arrayBuffer);\n     * ```\n     */\n    async writeFile(\n        path: string,\n        data: Uint8Array | ArrayBuffer\n    ): Promise<void> {\n        await this.mount();\n\n        const buffer = data instanceof Uint8Array ? data : new Uint8Array(data);\n\n        await withLock(path, 'exclusive', async() => {\n            const existed = await this.exists(path);\n            const fd = await this.open(path, { create: true, truncate: true });\n\n            try {\n                await this.write(fd, buffer, 0, buffer.length, null, false);\n                await this.fsync(fd);\n            }\n            finally {\n                await this.close(fd);\n            }\n\n            await this.notifyChange({ path, type: existed ? WatchEventType.Changed : WatchEventType.Added, isDirectory: false });\n        });\n    }\n\n    /**\n     * Append data to a file\n     * \n     * Adds binary data to the end of an existing file. If the file doesn't exist,\n     * it will be created.\n     * \n     * @param path - The path to the file to append to\n     * @param data - The binary data to append to the file (Uint8Array or ArrayBuffer)\n     * @returns Promise that resolves when the append operation is complete\n     * @throws {OPFSError} If appending to the file fails\n     * \n     * @example\n     * ```typescript\n     * // Append binary data\n     * const additionalData = new Uint8Array([6, 7, 8]);\n     * await fs.appendFile('/data/binary.dat', additionalData);\n     * \n     * // Append from ArrayBuffer\n     * const arrayBuffer = new ArrayBuffer(5);\n     * await fs.appendFile('/data/buffer.dat', arrayBuffer);\n     * ```\n     */\n    async appendFile(\n        path: string,\n        data: Uint8Array | ArrayBuffer\n    ): Promise<void> {\n        await this.mount();\n\n        const buffer = data instanceof Uint8Array ? data : new Uint8Array(data);\n\n        await withLock(path, 'exclusive', async() => {\n            const fd = await this.open(path, { create: true });\n\n            try {\n                const { size } = await this.fstat(fd);\n\n                await this.write(fd, buffer, 0, buffer.length, size, false);\n                await this.fsync(fd);\n            }\n            finally {\n                await this.close(fd);\n            }\n\n            await this.notifyChange({ path, type: WatchEventType.Changed, isDirectory: false });\n        });\n    }\n\n    /**\n     * Create a directory\n     * \n     * Creates a new directory at the specified path. If the recursive option\n     * is enabled, parent directories will be created as needed.\n     * \n     * @param path - The path where the directory should be created\n     * @param options - Options for directory creation\n     * @param options.recursive - Whether to create parent directories if they don't exist (default: false)\n     * @returns Promise that resolves when the directory is created\n     * @throws {OPFSError} If the directory cannot be created\n     * \n     * @example\n     * ```typescript\n     * // Create a single directory\n     * await fs.mkdir('/users/john');\n     * \n     * // Create nested directories\n     * await fs.mkdir('/users/john/documents/projects', { recursive: true });\n     * ```\n     */\n    async mkdir(path: string, options?: { recursive?: boolean }): Promise<void> {\n        await this.mount();\n\n        const recursive = options?.recursive ?? false;\n        const segments = splitPath(path);\n\n        let current: FileSystemDirectoryHandle | null = this.root;\n\n        for (let i = 0; i < segments.length; i++) {\n            const segment = segments[i];\n\n            try {\n                current = await current.getDirectoryHandle(segment!, { create: recursive || i === segments.length - 1 });\n            }\n            catch (err: any) {\n                if (err.name === 'NotFoundError') {\n                    throw new ExistenceError('directory', joinPath(segments.slice(0, i + 1)), err);\n                }\n\n                if (err.name === 'TypeMismatchError') {\n                    throw new FileTypeError('file', segment!, err);\n                }\n\n                throw new FileSystemOperationError('create directory', segment!, err);\n            }\n        }\n\n        await this.notifyChange({ path, type: WatchEventType.Added, isDirectory: true });\n    }\n\n    /**\n     * Get file or directory statistics\n     * \n     * Returns detailed information about a file or directory, including\n     * size, modification time, and optionally a hash of the file content.\n     * \n     * @param path - The path to the file or directory\n     * @returns Promise that resolves to FileStat object\n     * @throws {OPFSError} If the path does not exist or cannot be accessed\n     * \n     * @example\n     * ```typescript\n     * const stats = await fs.stat('/data/config.json');\n     * console.log(`File size: ${stats.size} bytes`);\n     * console.log(`Last modified: ${stats.mtime}`);\n     * \n     * // If hashing is enabled, hash will be included\n     * if (stats.hash) {\n     *   console.log(`Hash: ${stats.hash}`);\n     * }\n     * ```\n     */\n    async stat(path: string): Promise<FileStat> {\n        await this.mount();\n\n        // Special handling for root directory\n        if (path === '/') {\n            return {\n                kind: 'directory',\n                size: 0,\n                mtime: new Date(0).toISOString(),\n                ctime: new Date(0).toISOString(),\n                isFile: false,\n                isDirectory: true,\n            };\n        }\n\n        const name = basename(path);\n        let parentDir: FileSystemDirectoryHandle;\n\n        try {\n            parentDir = await this.getDirectoryHandle(dirname(path), false);\n            const hashAlgorithm = this.options.hashAlgorithm;\n\n            const fileHandle = await parentDir.getFileHandle(name, { create: false });\n            const file = await fileHandle.getFile();\n\n            const baseStat: FileStat = {\n                kind: 'file',\n                size: file.size,\n                mtime: new Date(file.lastModified).toISOString(),\n                ctime: new Date(file.lastModified).toISOString(),\n                isFile: true,\n                isDirectory: false,\n            };\n\n            if (hashAlgorithm === 'etag') {\n                baseStat.hash = `${ file.lastModified.toString(36) }-${ file.size.toString(36) }`;\n            }\n            // Crypto hash\n            else if (typeof hashAlgorithm === 'string') {\n                try {\n                    const hash = await calculateFileHash(file, hashAlgorithm, this.options.maxFileSize);\n\n                    baseStat.hash = hash;\n                }\n                catch (error) {\n                    console.warn(`Failed to calculate hash for ${ path }:`, error);\n                }\n            }\n\n            return baseStat;\n        }\n        catch (e: any) {\n            if (e.name === 'NotFoundError') {\n                throw new ExistenceError('file', path, e);\n            }\n\n            if (e.name !== 'TypeMismatchError') {\n                throw new FileSystemOperationError('stat', path, e);\n            }\n        }\n\n        try {\n            await parentDir!.getDirectoryHandle(name, { create: false });\n\n            return {\n                kind: 'directory',\n                size: 0,\n                mtime: new Date(0).toISOString(),\n                ctime: new Date(0).toISOString(),\n                isFile: false,\n                isDirectory: true,\n            };\n        }\n        catch (e: any) {\n            throw new FileSystemOperationError('stat', path, e);\n        }\n    }\n\n    /**\n     * Read a directory's contents\n     * \n     * Lists all files and subdirectories within the specified directory.\n     * \n     * @param path - The path to the directory to read\n     * @returns Promise that resolves to an array of detailed file/directory information\n     * @throws {OPFSError} If the directory does not exist or cannot be accessed\n     * \n     * @example\n     * ```typescript\n     * // Get detailed information about files and directories\n     * const detailed = await fs.readDir('/users/john/documents');\n     * detailed.forEach(item => {\n     *   console.log(`${item.name} - ${item.isFile ? 'file' : 'directory'}`);\n     * });\n     * ```\n     */\n    async readDir(path: string): Promise<DirentData[]> {\n        await this.mount();\n\n        const dir = await this.getDirectoryHandle(path, false);\n\n        const results: DirentData[] = [];\n\n        for await (const [name, handle] of (dir as any).entries()) {\n            const isFile = handle.kind === 'file';\n\n            results.push({\n                name,\n                kind: handle.kind,\n                isFile,\n                isDirectory: !isFile,\n            });\n        }\n\n        return results;\n    }\n\n    /**\n     * Check if a file or directory exists\n     * \n     * Verifies if a file or directory exists at the specified path.\n     * \n     * @param path - The path to check\n     * @returns Promise that resolves to true if the file or directory exists, false otherwise  \n     * \n     * @example\n     * ```typescript\n     * const exists = await fs.exists('/config/settings.json');\n     * console.log(`File exists: ${exists}`);\n     * ```\n     */\n    async exists(path: string): Promise<boolean> {\n        await this.mount();\n\n        if (path === '/') {\n            return true;\n        }\n\n        const name = basename(path);\n        let dir: FileSystemDirectoryHandle | null = null;\n\n        try {\n            dir = await this.getDirectoryHandle(dirname(path), false);\n        }\n        catch (e: any) {\n            dir = null;\n\n            if (e.name !== 'NotFoundError' && e.name !== 'TypeMismatchError') {\n                throw e;\n            }\n        }\n\n        if (!dir || !name) {\n            return false;\n        }\n\n        try {\n            await dir.getFileHandle(name, { create: false });\n\n            return true;\n        }\n        catch (err: any) {\n            if (err.name !== 'NotFoundError' && err.name !== 'TypeMismatchError') {\n                throw err;\n            }\n\n            try {\n                await dir.getDirectoryHandle(name, { create: false });\n\n                return true;\n            }\n            catch (err: any) {\n                if (err.name !== 'NotFoundError' && err.name !== 'TypeMismatchError') {\n                    throw err;\n                }\n\n                return false;\n            }\n        }\n    }\n\n    /**\n     * Clear all contents of a directory without removing the directory itself\n     * \n     * Removes all files and subdirectories within the specified directory,\n     * but keeps the directory itself.\n     * \n     * @param path - The path to the directory to clear (default: '/')\n     * @returns Promise that resolves when all contents are removed\n     * @throws {OPFSError} If the operation fails\n     * \n     * @example\n     * ```typescript\n     * // Clear root directory contents\n     * await fs.clear('/');\n     * \n     * // Clear specific directory contents\n     * await fs.clear('/data');\n     * ```\n     */\n    async clear(path: string = '/'): Promise<void> {\n        await this.mount();\n\n        try {\n            const items = await this.readDir(path);\n\n            for (const item of items) {\n                const itemPath = `${ path === '/' ? '' : path }/${ item.name }`;\n\n                await this.remove(itemPath, { recursive: true });\n            }\n\n            await this.notifyChange({ path, type: WatchEventType.Changed, isDirectory: true });\n        }\n        catch (error: any) {\n            if (error instanceof OPFSError) {\n                throw error;\n            }\n\n            throw mapDomError(error, { path, isDirectory: true });\n        }\n    }\n\n    /**\n     * Remove files and directories\n     * \n     * Removes files and directories. Similar to Node.js fs.rm().\n     * \n     * @param path - The path to remove\n     * @param options - Options for removal\n     * @param options.recursive - Whether to remove directories and their contents recursively (default: false)\n     * @param options.force - Whether to ignore errors if the path doesn't exist (default: false)\n     * @returns Promise that resolves when the removal is complete\n     * @throws {OPFSError} If the removal fails\n     * \n     * @example\n     * ```typescript\n     * // Remove a file\n     * await fs.rm('/path/to/file.txt');\n     * \n     * // Remove a directory and all its contents\n     * await fs.rm('/path/to/directory', { recursive: true });\n     * \n     * // Remove with force (ignore if doesn't exist)\n     * await fs.rm('/maybe/exists', { force: true });\n     * ```\n     */\n    async remove(path: string, options?: { recursive?: boolean; force?: boolean }): Promise<void> {\n        await this.mount();\n\n        // Special handling for root directory\n        if (path === '/') {\n            throw new DirectoryOperationError('EROOT', path);\n        }\n\n        const { recursive = false, force = false } = options || {};\n\n        const parent = await this.getDirectoryHandle(dirname(path), false);\n        const stat = await this.stat(path);\n\n        await removeEntry(parent, path, { recursive, force });\n\n        await this.notifyChange({ path, type: WatchEventType.Removed, isDirectory: stat.isDirectory });\n    }\n\n    /**\n     * Resolve a path to an absolute path\n     * \n     * Resolves relative paths and normalizes path segments (like '..' and '.').\n     * Similar to Node.js fs.realpath() but without symlink resolution since OPFS doesn't support symlinks.\n     * \n     * @param path - The path to resolve\n     * @returns Promise that resolves to the absolute normalized path\n     * @throws {FileNotFoundError} If the path does not exist\n     * @throws {OPFSError} If path resolution fails\n     * \n     * @example\n     * ```typescript\n     * // Resolve relative path\n     * const absolute = await fs.realpath('./config/../data/file.txt');\n     * console.log(absolute); // '/data/file.txt'\n     * ```\n     */\n    async realpath(path: string): Promise<string> {\n        await this.mount();\n\n        try {\n            const normalizedPath = resolvePath(path);\n            const exists = await this.exists(normalizedPath);\n\n            if (!exists) {\n                throw new ExistenceError('file', normalizedPath);\n            }\n\n            return normalizedPath;\n        }\n        catch (error) {\n            if (error instanceof OPFSError) {\n                throw error;\n            }\n\n            throw mapDomError(error, { path });\n        }\n    }\n\n    /**\n     * Rename a file or directory\n     * \n     * Changes the name of a file or directory. If the target path already exists,\n     * it will be replaced only if overwrite option is enabled.\n     * \n     * @param oldPath - The current path of the file or directory\n     * @param newPath - The new path for the file or directory\n     * @param options - Options for renaming\n     * @param options.overwrite - Whether to overwrite existing files (default: false)\n     * @returns Promise that resolves when the rename operation is complete\n     * @throws {OPFSError} If the rename operation fails\n     * \n     * @example\n     * ```typescript\n     * // Basic rename (fails if target exists)\n     * await fs.rename('/old/path/file.txt', '/new/path/renamed.txt');\n     * \n     * // Rename with overwrite\n     * await fs.rename('/old/path/file.txt', '/new/path/renamed.txt', { overwrite: true });\n     * ```\n     */\n    async rename(oldPath: string, newPath: string, options?: RenameOptions): Promise<void> {\n        await this.mount();\n\n        try {\n            const overwrite = options?.overwrite ?? false;\n\n            const sourceStat = await this.stat(oldPath);\n            const destExists = await this.exists(newPath);\n\n            if (destExists && !overwrite) {\n                throw new AlreadyExistsError(newPath);\n            }\n\n            await this.copy(oldPath, newPath, { recursive: true, overwrite });\n            await this.remove(oldPath, { recursive: true });\n\n            // Notify about the rename operation\n            await this.notifyChange({ path: oldPath, type: WatchEventType.Removed, isDirectory: sourceStat.isDirectory });\n            await this.notifyChange({ path: newPath, type: WatchEventType.Added, isDirectory: sourceStat.isDirectory });\n        }\n        catch (error) {\n            if (error instanceof OPFSError) {\n                throw error;\n            }\n\n            throw mapDomError(error, { path: oldPath });\n        }\n    }\n\n    /**\n     * Copy files and directories\n     * \n     * Copies files and directories. Similar to Node.js fs.cp().\n     * \n     * @param source - The source path to copy from\n     * @param destination - The destination path to copy to\n     * @param options - Options for copying\n     * @param options.recursive - Whether to copy directories recursively (default: false)\n     * @param options.overwrite - Whether to overwrite existing files (default: true)\n     * @returns Promise that resolves when the copy operation is complete\n     * @throws {OPFSError} If the copy operation fails\n     * \n     * @example\n     * ```typescript\n     * // Copy a file\n     * await fs.copy('/source/file.txt', '/dest/file.txt');\n     * \n     * // Copy a directory and all its contents\n     * await fs.copy('/source/dir', '/dest/dir', { recursive: true });\n     * \n     * // Copy without overwriting existing files\n     * await fs.copy('/source', '/dest', { recursive: true, overwrite: false });\n     * ```\n     */\n    async copy(source: string, destination: string, options?: { recursive?: boolean; overwrite?: boolean }): Promise<void> {\n        await this.mount();\n\n        try {\n            const recursive = options?.recursive ?? false;\n            const overwrite = options?.overwrite ?? true;\n\n            const sourceExists = await this.exists(source);\n\n            if (!sourceExists) {\n                throw new ExistenceError('source', source);\n            }\n\n            const destExists = await this.exists(destination);\n\n            if (destExists && !overwrite) {\n                throw new AlreadyExistsError(destination);\n            }\n\n            const sourceStats = await this.stat(source);\n\n            if (sourceStats.isFile) {\n                const content = await this.readFile(source);\n\n                await this.writeFile(destination, content);\n            }\n            else {\n                if (!recursive) {\n                    throw new FileTypeError('directory', source);\n                }\n\n                await this.mkdir(destination, { recursive: true });\n\n                const items = await this.readDir(source);\n\n                for (const item of items) {\n                    const sourceItemPath = `${ source }/${ item.name }`;\n                    const destItemPath = `${ destination }/${ item.name }`;\n\n                    await this.copy(sourceItemPath, destItemPath, { recursive: true, overwrite });\n                }\n            }\n        }\n        catch (error) {\n            if (error instanceof OPFSError) {\n                throw error;\n            }\n\n            throw mapDomError(error, { path: source });\n        }\n    }\n\n    /**\n     * Start watching a file or directory for changes\n     * \n     * @param path - The path to watch (minimatch syntax allowed)\n     * @param options - Watch options\n     * @param options.recursive - Whether to watch recursively (default: true)\n     * @param options.exclude - Glob pattern(s) to exclude (minimatch).\n     * @returns Promise that resolves when watching starts\n     * \n     * @example\n     * ```typescript\n     * // Watch entire directory tree recursively (default)\n     * await fs.watch('/data');\n     * \n     * // Watch only immediate children (shallow)\n     * await fs.watch('/data', { recursive: false });\n     * \n     * // Watch a single file\n     * await fs.watch('/config.json', { recursive: false });\n     * \n     * // Watch all json files but not in dist directory\n     * await fs.watch('/**\\/*.json', { recursive: false, exclude: ['dist/**'] });\n     *\n     * ```\n     */\n    async watch(path: string, options?: WatchOptions): Promise<void> {\n        if (!this.options.broadcastChannel) {\n            throw new OperationNotSupportedError('This instance is not configured to send events. Please specify options.broadcastChannel to enable watching.');\n        }\n\n        const snapshot: WatchSnapshot = {\n            pattern: normalizeMinimatch(path, options?.recursive ?? true),\n            include: Array.isArray(options?.include) ? options.include : [options?.include ?? '**'],\n            exclude: Array.isArray(options?.exclude) ? options.exclude : [options?.exclude ?? ''],\n        };\n\n        this.watchers.set(path, snapshot);\n    }\n\n    /**\n     * Stop watching a previously watched path\n     */\n    unwatch(path: string): void {\n        this.watchers.delete(path);\n    }\n\n    /**\n     * Open a file and return a file descriptor\n     * \n     * @param path - The path to the file to open\n     * @param options - Options for opening the file\n     * @param options.create - Whether to create the file if it doesn't exist (default: false)\n     * @param options.exclusive - If true and create is true, fails if file already exists (default: false)\n     *                            Note: This is best-effort in OPFS, not fully atomic due to browser limitations\n     * @param options.truncate - Whether to truncate the file to zero length (default: false)\n     * @returns Promise that resolves to a file descriptor number\n     * @throws {OPFSError} If opening the file fails\n     * \n     * @example\n     * ```typescript\n     * // Open existing file for reading\n     * const fd = await fs.open('/data/config.json');\n     * \n     * // Create new file for writing\n     * const fd = await fs.open('/data/new.txt', { create: true });\n     * \n     * // Create file exclusively (fails if exists)\n     * const fd = await fs.open('/data/unique.txt', { create: true, exclusive: true });\n     * \n     * // Open and truncate file\n     * const fd = await fs.open('/data/log.txt', { create: true, truncate: true });\n     * ```\n     */\n    async open(path: string, options?: FileOpenOptions): Promise<number> {\n        await this.mount();\n\n        const { create = false, exclusive = false, truncate = false } = options || {};\n\n        // Normalize path to prevent path-related issues\n        const normalizedPath = normalizePath(resolvePath(path));\n\n        try {\n            // Use lock for atomic operations when creating files\n            if (create && exclusive) {\n                return await withLock(normalizedPath, 'exclusive', async() => {\n                    const exists = await this.exists(normalizedPath);\n\n                    if (exists) {\n                        throw new AlreadyExistsError(normalizedPath);\n                    }\n\n                    return this._openFile(normalizedPath, create, truncate);\n                });\n            }\n\n            return await this._openFile(normalizedPath, create, truncate);\n        }\n        catch (error) {\n            if (error instanceof OPFSError) {\n                throw error;\n            }\n\n            throw mapDomError(error, { path: normalizedPath, isDirectory: false });\n        }\n    }\n\n    /**\n     * Internal method to open a file (without locking)\n     * @private\n     */\n    private async _openFile(path: string, create: boolean, truncate: boolean): Promise<number> {\n        const fileHandle = await this.getFileHandle(path, create);\n\n        // Verify that we got a file handle, not a directory\n        try {\n            // If getFile() succeeds, it's a file\n            await fileHandle.getFile();\n        }\n        catch (error: any) {\n            throw mapDomError(error, { path, isDirectory: true });\n        }\n\n        // Create sync access handle safely with proper error mapping\n        const syncHandle = await createSyncHandleSafe(fileHandle, path);\n\n        // If truncate is requested, use efficient truncate() method\n        if (truncate) {\n            syncHandle.truncate(0);\n            syncHandle.flush();\n        }\n\n        const fd = this.nextFd++;\n\n        this.openFiles.set(fd, {\n            path,\n            fileHandle,\n            syncHandle,\n            position: 0,\n        });\n\n        return fd;\n    }\n\n    /**\n     * Close a file descriptor\n     * \n     * @param fd - The file descriptor to close\n     * @returns Promise that resolves when the file descriptor is closed\n     * @throws {OPFSError} If the file descriptor is invalid or closing fails\n     * \n     * @example\n     * ```typescript\n     * const fd = await fs.open('/data/file.txt');\n     * // ... use the file descriptor ...\n     * await fs.close(fd);\n     * ```\n     */\n    async close(fd: number): Promise<void> {\n        const fileInfo = this._getFileDescriptor(fd);\n\n        safeCloseSyncHandle(fd, fileInfo.syncHandle, fileInfo.path);\n\n        this.openFiles.delete(fd);\n    }\n\n    /**\n     * Read data from a file descriptor\n     * \n     * @param fd - The file descriptor to read from\n     * @param buffer - The buffer to read data into\n     * @param offset - The offset in the buffer to start writing at\n     * @param length - The number of bytes to read\n     * @param position - The position in the file to read from (null for current position)\n     * @returns Promise that resolves to the number of bytes read and the modified buffer\n     * @throws {OPFSError} If the file descriptor is invalid or reading fails\n     * \n     * @note This method uses Comlink.transfer() to efficiently pass the buffer as a Transferable Object,\n     *       ensuring zero-copy performance across Web Worker boundaries.\n     * \n     * @example\n     * ```typescript\n     * const fd = await fs.open('/data/file.txt');\n     * const buffer = new Uint8Array(1024);\n     * const { bytesRead, buffer: modifiedBuffer } = await fs.read(fd, buffer, 0, 1024, null);\n     * console.log(`Read ${bytesRead} bytes`);\n     * // Use modifiedBuffer which contains the actual data\n     * await fs.close(fd);\n     * ```\n     */\n    async read(\n        fd: number,\n        buffer: Uint8Array,\n        offset: number,\n        length: number,\n        position: number | null | undefined\n    ): Promise<{ bytesRead: number; buffer: Uint8Array }> {\n        const fileInfo = this._getFileDescriptor(fd);\n\n        // Validate arguments\n        validateReadWriteArgs(buffer.length, offset, length, position);\n\n        try {\n            const readPosition = position ?? fileInfo.position;\n\n            // Get file size and calculate read length\n            const fileSize = fileInfo.syncHandle.getSize();\n            const { isEOF, actualLength } = calculateReadLength(readPosition, length, fileSize);\n\n            if (isEOF) {\n                return transfer({ bytesRead: 0, buffer }, [buffer.buffer]); // End of file\n            }\n\n            // Create a subarray view for the read operation\n            const targetBuffer = buffer.subarray(offset, offset + actualLength);\n\n            // Perform efficient positioned read\n            const bytesRead = fileInfo.syncHandle.read(targetBuffer, { at: readPosition });\n\n            // Update position if position was not explicitly specified (null means use current position)\n            if (position == null) {\n                fileInfo.position = readPosition + bytesRead;\n            }\n\n            return transfer({ bytesRead, buffer }, [buffer.buffer]);\n        }\n        catch (error) {\n            throw createFDError('read', fd, fileInfo.path, error);\n        }\n    }\n\n    /**\n     * Write data to a file descriptor\n     * \n     * @param fd - The file descriptor to write to\n     * @param buffer - The buffer containing data to write\n     * @param offset - The offset in the buffer to start reading from (default: 0)\n     * @param length - The number of bytes to write (default: entire buffer)\n     * @param position - The position in the file to write to (null/undefined for current position)\n     * @param emitEvent - Whether to emit a change event (default: true)\n     * @returns Promise that resolves to the number of bytes written\n     * @throws {OPFSError} If the file descriptor is invalid or writing fails\n     *\n     * @example\n     * ```typescript\n     * const fd = await fs.open('/data/file.txt', { create: true });\n     * const data = new TextEncoder().encode('Hello, World!');\n     * const bytesWritten = await fs.write(fd, data, 0, data.length, null);\n     * console.log(`Wrote ${bytesWritten} bytes`);\n     * await fs.close(fd);\n     * ```\n     */\n    async write(\n        fd: number,\n        buffer: Uint8Array,\n        offset: number = 0,\n        length?: number,\n        position?: number | null | undefined,\n        emitEvent: boolean = true\n    ): Promise<number> {\n        const fileInfo = this._getFileDescriptor(fd);\n\n        // Calculate actual length to write\n        const actualLength = length ?? (buffer.length - offset);\n\n        // Validate arguments using helper\n        validateReadWriteArgs(buffer.length, offset, actualLength, position);\n\n        try {\n            // Determine write position: use specified position, or current position if null/undefined\n            const writePosition = position ?? fileInfo.position;\n\n            // Create a subarray view for the write operation\n            const sourceBuffer = buffer.subarray(offset, offset + actualLength);\n\n            // Perform efficient positioned write\n            const bytesWritten = fileInfo.syncHandle.write(sourceBuffer, { at: writePosition });\n\n            // Update position if position was null or undefined (i.e., use current position)\n            // Also update position when writing at current position (position === fileInfo.position)\n            if (position == null || position === fileInfo.position) {\n                fileInfo.position = writePosition + bytesWritten;\n            }\n\n            if (emitEvent) {\n                await this.notifyChange({ path: fileInfo.path, type: WatchEventType.Changed, isDirectory: false });\n            }\n\n            return bytesWritten;\n        }\n        catch (error) {\n            throw createFDError('write', fd, fileInfo.path, error);\n        }\n    }\n\n    /**\n     * Get file status information by file descriptor\n     * \n     * @param fd - The file descriptor\n     * @returns Promise that resolves to FileStat object\n     * @throws {OPFSError} If the file descriptor is invalid\n     * \n     * @example\n     * ```typescript\n     * const fd = await fs.open('/data/file.txt');\n     * const stats = await fs.fstat(fd);\n     * console.log(`File size: ${stats.size} bytes`);\n     * console.log(`Last modified: ${stats.mtime}`);\n     * \n     * // If hashing is enabled, hash will be included\n     * if (stats.hash) {\n     *   console.log(`Hash: ${stats.hash}`);\n     * }\n     * ```\n     */\n    async fstat(fd: number): Promise<FileStat> {\n        const fileInfo = this._getFileDescriptor(fd);\n\n        // Simply reuse existing stat() method with the file path\n        return this.stat(fileInfo.path);\n    }\n\n    /**\n     * Truncate file to specified size\n     * \n     * @param fd - The file descriptor\n     * @param size - The new size of the file (default: 0)\n     * @returns Promise that resolves when truncation is complete\n     * @throws {OPFSError} If the file descriptor is invalid or truncation fails\n     * \n     * @example\n     * ```typescript\n     * const fd = await fs.open('/data/file.txt', { create: true });\n     * await fs.truncate(fd, 100); // Truncate to 100 bytes\n     * ```\n     */\n    async ftruncate(fd: number, size: number = 0): Promise<void> {\n        const fileInfo = this._getFileDescriptor(fd);\n\n        // Validate size parameter\n        if (size < 0 || !Number.isInteger(size)) {\n            throw new ValidationError('argument', 'Invalid size');\n        }\n\n        try {\n            fileInfo.syncHandle.truncate(size);\n            fileInfo.syncHandle.flush();\n\n            // Adjust position if it's beyond the new file size\n            if (fileInfo.position > size) {\n                fileInfo.position = size;\n            }\n\n            await this.notifyChange({ path: fileInfo.path, type: WatchEventType.Changed, isDirectory: false });\n        }\n        catch (error) {\n            throw createFDError('truncate', fd, fileInfo.path, error);\n        }\n    }\n\n    /**\n     * Synchronize file data to storage (fsync equivalent)\n     * \n     * @param fd - The file descriptor\n     * @returns Promise that resolves when synchronization is complete\n     * @throws {OPFSError} If the file descriptor is invalid or sync fails\n     * \n     * @example\n     * ```typescript\n     * const fd = await fs.open('/data/file.txt', { create: true });\n     * await fs.write(fd, data);\n     * await fs.fsync(fd); // Ensure data is written to storage\n     * ```\n     */\n    async fsync(fd: number): Promise<void> {\n        const fileInfo = this._getFileDescriptor(fd);\n\n        try {\n            fileInfo.syncHandle.flush();\n        }\n        catch (error) {\n            throw createFDError('sync', fd, fileInfo.path, error);\n        }\n    }\n\n    /**\n     * Dispose of resources and clean up the file system instance\n     * \n     * This method should be called when the file system instance is no longer needed\n     * to properly clean up resources like the broadcast channel and watch timers.\n     */\n    dispose(): void {\n        if (this.broadcastChannel) {\n            this.broadcastChannel.close();\n            this.broadcastChannel = null;\n        }\n\n        this.watchers.clear();\n\n        // Close all open file descriptors\n        for (const [fd, fileInfo] of this.openFiles) {\n            safeCloseSyncHandle(fd, fileInfo.syncHandle, fileInfo.path);\n        }\n\n        this.openFiles.clear();\n        this.nextFd = 1;\n    }\n\n    /**\n     * Synchronize the file system with external data\n     * \n     * Syncs the file system with an array of entries containing paths and data.\n     * This is useful for importing data from external sources or syncing with remote data.\n     * \n     * @param entries - Array of [path, data] tuples to sync\n     * @param options - Options for synchronization\n     * @param options.cleanBefore - Whether to clear the file system before syncing (default: false)\n     * @returns Promise that resolves when synchronization is complete\n     * @throws {OPFSError} If the synchronization fails\n     * \n     * @example\n     * ```typescript\n     * // Sync with external data\n     * const entries: [string, string | Uint8Array | Blob][] = [\n     *   ['/config.json', JSON.stringify({ theme: 'dark' })],\n     *   ['/data/binary.dat', new Uint8Array([1, 2, 3, 4])],\n     *   ['/upload.txt', new Blob(['file content'], { type: 'text/plain' })]\n     * ];\n     * \n     * // Sync without clearing existing files\n     * await fs.sync(entries);\n     * \n     * // Clean file system and then sync\n     * await fs.sync(entries, { cleanBefore: true });\n     * ```\n     */\n    async createIndex(entries: [string, string | Uint8Array | Blob][]): Promise<void> {\n        await this.mount();\n\n        try {\n            for (const [path, data] of entries) {\n                const normalizedPath = normalizePath(path);\n\n                let fileData: Uint8Array;\n\n                if (data instanceof Blob) {\n                    fileData = await convertBlobToUint8Array(data);\n                }\n                else if (typeof data === 'string') {\n                    // Convert string to Uint8Array using UTF-8 encoding\n                    fileData = new TextEncoder().encode(data);\n                }\n                else {\n                    fileData = data;\n                }\n\n                await this.writeFile(normalizedPath, fileData);\n            }\n        }\n        catch (error) {\n            if (error instanceof OPFSError) {\n                throw error;\n            }\n\n            throw mapDomError(error);\n        }\n    }\n}\n\n// Only expose the worker when running in a Web Worker environment\nif (typeof globalThis !== 'undefined' && globalThis.constructor.name === 'DedicatedWorkerGlobalScope') {\n    expose(new OPFSWorker());\n}\n"],"names":["proxyMarker","createEndpoint","releaseProxy","finalizer","throwMarker","isObject","val","proxyTransferHandler","obj","port1","port2","expose","port","wrap","throwTransferHandler","value","serialized","transferHandlers","isAllowedOrigin","allowedOrigins","origin","allowedOrigin","ep","callback","ev","id","type","path","argumentList","fromWireValue","returnValue","parent","prop","rawValue","proxy","transfer","wireValue","transferables","toWireValue","closeEndPoint","error","isMessagePort","endpoint","target","pendingListeners","data","resolver","createProxy","throwIfProxyReleased","isReleased","releaseEndpoint","requestResponseMessage","proxyCounter","proxyFinalizers","newCount","registerProxy","unregisterProxy","isProxyReleased","_target","r","p","_thisArg","rawArgumentList","last","processArguments","myFlat","arr","processed","v","transferCache","transfers","name","handler","serializedValue","msg","resolve","generateUUID","WatchEventType","ERROR_CODE_TO_ERRNO","OPFSError","message","code","syscall","cause","OPFSNotSupportedError","PathError","ExistenceError","messages","PermissionError","operation","StorageError","FileBusyError","FileTypeError","actualType","ValidationError","codes","OperationAbortedError","IOError","OperationNotSupportedError","DirectoryOperationError","InitializationFailedError","FileSystemOperationError","AlreadyExistsError","createFDError","fd","errorCode","mapDomError","context","isDirectory","balanced","a","b","str","ma","maybeMatch","mb","range","reg","m","begs","beg","left","right","result","ai","bi","i","escSlash","escOpen","escClose","escComma","escPeriod","escSlashPattern","escOpenPattern","escClosePattern","escCommaPattern","escPeriodPattern","slashPattern","openPattern","closePattern","commaPattern","periodPattern","numeric","escapeBraces","unescapeBraces","parseCommaParts","parts","pre","body","post","postParts","expand","expand_","embrace","isPadded","el","lte","y","gte","isTop","expansions","k","expansion","isNumericSequence","isAlphaSequence","isSequence","isOptions","n","N","x","width","incr","test","pad","c","need","z","j","MAX_PATTERN_LENGTH","assertValidPattern","pattern","posixClasses","braceEscape","regexpEscape","rangesToString","ranges","parseClass","glob","position","pos","negs","sawStart","uflag","escaping","negate","endPos","rangeStart","WHILE","cls","unip","u","neg","sranges","snegs","unescape","windowsPathsNoEscape","types","isExtglobType","startNoTraversal","startNoDot","addPatternStart","justDots","reSpecials","regExpEscape","qmark","star","starNoEmpty","AST","#root","#hasMagic","#uflag","#parts","#parent","#parentIndex","#negs","#filledNegs","#options","#toString","#emptyExt","options","#fillNegs","pp","part","ret","pl","#parseAST","ast","opt","inBrace","braceStart","braceNeg","acc","ext","re","hasMagic","flags","allowDot","dot","noEmpty","src","_","#parseGlob","start","aps","needNoTrav","needNoDot","end","repeated","#partsToRegExp","s","bodyDotAllowed","final","close","_hasMagic","needUflag","consumed","magic","escape","minimatch","Minimatch","starDotExtRE","starDotExtTest","f","starDotExtTestDot","starDotExtTestNocase","starDotExtTestNocaseDot","starDotStarRE","starDotStarTest","starDotStarTestDot","dotStarRE","dotStarTest","starRE","starTest","starTestDot","qmarksRE","qmarksTestNocase","$0","noext","qmarksTestNoExt","qmarksTestNocaseDot","qmarksTestNoExtDot","qmarksTestDot","qmarksTest","len","defaultPlatform","sep","GLOBSTAR","twoStarDot","twoStarNoDot","filter","defaults","def","orig","list","braceExpand","makeRe","match","mm","globMagic","args","rawGlobParts","set","__","isUNC","isDrive","ss","globParts","optimizationLevel","gs","prev","didSomething","dd","gss","next","p2","other","splin","matched","emptyGSMatch","which","negateOffset","file","partial","fileDrive","fileUNC","patternDrive","patternUNC","fdi","pdi","pd","fi","pi","fl","fr","pr","swallowee","hit","fastTest","twoStar","open","ff","filename","checkOPFSSupport","withLock","mode","fn","splitPath","joinPath","segments","basename","dirname","normalizePath","normalizeMinimatch","recursive","matchMinimatch","resolvePath","normalizedPath","normalizedSegments","segment","calculateFileHash","buffer","algorithm","maxSize","bufferSource","hashBuffer","convertBlobToUint8Array","blob","arrayBuffer","removeEntry","parentHandle","force","e","validateReadWriteArgs","bufferLen","offset","length","safeCloseSyncHandle","syncHandle","calculateReadLength","requestedLength","fileSize","actualLength","createSyncHandleSafe","fileHandle","OPFSWorker","fileInfo","event","snapshot","include","exclude","hash","watchEvent","root","reject","rootDir","create","from","current","_from","fileName","walk","dirPath","items","item","fullPath","stat","err","size","existed","parentDir","hashAlgorithm","baseStat","dir","results","handle","isFile","itemPath","oldPath","newPath","overwrite","sourceStat","source","destination","content","sourceItemPath","destItemPath","exclusive","truncate","readPosition","isEOF","targetBuffer","bytesRead","emitEvent","writePosition","sourceBuffer","bytesWritten","entries","fileData"],"mappings":"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","x_google_ignoreList":[0,3,4,5,6,7,8,9,10]}